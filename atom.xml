<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凡是过去 皆为序曲</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-20T13:00:54.944Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP拥塞控制之：BBR</title>
    <link href="http://yoursite.com/2017/05/25/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8BBBR/"/>
    <id>http://yoursite.com/2017/05/25/TCP拥塞控制之BBR/</id>
    <published>2017-05-25T06:49:05.000Z</published>
    <updated>2017-06-20T13:00:54.944Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;BBR是Google在2016年提出的一种拥塞控制算法，在Linux kernel@4.9及以后的版本中已添加该算法。在Googele通过paper将BBR公布前，BBR算法应该在Google自家World Area Network中早已投入使用。Google后来提出基于SDN的B4网络（paper叫做B4，很有名的一篇paper），其拥塞控制算法也是使用的BBR。<br><a id="more"></a><br>&emsp;&emsp;丢包即拥塞的思想已经沿用了很多年，很多拥塞控制算法也是基于此的，比如当前Linux kernel的默认拥塞控制算法CUBIC，还有Reno和FAST TCP等，都是基于这一思想进行的拥塞控制。在技术受限的年代，这一思想（丢包即拥塞）没有错，但是，现在，当NIC（network interface controllers）的处理能力从Mbps升级到Gpbs，memory chips从KB升级到GB，拥塞和丢包的关系就没那么紧密了。<br>&emsp;&emsp;在现在high BDP网络环境下，丢包即拥塞思想带来的问题包括：当因为bottelneck buffers满而出现丢包时，会引起bufferbloat现象，网络延迟高；但是，当bottleneck buffers很小时，这时出现丢包，网络会误认为是发生了拥塞，从而降低发送窗口，这样就会造成low throughput。想要解决上面的问题，那么就需要抛弃基于丢包的拥塞控制思想，换个新的。</p>
<p><img src="../../../../pictures/paper read/20170525154759.png" alt=""><br>&emsp;&emsp;上图其实是两个图，只不过有共同的横坐标，想当初弱智的我看了半天，才明白这是两个图。图中的一些符号解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RTprop = round-trip propagation</div><div class="line">BtlBw = bottleneck bandwidth</div><div class="line">blue lines show the RTprop constraint;</div><div class="line">green lines show the BtlBw constraint;</div><div class="line">red lines show the bottleneck buffer;</div></pre></td></tr></table></figure></p>
<p>基于丢包的拥塞控制如图中指出的那样，其作用域在bandwidth limited，这时bottleneck buffers慢慢被填满，最后导致buffer溢出，出现丢包。在早前，memory价格较贵时，buffer sizes约等于一个link BDP，现在由于技术的进步，memory价格一直下降，buffer sizes越来越大，都快高出link BDP一个数量级。这样，delay也由以前的milliseconds升到了seconds，自然也带来了bufferbloat（缓冲区爆满，排队延迟影响网络整体性能）。其实之前有paper专门针对bottelneck buffer设置为多大给出了其研究结果，等于一个link BDP是最好的。</p>
<h3 id="Characterizing-the-bottleneck"><a href="#Characterizing-the-bottleneck" class="headerlink" title="Characterizing the bottleneck"></a>Characterizing the bottleneck</h3><p>&emsp;&emsp;要达到highest throughput和lowest delay，connection必须同时满足两个条件：</p>
<blockquote>
<ol>
<li>the bottleneck packet arrival rate equals BtlBw;</li>
<li>the total data in flight is equal to the BDP(BtlBw*Rtprop);</li>
</ol>
</blockquote>
<p>第一个条件保证bottelneck被100%的利用，第二个条件防止bottleneck出现饥饿，但又不会溢出。<br>&emsp;&emsp;因为$BtlBw$和$PTprop$在整个过程中一直是变动的，所以需要一直不断的测量。在任何时刻$t$，<br>$$RTT_t = RTprop_t + \eta_t$$<br>这里$\eta&gt;=0$表示‘noise’，比如接收端的延迟ack策略，ack aggregation策略等。因此$RTprop$是不可能准确测量的，只能估算，像大多数算法测量最小$RTT$做的那样：<br>$$\hat{RT}prop = RTprop + min(\eta_t) = min(RTT_t)$$<br>&emsp;&emsp;根据从receiver返回的ack，我们可以知道当前ack确认数据包的$RTT$和离开sender留存在网络中的确切数据包数。因为我们可以准确知道当前的发送序号snd_nxt，以及其确认序号snd_una，如果开启了SACK也可以准确知道，只不过需要walk一遍SACK段。这样我们便可以测量平均delivery rate:$deliveryRate = \deltadelivered/\deltat$。在这个过程中delivered是可以准确知道的，而\deltat则会大于真实interval，因为受网络噪声的影响，所以$delivery rate &lt;= bottleneck rate$，那么我们可以这样评估BtlBw:<br>$$\hat{BtlBw} = max(deliveryRate_t)$$</p>
<h3 id="MATCHING-THE-PACKET-FLOW-TO-THE-DELIVERY-PATH"><a href="#MATCHING-THE-PACKET-FLOW-TO-THE-DELIVERY-PATH" class="headerlink" title="MATCHING THE PACKET FLOW TO THE DELIVERY PATH"></a>MATCHING THE PACKET FLOW TO THE DELIVERY PATH</h3><p>The core BBR algorithm has two parts:</p>
<h4 id="When-an-ack-is-received"><a href="#When-an-ack-is-received" class="headerlink" title="When an ack is received"></a>When an ack is received</h4><p>&emsp;&emsp;每一个ack都会提供一个新的RTT和delivery rate值，用来更新$RTprop$和$BtlBw$，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function onAck(packet)</div><div class="line">    rtt = now - packet.sendtime</div><div class="line">    update_min_filter(RTpropFilter, rtt)</div><div class="line">    delivery_time = now</div><div class="line">    deliveryRate = (delivered - packet.delivered)/(now - packet.delivered_time)</div><div class="line">    if (deliveryRate &gt; BtlBwFilter.curentMax || !packet.app_limited)</div><div class="line">        update_max_filter(BtlBwFilter, deliveryRate)</div><div class="line">    if (app_limited_until &gt; 0)</div><div class="line">        app_limited_until -= packet.size</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在数据传输过程中，senders可能成为application limited，也就是application有机会发送更多的数据，但是没有数据可以发送，这是一个很普遍的现象。</p>
<h4 id="When-data-is-sent"><a href="#When-data-is-sent" class="headerlink" title="When data is sent"></a>When data is sent</h4><p>&emsp;&emsp;为了使packet-arrival rate和bottleneck link’s departure rate相匹配，BBR必须paces每一个数据包。$pacing<em>{rate}$是BBR的主要控制参数，另外一个参数是$cwnd</em>{gain}$，用来限定inflight为小倍数的BDP，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function send(packet)</div><div class="line">    bdp = BtlBwFilter.currentMax*RTpropFilter.currentMin</div><div class="line">    if (inflight &gt;= cwnd_gain*bdp)</div><div class="line">        //wait for ack or timeout</div><div class="line">        return</div><div class="line">    if (now &gt;= nextSendTime)</div><div class="line">        packet = nextPacketToSend()</div><div class="line">        if (!packet)</div><div class="line">            app_limited_until = inflight</div><div class="line">            return</div><div class="line">        packet.app_limited = (app_limited_until &gt; 0)</div><div class="line">        packet.sendtime = now</div><div class="line">        packet.delivered = delivered</div><div class="line">        packet.delivered_time = delivered_time</div><div class="line">        ship(packet)</div><div class="line">        nextSendTime = now + packet.size/(pacing_gain * BtlBwFilter.currentMax)</div><div class="line">    timerCallbackAt(send, nextSendTime)</div></pre></td></tr></table></figure></p>
<h4 id="Steady-state-behavior"><a href="#Steady-state-behavior" class="headerlink" title="Steady-state behavior"></a>Steady-state behavior</h4><p>&emsp;&emsp;有上面可知，测量$BtlBw$和$RTprop$都有独立的函数去完成，在bottleneck的约束下会形成一个控制循环，那么带来的效果如下图所示：<br><img src="../../../../pictures/paper read/20170620164658.png" alt=""><br>图中蓝线是RTT， 绿线是inflight，红线代表delivery rate，delivery rate上方的粗灰线表示BtlBw max filter的状态。<br>&emsp;&emsp;BBR通过保证inflight大多数时候为一个BDP来最小化delay。这样bottleneck就被转移到了sender，因为sender看不到BtlBw的变化，因此BBR需要周期性的通过$pacing_gain &gt; 1$来测量BtlBw是否变化，当发现形成queueing delay时， 将pacing_gain设为小于1便可消除queueing delay。</p>
<p><strong>总结</strong><br>&emsp;&emsp;其实BBR的思想和CUBIC相比很简单，其最终的效果据google自己说很好，本人没有实际跑过来和CUBIC、vegas、westwood等传统的拥塞控制算法做对比。不过各类拥塞控制算法都有其适用环境，具体看需求。</p>
<p><strong>参考文献：</strong><br><a href="http://delivery.acm.org/10.1145/3030000/3022184/p50-vanjacobson.pdf?ip=159.226.43.30&amp;id=3022184&amp;acc=OPEN&amp;key=33E289E220520BFB%2ED25FD1BB8C28ADF7%2E4D4702B0C3E38B35%2E6D218144511F3437&amp;CFID=950630525&amp;CFTOKEN=77242094&amp;__acm__=1497963804_1df76caeda50f66015a40a5651745817" target="_blank" rel="external">BBR Congestion-Based Congestion Control</a><br><a href="http://an.kaist.ac.kr/courses/2009/cs540/papers/Nick.pdf" target="_blank" rel="external">Sizing Router Buffers</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;BBR是Google在2016年提出的一种拥塞控制算法，在Linux kernel@4.9及以后的版本中已添加该算法。在Googele通过paper将BBR公布前，BBR算法应该在Google自家World Area Network中早已投入使用。Google后来提出基于SDN的B4网络（paper叫做B4，很有名的一篇paper），其拥塞控制算法也是使用的BBR。&lt;br&gt;
    
    </summary>
    
      <category term="私人文献阅读" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP拥塞控制之：FAST TCP</title>
    <link href="http://yoursite.com/2017/05/18/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8BFASTTCP/"/>
    <id>http://yoursite.com/2017/05/18/TCP拥塞控制之FASTTCP/</id>
    <published>2017-05-18T11:11:52.000Z</published>
    <updated>2017-05-22T01:46:18.004Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;经典的TCP拥塞控制算法TCP Reno从被提出后很长一段时间一直作为Linux kernel的默认算法，但随着Internet在规模、传输速度、负载、连接数上的增长，TCP Reno迟早会成为性能瓶颈。<br><a id="more"></a></p>
<h3 id="问题与背景"><a href="#问题与背景" class="headerlink" title="问题与背景"></a>问题与背景</h3><p>&emsp;&emsp;当前的Linux kernel的默认拥塞控制算法是于2008年提出的CUBIC，本文介绍的FAST TCP算法于2004年被提出，主要针对高速和长延迟网络，虽然有点老，但还是可以了解了解的。原文主要是和TCP Reno作比较，所以提出的问题也是针对TCP Reno的（时代所限制，如果是现在提出的算法多半是要和CUBIC作比较的）。</p>
<h4 id="TCP-Reno的问题"><a href="#TCP-Reno的问题" class="headerlink" title="TCP Reno的问题"></a>TCP Reno的问题</h4><p>&emsp;&emsp;TCP Reno在large bandwidth-delay products网络上表现差主要体现在以下四个方面（摘自原文）：</p>
<blockquote>
<ol>
<li>At the packet level, linear increase by one packet per Pound-Trip Time(RTT) is too slow, and multiplicative decrease per loss event is too drastic.</li>
<li>At teh flow level, maintaining large average congestion windows requires an extremely small equilibrium loss probability.</li>
<li>At the packet level, oscillation is unavoidable because TCP uses a binary congestion sigmal(packet loss).</li>
<li>At the flow level, the dynamics is unstable leading to severe oscillations that can only be reduced by the accurate estimation of packet loss probability and a stable design of the flow dynamics.</li>
</ol>
</blockquote>
<p>&emsp;&emsp;在前人的工作中有很多算法是基于丢包检测提出的，比如HSTCP和STCP，而FAST TCP是通过测量queueing delay来作为网络拥塞程度的参考。</p>
<h4 id="flow-level和packet-level的区别"><a href="#flow-level和packet-level的区别" class="headerlink" title="flow level和packet level的区别"></a>flow level和packet level的区别</h4><p>&emsp;&emsp;一个拥塞控制算法可以从两个level(flow level and packet level)去设计。flow level相比于packet level是一个宏观上的概念，其设计目标是达到高带宽利用率、低排队延迟和丢包、公平和稳定。而packet level是通过端到端控制的约束来设计实施那些flow level的目标。</p>
<h3 id="FAST-TCP的设计"><a href="#FAST-TCP的设计" class="headerlink" title="FAST TCP的设计"></a>FAST TCP的设计</h3><p>&emsp;&emsp;在说FAST TCP的设计之前先来看一个方程；<br>$$\check{w}_i(t) = \kappa_i(t)(1 - \frac{p_i(t)}{u_i(t)})\label{eq.Sample}$$<br>方程（1）可以用来描述各种已知的TCP拥塞控制算法，不同的拥塞控制算法的区别在于它们对gain function$\kappa_i$和marginal utility function$u_i$以及congestion measures $p_i$是丢失率还是排队延迟。<br>&emsp;&emsp;当然啦，FAST TCP与其他的拥塞控制算法的区别也是在那三个函数的选择上。下面对这三个函数的作用简单介绍下（还是摘自原文，翻译真的很麻烦）。</p>
<blockquote>
<p><strong>$\kappa_i$:</strong> the choice of the gain function $\kappa_i$ determines the dynamic properties sush as stability and responsiveness, but does not affect the equilibrium properties.<br><strong>$u_i$:</strong> the choice of the marginal utility function $u_i$ mainly determines equilibrium properties such as the equilibrium rate allocation and its fairness.<br><strong>$p_i$:</strong> in the absence of explicit feedback, the choice of congestion measure $p_i$ is limited to loss probability or queueing delay. The dynamics of $p_i(t)$ is determined at links.</p>
</blockquote>
<h4 id="implementation-strategy"><a href="#implementation-strategy" class="headerlink" title="implementation strategy"></a>implementation strategy</h4><p>&emsp;&emsp;FAST TCP 通过适当的flow and packet level 设计来解决上文提到的TCP Reno 在large windows环境下所遇到的四个问题。<br>&emsp;&emsp;首先，评估当前状态$\frac{p_i(t)}{u_i(t)}$距equilibrium（值为1）有多远，如果当前状态接近于equilibrium，那么就缓慢调整window，反之，则激进一点调整。而在TCP Reno中，其窗口调整取决于当前窗口大小。基于delay的方法避免了在TCP Reno中window缓慢增长，迅速下降的问题。<br>&emsp;&emsp;其次，选择一个multi-bit 的拥塞测试，消除由于binary feedback造成的packet level oscillation。这里binary feedback表示window要么增，要么降，没有其他选择。<br>&emsp;&emsp;最后，拥塞测量函数$p_i(t)$采用测量queueing delay而不是测量loss probability，通过调整window从而控制queueing delay可以使网络稳定在overflowing point的下方区域，如下图（b）中的F点。这样既消除了高queueing<br>delay，又避免了不必要的数据包丢失。更重要的是，这样还保留了root for buffering “mice” traffic。<br><img src="../../../../pictures/TCP/20170519171625.png" alt=""></p>
<h3 id="FAST-TCP的架构和算法"><a href="#FAST-TCP的架构和算法" class="headerlink" title="FAST TCP的架构和算法"></a>FAST TCP的架构和算法</h3><p>&emsp;&emsp;在FAST TCP这篇paper中， 将TCP拥塞控制机制分割成了四部分，这四部分功能相互独立，以便能够设计分离和异步升级。如下图所示，FAST TCP的架构。<br><img src="../../../../pictures/TCP/20170520104134.png" alt=""><br>&emsp;&emsp;其中，data control 部分决定发送那些数据包，window contorl部分决定可以发多少数据包，burstiness control决定什么时候发送这些数据包，上述决定都是在estimation部分提供的信息的基础上做出的。这里只说一下estimation和window control。</p>
<h4 id="Estimation"><a href="#Estimation" class="headerlink" title="Estimation"></a>Estimation</h4><p>&emsp;&emsp;对于每一个被发送的数据包，estimation部分计算两类反馈信息。当收到一个正常的ACK，计算出相应数据包的RTT，更新平均queueing delay和最小RTT。当收到一个乱序ACK（三个dupack或者timeout），estimation会将数据包的丢失信息报告给其他部分。estimation既可以进行multi-bit的queueing delay采样，也可以进行ont-bit的loss-or-no-loss采样。<br>最后得到的RTT一般都会采用加权移动平均处理，FAST TCP也不例外，$T_i(k)$表示第k个RTT的样本值，$\overline{T}_i(k)$，平均RTT的更新公式如下：<br>$$\overline{T}_i(k+1) = (1 - \eta)\overline{T}_i(k) + \etaT_i(k)$$<br>这里，$t_k$表示收到第k个RTT样本值的时间，$\eta$为加权值。记$d_i(k)$为到目前为止的最小RTT，那么平均queueing delay的计算公式如下：<br>$$\hat{q}_i(k) = \overline{T}_i(k) - d_i(k)$$</p>
<h4 id="Window-control"><a href="#Window-control" class="headerlink" title="Window control"></a>Window control</h4><p>&emsp;&emsp;window control会根据estimation提供的拥塞信息（queueing delay and packet loss）来决定拥塞窗口的调整。FAST TCP不同于传统TCP的关键在于其对拥塞窗口的计算与sender state是独立的。<br>&emsp;&emsp;在正常情况下，根据estimation提供的平均RTT和平均queueing delay，FAST TCP会周期性的更新其拥塞窗口$CWnd$。 更新公式如下：<br>$$w &lt;— min\lbrace2w, (1-\gamma)w + \gamma(\frac{baseRTT}{RTT}w + \alpha(w, qdelay))\rbrace$$<br>这里，$\gamma\in(0, ]$，qdelay是端到端的平均queueing delay。</p>
<p>&emsp;&emsp;这篇博客只是对原文基本思想的表述，还有许多细节问题没有提到，有兴趣的朋友可以考虑看看原文，原文地址在博客的参考文献中给出。</p>
<p><strong>参考文献</strong><br><a href="http://infocom2004.ieee-infocom.org/Papers/52_2.PDF" target="_blank" rel="external">FAST TCP: Motivation, Architecture, Algorithms, Performance</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;经典的TCP拥塞控制算法TCP Reno从被提出后很长一段时间一直作为Linux kernel的默认算法，但随着Internet在规模、传输速度、负载、连接数上的增长，TCP Reno迟早会成为性能瓶颈。&lt;br&gt;
    
    </summary>
    
      <category term="私人文献阅读" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP拥塞算法之：Vegas</title>
    <link href="http://yoursite.com/2017/05/18/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8BVegas/"/>
    <id>http://yoursite.com/2017/05/18/TCP拥塞控制之Vegas/</id>
    <published>2017-05-17T17:06:38.000Z</published>
    <updated>2017-05-17T17:13:55.975Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;vegas是一种主动调整cwnd的拥塞控制算法，主要思想是设置两个阈值,alpha和beta,然后通过计算目标速率(Expected)和实际速率(Actual)差(diff)，再比较diff与alpha和beta的关系，对cwnd进行调节。vegas这篇paper的主要贡献是提供了一种拥塞检测的方法。<br><a id="more"></a></p>
<h3 id="区分拥塞还是非拥塞状态"><a href="#区分拥塞还是非拥塞状态" class="headerlink" title="区分拥塞还是非拥塞状态"></a>区分拥塞还是非拥塞状态</h3><h4 id="定义理论速率Expected和实际速率Actual："><a href="#定义理论速率Expected和实际速率Actual：" class="headerlink" title="定义理论速率Expected和实际速率Actual："></a>定义理论速率Expected和实际速率Actual：</h4><p>$$Expected = cwnd/BaseRTT$$<br>$$Actual = cwnd/RTT$$<br>这里cwnd是当前的TCP窗口大小，BaseRTT是测量的最小往返时间，RTT是所测量的经平滑后的往返时间。</p>
<h4 id="定义速率差Diff"><a href="#定义速率差Diff" class="headerlink" title="定义速率差Diff"></a>定义速率差Diff</h4><p>$$Diff = Expected - Actual$$<br>$$diff = Diff*baseRTT$$</p>
<h4 id="设置alpha和beta的值："><a href="#设置alpha和beta的值：" class="headerlink" title="设置alpha和beta的值："></a>设置alpha和beta的值：</h4><pre><code>alpha = 2;
beta = 4;
</code></pre><h3 id="基于链路状态的拥塞控制"><a href="#基于链路状态的拥塞控制" class="headerlink" title="基于链路状态的拥塞控制"></a>基于链路状态的拥塞控制</h3><h4 id="慢开始算法-cwnd-lt-ssthresh"><a href="#慢开始算法-cwnd-lt-ssthresh" class="headerlink" title="慢开始算法(cwnd &lt;= ssthresh)"></a>慢开始算法(cwnd &lt;= ssthresh)</h4><p>&emsp;&emsp;慢开始算法同Reno算法的慢开始的处理方法一样，每收到一个ACK，cwnd加1，这样cwnd会程指数增长，即每经过一个RTT，<br>    $$cwnd = cwnd*2$$</p>
<h4 id="自适应增长算法-cwnd-gt-ssthresh"><a href="#自适应增长算法-cwnd-gt-ssthresh" class="headerlink" title="自适应增长算法(cwnd &gt; ssthresh)"></a>自适应增长算法(cwnd &gt; ssthresh)</h4><p>Reno的处理方法:<br>对于cwnd而言，会设置一个ssthresh(slow-start threshold)来控制cwnd的增长。<br>当cwnd &gt;ssthresh，会降低cwnd的增长速度，避免出现拥塞(congestion)具体的控制方法是，每经过一个RTT，<br>    $$cwnd = cwnd + 1$$<br>也可以这样理解，每收到一个ACK，<br>    $$cwnd = cwnd + 1/cwnd$$</p>
<p>vegas的处理方法:<br>当cwnd &gt; ssthresh时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (diff &lt; alpha)</div><div class="line">set: cwnd = cwnd + 1 //每收到一个ACK</div><div class="line">else if (diff &gt;= beta)</div><div class="line">set: cwnd = cwnd - 1 //每收到两个ACK</div><div class="line">else</div><div class="line">set: cwnd = cwnd</div></pre></td></tr></table></figure></p>
<p>理论知识介绍到此，下面来看看在内核中的具体代码实现。</p>
<h3 id="代码实现注解"><a href="#代码实现注解" class="headerlink" title="代码实现注解"></a>代码实现注解</h3><p>@linux kernel version 3.12/src/net/ipv4/tcp_vegas.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div></pre></td><td class="code"><pre><div class="line">/*头文件包含，这里就不解释了*/</div><div class="line">#include &lt;linux/mm.h&gt; </div><div class="line">#include &lt;linux/module.h&gt; </div><div class="line">#include &lt;linux/skbuff.h&gt; </div><div class="line">#include &lt;linux/inet_diag.h&gt; </div><div class="line"> </div><div class="line">#include &lt;net/tcp.h&gt; </div><div class="line"> </div><div class="line">#include &quot;tcp_vegas.h&quot; </div><div class="line"></div><div class="line">/*gamma参数在后面代码中遇到时作分析*/</div><div class="line">static int gamma = 1; </div><div class="line">/*sysctl命令被用于在内核运行时动态地修改内核的运行参数,</div><div class="line"> *0644表示可读写权限,</div><div class="line"> *sysctl_tcp_vegas_alpha表示在</div><div class="line"> */pro/sys/net/ipv4/目录下有一个tcp_vegas_alpha参数，可以进行动态修改。</div><div class="line"> *修改命令为：echo targetvalue &gt; /pro/sys/net/ipv4/tcp_vegas_alpha,这样就没必要*进入到内核去修改，因为在修改内核后还得重新编译内核。</div><div class="line"> */</div><div class="line">module_param(sysctl_tcp_vegas_alpha, int, 0644); </div><div class="line">MODULE_PARM_DESC(sysctl_tcp_vegas_alpha, &quot;lower bound of packets in network&quot;); </div><div class="line">module_param(sysctl_tcp_vegas_beta, int, 0644); </div><div class="line">MODULE_PARM_DESC(sysctl_tcp_vegas_beta, &quot;upper bound of packets in network&quot;); </div><div class="line">module_param(gamma, int, 0644); </div><div class="line">MODULE_PARM_DESC(gamma, &quot;limit on increase (scale by 2)&quot;); </div><div class="line"> </div><div class="line"> </div><div class="line">/* There are several situations when we must &quot;re-start&quot; Vegas: </div><div class="line"> * </div><div class="line"> *  o when a connection is established </div><div class="line"> *  o after an RTO </div><div class="line"> *  o after fast recovery </div><div class="line"> *  o when we send a packet and there is no outstanding </div><div class="line"> *    unacknowledged data (restarting an idle connection) </div><div class="line"> * </div><div class="line"> * In these circumstances we cannot do a Vegas calculation at the </div><div class="line"> * end of the first RTT, because any calculation we do is using </div><div class="line"> * stale info -- both the saved cwnd and congestion feedback are </div><div class="line"> * stale. </div><div class="line"> * </div><div class="line"> * Instead we must wait until the completion of an RTT during </div><div class="line"> * which we actually receive ACKs. </div><div class="line"> */ </div><div class="line">static void vegas_enable(struct sock *sk) </div><div class="line">&#123; </div><div class="line">    const struct tcp_sock *tp = tcp_sk(sk); </div><div class="line">    struct vegas *vegas = inet_csk_ca(sk); </div><div class="line"> </div><div class="line">    /* Begin taking Vegas samples next time we send something. */ </div><div class="line">    vegas-&gt;doing_vegas_now = 1; </div><div class="line"> </div><div class="line">    /* Set the beginning of the next send window. */ </div><div class="line">    vegas-&gt;beg_snd_nxt = tp-&gt;snd_nxt; </div><div class="line"> </div><div class="line">    vegas-&gt;cntRTT = 0; </div><div class="line">    vegas-&gt;minRTT = 0x7fffffff; </div><div class="line">&#125; </div><div class="line"> </div><div class="line">/* Stop taking Vegas samples for now. */ </div><div class="line">static inline void vegas_disable(struct sock *sk) </div><div class="line">&#123; </div><div class="line">    struct vegas *vegas = inet_csk_ca(sk); </div><div class="line"> </div><div class="line">    vegas-&gt;doing_vegas_now = 0; </div><div class="line">&#125; </div><div class="line"> /*初始化*/</div><div class="line">void tcp_vegas_init(struct sock *sk) </div><div class="line">&#123; </div><div class="line">    struct vegas *vegas = inet_csk_ca(sk); </div><div class="line"> </div><div class="line">    vegas-&gt;baseRTT = 0x7fffffff; </div><div class="line">    vegas_enable(sk); </div><div class="line">&#125; </div><div class="line">EXPORT_SYMBOL_GPL(tcp_vegas_init); </div><div class="line"> </div><div class="line">/* Do RTT sampling needed for Vegas. </div><div class="line"> * Basically we: </div><div class="line"> *   o min-filter RTT samples from within an RTT to get the current </div><div class="line"> *     propagation delay + queuing delay (we are min-filtering to try to </div><div class="line"> *     avoid the effects of delayed ACKs) </div><div class="line"> *   o min-filter RTT samples from a much longer window (forever for now) </div><div class="line"> *     to find the propagation delay (baseRTT) </div><div class="line"> */ </div><div class="line">void tcp_vegas_pkts_acked(struct sock *sk, u32 cnt, s32 rtt_us) </div><div class="line">&#123; </div><div class="line">    struct vegas *vegas = inet_csk_ca(sk); </div><div class="line">    u32 vrtt; </div><div class="line"> </div><div class="line">    if (rtt_us &lt; 0) </div><div class="line">        return; </div><div class="line"> </div><div class="line">    /* Never allow zero rtt or baseRTT */ </div><div class="line">    vrtt = rtt_us + 1; </div><div class="line"> </div><div class="line">    /* Filter to find propagation delay: */ </div><div class="line">    if (vrtt &lt; vegas-&gt;baseRTT) </div><div class="line">        vegas-&gt;baseRTT = vrtt; </div><div class="line"> </div><div class="line">    /* Find the min RTT during the last RTT to find </div><div class="line">     * the current prop. delay + queuing delay: </div><div class="line">     */ </div><div class="line">    vegas-&gt;minRTT = min(vegas-&gt;minRTT, vrtt); </div><div class="line">    /*对rtt采样统计*/</div><div class="line">    vegas-&gt;cntRTT++; </div><div class="line">&#125; </div><div class="line">EXPORT_SYMBOL_GPL(tcp_vegas_pkts_acked); </div><div class="line"> /*状态判断，是否开启vegas*/</div><div class="line">void tcp_vegas_state(struct sock *sk, u8 ca_state) </div><div class="line">&#123; </div><div class="line"> </div><div class="line">    if (ca_state == TCP_CA_Open) </div><div class="line">        vegas_enable(sk); </div><div class="line">    else </div><div class="line">        vegas_disable(sk); </div><div class="line">&#125; </div><div class="line">EXPORT_SYMBOL_GPL(tcp_vegas_state); </div><div class="line"> </div><div class="line">/* </div><div class="line"> * If the connection is idle and we are restarting, </div><div class="line"> * then we don&apos;t want to do any Vegas calculations </div><div class="line"> * until we get fresh RTT samples.  So when we </div><div class="line"> * restart, we reset our Vegas state to a clean </div><div class="line"> * slate. After we get acks for this flight of </div><div class="line"> * packets, _then_ we can make Vegas calculations </div><div class="line"> * again. </div><div class="line"> */ </div><div class="line">void tcp_vegas_cwnd_event(struct sock *sk, enum tcp_ca_event event) </div><div class="line">&#123; </div><div class="line">    if (event == CA_EVENT_CWND_RESTART || </div><div class="line">        event == CA_EVENT_TX_START) </div><div class="line">        tcp_vegas_init(sk); </div><div class="line">&#125; </div><div class="line">EXPORT_SYMBOL_GPL(tcp_vegas_cwnd_event); </div><div class="line"> /*设置ssthresh*/</div><div class="line">static inline u32 tcp_vegas_ssthresh(struct tcp_sock *tp) </div><div class="line">&#123; </div><div class="line">    return  min(tp-&gt;snd_ssthresh, tp-&gt;snd_cwnd-1); </div><div class="line">&#125; </div><div class="line"> /*tcp_vegas_cong_avoid()函数是vegas算法实现的重点*/</div><div class="line">static void tcp_vegas_cong_avoid(struct sock *sk, u32 ack, u32 in_flight) </div><div class="line">&#123; </div><div class="line">    struct tcp_sock *tp = tcp_sk(sk); </div><div class="line">    struct vegas *vegas = inet_csk_ca(sk); </div><div class="line"> /*cwnd和in_flight比较，判断cwnd是否受限，受限则直接返回*/</div><div class="line">    if (!tcp_is_cwnd_limited(sk, in_flight)) &#123; </div><div class="line">        return; </div><div class="line">    &#125; </div><div class="line"> /*如果现在不能使用vegas，则使用reno进行拥塞控制*/</div><div class="line">    if (!vegas-&gt;doing_vegas_now) &#123; </div><div class="line">        tcp_reno_cong_avoid(sk, ack, in_flight); </div><div class="line">        return; </div><div class="line">    &#125; </div><div class="line"> /*每收到一个ACK，便和beg_snd_nxt比较，判断是ACK新包还是ACK重传包*/</div><div class="line">    if (after(ack, vegas-&gt;beg_snd_nxt)) &#123; </div><div class="line">        /* Do the Vegas once-per-RTT cwnd adjustment. */ </div><div class="line"> </div><div class="line">        /* Save the extent of the current window so we can use this </div><div class="line">         * at the end of the next RTT. </div><div class="line">         */ </div><div class="line">        /*更新滑动窗口的左边界*/</div><div class="line">        vegas-&gt;beg_snd_nxt  = tp-&gt;snd_nxt;     </div><div class="line"> </div><div class="line">        /* We do the Vegas calculations only if we got enough RTT </div><div class="line">         * samples that we can be reasonably sure that we got </div><div class="line">         * at least one RTT sample that wasn&apos;t from a delayed ACK. </div><div class="line">         * If we only had 2 samples total, </div><div class="line">         * then that means we&apos;re getting only 1 ACK per RTT, which </div><div class="line">         * means they&apos;re almost certainly delayed ACKs. </div><div class="line">         * If  we have 3 samples, we should be OK. </div><div class="line">         */ </div><div class="line"> </div><div class="line">        if (vegas-&gt;cntRTT &lt;= 2) &#123; </div><div class="line">            /* We don&apos;t have enough RTT samples to do the Vegas </div><div class="line">             * calculation, so we&apos;ll behave like Reno. </div><div class="line">             */ </div><div class="line">            tcp_reno_cong_avoid(sk, ack, in_flight); </div><div class="line">        &#125; else &#123; </div><div class="line">            u32 rtt, diff; </div><div class="line">            u64 target_cwnd; </div><div class="line"> </div><div class="line">            /* We have enough RTT samples, so, using the Vegas </div><div class="line">             * algorithm, we determine if we should increase or </div><div class="line">             * decrease cwnd, and by how much. </div><div class="line">             */ </div><div class="line"> </div><div class="line">            /* Pluck out the RTT we are using for the Vegas </div><div class="line">             * calculations. This is the min RTT seen during the </div><div class="line">             * last RTT. Taking the min filters out the effects </div><div class="line">             * of delayed ACKs, at the cost of noticing congestion </div><div class="line">             * a bit later. </div><div class="line">             */ </div><div class="line">            rtt = vegas-&gt;minRTT; </div><div class="line"> </div><div class="line">            /* Calculate the cwnd we should have, if we weren&apos;t </div><div class="line">             * going too fast. </div><div class="line">             * </div><div class="line">             * This is: </div><div class="line">             *     (actual rate in segments) * baseRTT </div><div class="line">             */ </div><div class="line">            target_cwnd = tp-&gt;snd_cwnd * vegas-&gt;baseRTT / rtt; </div><div class="line"> </div><div class="line">            /* Calculate the difference between the window we had, </div><div class="line">             * and the window we would like to have. This quantity </div><div class="line">             * is the &quot;Diff&quot; from the Arizona Vegas papers. </div><div class="line">             */ </div><div class="line">            /*这里要说明下，diff的计算和paper中说的有点出入,</div><div class="line">             *将公式展开后得diff = snd_cwnd*rtt/baseRTT - snd_cwnd</div><div class="line">             *而在paper中说的是diff = snd_cwnd - snd_cwnd*baseRTT/rtt</div><div class="line">             */</div><div class="line">            diff = tp-&gt;snd_cwnd * (rtt-vegas-&gt;baseRTT) / vegas-&gt;baseRTT; </div><div class="line">            /*更新变量*/</div><div class="line">            tp-&gt;snd_diff = diff; </div><div class="line">            tp-&gt;vegas_baseRTT = vegas-&gt;baseRTT; </div><div class="line">            tp-&gt;vegas_minRTT = vegas-&gt;minRTT; </div><div class="line">            if (diff &gt; gamma &amp;&amp; tp-&gt;snd_cwnd &lt;= tp-&gt;snd_ssthresh) &#123; </div><div class="line">                /* Going too fast. Time to slow down </div><div class="line">                 * and switch to congestion avoidance. </div><div class="line">                 */ </div><div class="line"> </div><div class="line">                /* Set cwnd to match the actual rate </div><div class="line">                 * exactly: </div><div class="line">                 *   cwnd = (actual rate) * baseRTT </div><div class="line">                 * Then we add 1 because the integer </div><div class="line">                 * truncation robs us of full link </div><div class="line">                 * utilization. </div><div class="line">                 */ </div><div class="line">                tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, (u32)target_cwnd+1); </div><div class="line">                tp-&gt;snd_ssthresh = tcp_vegas_ssthresh(tp); </div><div class="line"> </div><div class="line">            &#125; else if (tp-&gt;snd_cwnd &lt;= tp-&gt;snd_ssthresh) &#123; </div><div class="line">                /* Slow start.  */ </div><div class="line">                tcp_slow_start(tp); </div><div class="line">            &#125; else &#123; </div><div class="line">                /* Congestion avoidance. */ </div><div class="line"> </div><div class="line">                /* Figure out where we would like cwnd </div><div class="line">                 * to be. </div><div class="line">                 */ </div><div class="line">                /*如果diff &gt; beta,说明网络拥塞严重，需要降低cwnd*/</div><div class="line">                if (diff &gt; sysctl_tcp_vegas_beta) &#123; </div><div class="line">                    /* The old window was too fast, so </div><div class="line">                     * we slow down. </div><div class="line">                     */ </div><div class="line">                    tp-&gt;snd_cwnd--; </div><div class="line">                    tp-&gt;snd_ssthresh </div><div class="line">                        = tcp_vegas_ssthresh(tp); </div><div class="line">                &#125;</div><div class="line">                /*如果diff &lt; alpha,说明网络中数据包的数量还有增长空间*/</div><div class="line">                 else if (diff &lt; sysctl_tcp_vegas_alpha) &#123; </div><div class="line">                    /* We don&apos;t have enough extra packets </div><div class="line">                     * in the network, so speed up. </div><div class="line">                     */ </div><div class="line">                    tp-&gt;snd_cwnd++; </div><div class="line">                &#125;</div><div class="line">                /*如果alpha &lt; diff &lt; beta,维持原样*/ </div><div class="line">                else &#123; </div><div class="line">                    /* Sending just as fast as we </div><div class="line">                     * should be. </div><div class="line">                     */ </div><div class="line">                &#125; </div><div class="line">            &#125; </div><div class="line">            /*cwnd最小为2*/</div><div class="line">            if (tp-&gt;snd_cwnd &lt; 2) </div><div class="line">                tp-&gt;snd_cwnd = 2; </div><div class="line">            else if (tp-&gt;snd_cwnd &gt; tp-&gt;snd_cwnd_clamp) </div><div class="line">                tp-&gt;snd_cwnd = tp-&gt;snd_cwnd_clamp; </div><div class="line"> </div><div class="line">            tp-&gt;snd_ssthresh = tcp_current_ssthresh(sk); </div><div class="line">        &#125; </div><div class="line"> </div><div class="line">        /* Wipe the slate clean for the next RTT. */ </div><div class="line">        vegas-&gt;cntRTT = 0; </div><div class="line">        vegas-&gt;minRTT = 0x7fffffff; </div><div class="line">    &#125; </div><div class="line">    /* Use normal slow start */ </div><div class="line">    else if (tp-&gt;snd_cwnd &lt;= tp-&gt;snd_ssthresh) </div><div class="line">        tcp_slow_start(tp); </div><div class="line"> </div><div class="line">&#125; </div><div class="line"> </div><div class="line">/* Extract info for Tcp socket info provided via netlink. */ </div><div class="line">void tcp_vegas_get_info(struct sock *sk, u32 ext, struct sk_buff *skb) </div><div class="line">&#123; </div><div class="line">    const struct vegas *ca = inet_csk_ca(sk); </div><div class="line">    if (ext &amp; (1 &lt;&lt; (INET_DIAG_VEGASINFO - 1))) &#123; </div><div class="line">        struct tcpvegas_info info = &#123; </div><div class="line">            .tcpv_enabled = ca-&gt;doing_vegas_now, </div><div class="line">            .tcpv_rttcnt = ca-&gt;cntRTT, </div><div class="line">            .tcpv_rtt = ca-&gt;baseRTT, </div><div class="line">            .tcpv_minrtt = ca-&gt;minRTT, </div><div class="line">        &#125;; </div><div class="line"> </div><div class="line">        nla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &amp;info); </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line">EXPORT_SYMBOL_GPL(tcp_vegas_get_info);</div><div class="line"></div><div class="line">static struct tcp_congestion_ops tcp_vegas __read_mostly = &#123;</div><div class="line">    .flags      = TCP_CONG_RTT_STAMP,</div><div class="line">    .init       = tcp_vegas_init,</div><div class="line">    .ssthresh   = tcp_reno_ssthresh,</div><div class="line">    .cong_avoid = tcp_vegas_cong_avoid,</div><div class="line">    .min_cwnd   = tcp_reno_min_cwnd,</div><div class="line">    .pkts_acked = tcp_vegas_pkts_acked,</div><div class="line">    .set_state  = tcp_vegas_state,</div><div class="line">    .cwnd_event = tcp_vegas_cwnd_event,</div><div class="line">    .get_info   = tcp_vegas_get_info,</div><div class="line"></div><div class="line">    .owner      = THIS_MODULE,</div><div class="line">    .name       = &quot;vegas&quot;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static int __init tcp_vegas_register(void)</div><div class="line">&#123;</div><div class="line">    BUILD_BUG_ON(sizeof(struct vegas) &gt; ICSK_CA_PRIV_SIZE);</div><div class="line">    tcp_register_congestion_control(&amp;tcp_vegas);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __exit tcp_vegas_unregister(void)</div><div class="line">&#123;</div><div class="line">    tcp_unregister_congestion_control(&amp;tcp_vegas);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module_init(tcp_vegas_register);</div><div class="line">module_exit(tcp_vegas_unregister);</div><div class="line"></div><div class="line">MODULE_AUTHOR(&quot;Stephen Hemminger&quot;);</div><div class="line">MODULE_LICENSE(&quot;GPL&quot;);</div><div class="line">MODULE_DESCRIPTION(&quot;TCP Vegas&quot;);</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>vegas拥塞控制算法用于控制传输速率和delay会有很好的效果，但其缺点是在现在的高带宽网络环境下，其竞争带宽时不够激进，比不上其他拥塞控制算法，比如cubic, veno等。</p>
<p><strong>参考文献</strong><br><a href="http://www.cs.toronto.edu/syslab/courses/csc2209/06au/papers/vegas.pdf" target="_blank" rel="external">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;vegas是一种主动调整cwnd的拥塞控制算法，主要思想是设置两个阈值,alpha和beta,然后通过计算目标速率(Expected)和实际速率(Actual)差(diff)，再比较diff与alpha和beta的关系，对cwnd进行调节。vegas这篇paper的主要贡献是提供了一种拥塞检测的方法。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
  </entry>
  
  <entry>
    <title>混合慢启动算法:Hybrid</title>
    <link href="http://yoursite.com/2017/05/14/%E6%B7%B7%E5%90%88%E6%85%A2%E5%90%AF%E5%8A%A8%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/05/14/混合慢启动算法/</id>
    <published>2017-05-14T13:03:43.000Z</published>
    <updated>2017-05-14T13:08:58.521Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;传统的单纯采用指数增长的慢启动算法有一个无法避免的问题，在临界进入拥塞避免阶段时，特别是在高带宽长距离网络中，容易出现大规模丢包，进而导致大量数据包重传，也有可能出现timeout，致使网络带宽利用率下降。<br>&emsp;&emsp;这里，本文将介绍一种新的慢启动方法——Hybrid Slow Start，它在传统的慢启动算法中加入了判断机制，强制从慢启动转入拥塞避免。这里主要说说其在CUBIC中是怎么实现的，Hybrid Slow Start算法原理本身就不做过多介绍了，有兴趣可以看看本文最后给出的参考文献。<br><a id="more"></a></p>
<h3 id="变量介绍"><a href="#变量介绍" class="headerlink" title="变量介绍"></a>变量介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#define HYSTART_ACK_TRAIN      0x1 //进入拥塞避免的条件</div><div class="line">#define HYSTART_DELAY          0x2 //进入拥塞避免的条件</div><div class="line">#define HYSTART_MIN_SAMPLES    8   //表示至少取一个RTT的前8个ACK作为样本</div><div class="line">#define HYSTART_DELAY_MIN      (4u&lt;&lt;3) </div><div class="line">#define HYSTART_DELAY_MAX      (16u&lt;&lt;3)</div><div class="line">/* if x &gt; HYSTART_DELAY_MAX，return HYSTART_DELAY_MAX </div><div class="line"> * else if x &lt; HYSTART_DELAY_MIN，return HYATART_DELAY_MIN</div><div class="line"> * else return x</div><div class="line"> */</div><div class="line">#define HYSTART_DELAY_THRESH clamp(x, HYSTART_DELAY_MIN, HYSTART_DELAY_MAX)</div><div class="line">static int hystart __read_mostly = 1;</div><div class="line">static int hystart_detect __read_mostly = HYSTART_ACK_TRAIN | HYSART_DELAY;</div><div class="line">static int hystart_low_window __read_mostly = 16;</div><div class="line">static int hystart_ack_delta __read_mostly = 2;</div><div class="line"></div><div class="line">struct bictcp &#123;</div><div class="line">  ...</div><div class="line">  u32    delay_min;   //全局最小rtt</div><div class="line">  u32    round_start; //记录慢启动的起始时间</div><div class="line">  u32    curr_rtt;    //记录样本中的最小rtt</div><div class="line">  u8      found;</div><div class="line">  u8      sample_cnt; //样本计数变量</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="两类退出slow-start机制"><a href="#两类退出slow-start机制" class="headerlink" title="两类退出slow start机制"></a>两类退出slow start机制</h3><p>在Hybrid Slow Start算法中给出了种类判断机制用来退出慢启动进入拥塞避免，分别是ACKs train length和Increase in packet delays。</p>
<h4 id="ACKS-train-length"><a href="#ACKS-train-length" class="headerlink" title="ACKS train length"></a>ACKS train length</h4><p>这里给出一段原文描述，在这段描述中说了怎么测ACKs train length以及为什么要用ACKs train length。</p>
<blockquote>
<p>The ACK train length is measured by calculating the sum of inter-arrival times of all the closely spaced ACKs within an RTT round. The train length is strongly affected by the bottleneck bandwidth, routing delays and buffer sizes along the path, and is easily stretched out by congestion caused by cross traffic in the path, so by estimating the train length we can reliably find a safe exit point of Slow Start. </p>
</blockquote>
<h4 id="Increase-in-packet-delays"><a href="#Increase-in-packet-delays" class="headerlink" title="Increase in packet delays"></a>Increase in packet delays</h4><p>同样还是一段原文描述，如果你问我为什么不直接翻译成中文，我不会回答你这个问题的。</p>
<blockquote>
<p>Increase in packet delays during Slow Start may indicate the possibility of the bottleneck router being congested.</p>
</blockquote>
<p>但是Increase in packet delays的测量会受到bursty transmission的影响，所以只测一个RTT中刚开始的几个数据包的往返时间来避免bursty transission的影响，在后面给出的code中会看到。</p>
<h3 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h3><p>hystart重置函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static inline void bictcp_hystart_reset(struct sock *sk)</div><div class="line">&#123;</div><div class="line">    struct tcp_sock *tp = tcp_sk(sk);</div><div class="line">    struct bictcp *ca = inet_csk_ca(sk);</div><div class="line">    </div><div class="line">    ca-&gt;round_start = ca-&gt;last_ack = bictcp_clock(); //记录慢启动的开始时间</div><div class="line">    ca-&gt;end_seq = tp-&gt;snd_nxt;</div><div class="line">    ca-&gt;curr_rtt = 0;   //重置样本最小rtt为0</div><div class="line">    ca-&gt;sample_cnt = 0; //重置样本计数为0</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Hybrid Slow Start实现的核心部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">static void hystart_update(struct sock *sk, u32 delay)</div><div class="line">&#123;</div><div class="line">    struct tcp_sock *tp = tcp_sk(sk);</div><div class="line">    struct bictcp *ca = inet_csk_ca(sk);</div><div class="line"></div><div class="line">    //如果ca-&gt;found &amp; hystart_detect为真，表示应该进入拥塞避免</div><div class="line">    if (!(ca-&gt;found &amp; hystart_detect)) &#123;</div><div class="line">        u32 now = bictcp_clock(); //获取当前时间</div><div class="line"></div><div class="line">        /* first detection parameter - ack-train detection */</div><div class="line">        /* 前后到来的两个ACK的间隔时间小于hystart_ack_delta才有效 */</div><div class="line">        if ((s32)(now - ca-&gt;last_ack) &lt;= hystart_ack_delta) &#123;</div><div class="line">            ca-&gt;last_ack = now;  //更新上一个ACK到来的时间</div><div class="line">            /* 每次慢启动时会重置round_start为0，结合前面的if条件，下面的</div><div class="line">             * if成立的条件是：从慢启动开始到现在经过的时间如果大于</div><div class="line">             * delay_min&gt;&gt;4，那么可以进入拥塞避免了。至于为什么选</div><div class="line">             * delay_min&gt;&gt;4这个值，鬼知道。</div><div class="line">             */</div><div class="line">            if ((s32)(now - ca-&gt;round_start) &gt; ca-&gt;delay_min &gt;&gt; 4)</div><div class="line">                ca-&gt;found |= HYSTART_ACK_TRAIN;</div><div class="line">        &#125;   </div><div class="line"></div><div class="line">        /* obtain the minimum delay of more than sampling packets */</div><div class="line">        /* 如果样本计数小于HYSTART_MIN_SAMPLES(默认为8) */</div><div class="line">        if (ca-&gt;sample_cnt &lt; HYSTART_MIN_SAMPLES) &#123;</div><div class="line">            if (ca-&gt;curr_rtt == 0 || ca-&gt;curr_rtt &gt; delay)</div><div class="line">                ca-&gt;curr_rtt = delay;/* 更新样本中的最小rtt */</div><div class="line"></div><div class="line">            ca-&gt;sample_cnt++;</div><div class="line">        &#125; else &#123;//如果样本大于8了，那么就可以判断是否要进入拥塞避免了</div><div class="line">            /* 如果前面8个样本中的最小rtt大于全局最小rtt与阈值的和，那么表示网络出</div><div class="line">             * 现了拥塞，应立马进入拥塞避免阶段，HYSTART_DELAY_THRESH()的返</div><div class="line">             * 回值在前面的变量介绍中有说明。</div><div class="line">            if (ca-&gt;curr_rtt &gt; ca-&gt;delay_min +</div><div class="line">                HYSTART_DELAY_THRESH(ca-&gt;delay_min&gt;&gt;4))</div><div class="line">                ca-&gt;found |= HYSTART_DELAY;</div><div class="line">        &#125;   </div><div class="line">        /*  </div><div class="line">         * Either one of two conditions are met,</div><div class="line">         * we exit from slow start immediately.</div><div class="line">         */</div><div class="line">        /* 如果为真就进入拥塞避免 */</div><div class="line">        if (ca-&gt;found &amp; hystart_detect)</div><div class="line">            tp-&gt;snd_ssthresh = tp-&gt;snd_cwnd;</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最近做实验需要探测网络带宽，需要用到Hybrid Slow Start，所以看了paper和其在Linux CUBIC算法中的实现，然后就写了这篇blog。<br>参考文献：<a href="https://pdfs.semanticscholar.org/25e9/ef3f03315782c7f1cbcd31b587857adae7d1.pdf" target="_blank" rel="external">Hybrid Slow Start for High-Bandwidth and Long-Distance Networks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;传统的单纯采用指数增长的慢启动算法有一个无法避免的问题，在临界进入拥塞避免阶段时，特别是在高带宽长距离网络中，容易出现大规模丢包，进而导致大量数据包重传，也有可能出现timeout，致使网络带宽利用率下降。&lt;br&gt;&amp;emsp;&amp;emsp;这里，本文将介绍一种新的慢启动方法——Hybrid Slow Start，它在传统的慢启动算法中加入了判断机制，强制从慢启动转入拥塞避免。这里主要说说其在CUBIC中是怎么实现的，Hybrid Slow Start算法原理本身就不做过多介绍了，有兴趣可以看看本文最后给出的参考文献。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端拥塞控制算法之：Verus</title>
    <link href="http://yoursite.com/2017/04/24/%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E4%B9%8B%EF%BC%9AVerus/"/>
    <id>http://yoursite.com/2017/04/24/移动网络拥塞控制算法之：Verus/</id>
    <published>2017-04-24T06:19:49.000Z</published>
    <updated>2017-05-17T16:31:14.163Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Verus是一种端到端的拥塞控制协议，它根据测量delay来快速反应移动网络的容量变化，而不是去尝试预测移动网络的动态信道。<br><a id="more"></a></p>
<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>&emsp;&emsp;Verus是一种端到端的拥塞控制协议，它根据测量delay来快速反应移动网络的容量变化，而不是去尝试预测移动网络的动态信道。Verus的关键idea是学习历史数据（delay profile）来得到在一个short epochs内，端到端的packet dealy和outstanding window size之间的关系。然后运用这种关系，观察在short-term内数据报延迟的变化，对window size做出适当的调整。</p>
<h4 id="移动网络信道的难以预测主要有三点："><a href="#移动网络信道的难以预测主要有三点：" class="headerlink" title="移动网络信道的难以预测主要有三点："></a>移动网络信道的难以预测主要有三点：</h4><blockquote>
<p>First, the state of a cellular channel between a mobile device and a base station undergoes several complex state transitions that affect channel availability in short time scales.<br>Second, the frame scheduling algorithms used in cellular networks cause burstiness in the cellular channel.<br>Third, while prior work has considered only self-inflicted queuing delay as a cause for high delays, we find that competing traffic does affect end-to-end delay characteristics, especially under high contention or when the cellular channel is near saturation. </p>
</blockquote>
<h4 id="通过实验观察到的三点网络特性："><a href="#通过实验观察到的三点网络特性：" class="headerlink" title="通过实验观察到的三点网络特性："></a>通过实验观察到的三点网络特性：</h4><blockquote>
<p><strong>Burst scheduling:</strong> Typical traffic characteristics observed at a receiver are highly bursty with variable burst sizes and burst inter-arrival periods. Mobility further amplifies these characteristics.<br><strong>Competing traffic:</strong> When two or more flows contend for radio resources and their sending rates approach network capacity, we observe cross-flow dependencies.<br><strong>Channel unpredictability:</strong> Standard prediction mechanisms even using the most recent samples are far from capturing the bursty behavior of the channel.</p>
</blockquote>
<h3 id="Verus协议"><a href="#Verus协议" class="headerlink" title="Verus协议"></a>Verus协议</h3><p>&emsp;&emsp;Verus从传统的TCP拥塞控制算法中借鉴了一些东西，比如慢开始和丢包后的多路降低（multiplicative decrease），但Verus在发送窗口的增长机制上做了改变。不同于传统的TCP算法在拥塞避免阶段每一个$RTT$，$CWnd$才增1，而Verus增加和降低发送窗口每$\xi$ms——记为epoch，当信道条件允许发送更多的数据包时，verus通过快速增加发送窗口来适应动态改变的无线信道。<br>在每一个epoch，Verus的发送窗口函数如下：<br>                  $$W(t+1) = f(d(t) + \delta(t))$$<br>这里，$W(t+1)$是下一时刻的发送窗口，$d(t)$是网络延迟，$\delta(t)$是延迟增量（可为负数），$f$是delay profile 函数。</p>
<h4 id="delay-profile"><a href="#delay-profile" class="headerlink" title="delay profile"></a>delay profile</h4><p>&emsp;&emsp;Verus通过下面四个步骤来建立delay profile：</p>
<blockquote>
<p><strong>Delay Estimator</strong>: estimates the network RTT using delay measurements reported from the receiver’s acknowledgments<br><strong>Delay Profiler</strong>: tracks the relationship between delay and sending window that does not cause network congestion<br><strong>Window Estimator:</strong> estimates the sending window using the estimated delay and delay profile<br><strong>Loss Handler</strong>: handles losses and adjusts the sending window</p>
</blockquote>
<p>具体建立delay profile的计算过程和公式推导在这里就不详细介绍了，最后会得到下面给出的一张图，这张图反映的是delay estimate和sending window之间的关系。通过当前时刻测得的delay，估算下一时刻的delay，然后根据这张图找出下一时刻的sending window值。<br><img src="../../../../pictures/Cellular/20170424165913.png" alt=""><br>这里只是很简单的介绍了verus的思想， 想要深入了解verus算法的话还是看其paper更好一点，下面会给出这篇paper的地址。</p>
<p><strong>参考文献：</strong><br><a href="https://cs.nyu.edu/~jchen/publications/sigcomm15-zaki.pdf" target="_blank" rel="external">Adaptive Congestion Control for Unpredictable Celler Networks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Verus是一种端到端的拥塞控制协议，它根据测量delay来快速反应移动网络的容量变化，而不是去尝试预测移动网络的动态信道。&lt;br&gt;
    
    </summary>
    
      <category term="私人文献阅读" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统内核参数的添加方法</title>
    <link href="http://yoursite.com/2017/01/15/Linux%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/01/15/Linux系统内核参数的添加方法/</id>
    <published>2017-01-15T01:39:01.000Z</published>
    <updated>2017-05-17T16:41:16.440Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在Linux系统下，使用sysctl命令可以查看和修改系统参数，但是如果想要添加一个系统参数应该怎么办呢？这篇博客的目的就是要来说这个事的。添加一个系统参数是一件很麻烦的事，大多时候是用来做测试用。<br><a id="more"></a></p>
<h4 id="在ctl-table中注册内核参数"><a href="#在ctl-table中注册内核参数" class="headerlink" title="在ctl_table中注册内核参数"></a>在ctl_table中注册内核参数</h4><p>在source/net/ipv4/sysctl_net_ipv4.c文件中有这样一个结构体数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static struct ctl_table ipv4-table[] = &#123;</div><div class="line">    ......</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>在目录/proc/sys/net/ipv4/下面所有的系统参数都得先到这里注册，下面给出一个具体例子。<br><img src="../../../../pictures/TCP/20170115100648.png" alt=""><br>这两个参数是拥塞控制算法Vegas在拥塞控制阶段调节cwnd用的，相信很多人都不陌生。<br>这里是struct ctl_table的具体定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* 结构位置：include/linux/sysctl.h */</div><div class="line">struct ctl_table</div><div class="line">&#123;</div><div class="line">    const char    *procname;    /* Text ID for /proc/sys, or zero */</div><div class="line">    void          *data;</div><div class="line">    int           maxlen;</div><div class="line">    umode_t       mode;</div><div class="line">    struct        ctl_table *child;  /* Deprecated */</div><div class="line">    proc_handler  *proc_handler;     /* Callback for text formatting */</div><div class="line">    struct ctl_tabel_poll *poll;</div><div class="line">    void *extral;</div><div class="line">    void *extra2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>现在简单介绍一下这些结构体成员变量。<br><em>procname 表示在/proc/sys/下显示的文件名称，
</em>data 表示对应于内核中的变量名称，<br>maxlen 表示允许的最大长度，<br>mode   表示访问权限<br>proc_handler表示回调函数，有一些常用取值：<br>porc_dointvec 读写包含一个或多个整数的数组，<br>proc_dostring 读写一个字符串，<br>proc_dointvec_minmax 写的整数必须在min~max范围内。</p>
<h4 id="声明内核参数"><a href="#声明内核参数" class="headerlink" title="声明内核参数"></a>声明内核参数</h4><p>用于TCP的内核参数在source/include/net/tcp.h声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* 进入tcp.h文件可以看到大量的变量声明，这里只列出上文提及到的两个变量 */</div><div class="line">...</div><div class="line">extern int sysctl_tcp_vegas_alpha;</div><div class="line">extern int sysctl_tcp_vegas_beta</div><div class="line">...</div></pre></td></tr></table></figure></p>
<h4 id="定义内核参数"><a href="#定义内核参数" class="headerlink" title="定义内核参数"></a>定义内核参数</h4><p>内核参数的定义可能在不同的文件中，这个根据内核参数的用途而定。<br>systcl_tcp_vegas_alpha和sysctl_tcp_vegas_beta这两个变量的定义位置：<br>source/net/ipv4/tcp_retrans.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int sysctl_tcp_vegas_alpha = 2;</div><div class="line">int sysctl_tcp_vegas_beta = 4;</div></pre></td></tr></table></figure></p>
<p>经过上面这些步奏，内核参数就添加成功了，但我们编译重启系统后，就会发现在目录：<br>/proc/sys/net/ipv4/下有两个文件分别是tcp_vegas_alpha和tcp_vegas_beta，以后就可以通过echo命令动态修改这两个值了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在Linux系统下，使用sysctl命令可以查看和修改系统参数，但是如果想要添加一个系统参数应该怎么办呢？这篇博客的目的就是要来说这个事的。添加一个系统参数是一件很麻烦的事，大多时候是用来做测试用。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程（第三版）头文件&quot;apue.h&quot;问题</title>
    <link href="http://yoursite.com/2017/01/15/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6%E2%80%9Capue.h%E2%80%9D%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/01/15/UNIX环境高级编程（第三版）头文件“apue.h”问题/</id>
    <published>2017-01-15T01:39:01.000Z</published>
    <updated>2017-05-14T13:17:50.277Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;初次学UNIX环境高级编程（第三版）都会遇到头文件”apue.h”怎么添加的问题，这里说下从下载源码到编译通过的整个过程。当然在编译中会遇到各种error，本人也踩了好几个坑，好在都解决了。<br><a id="more"></a></p>
<h4 id="下载源码及解压"><a href="#下载源码及解压" class="headerlink" title="下载源码及解压"></a>下载源码及解压</h4><p>先新建一个自己准备存放源码的目录，然后下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd /home/</div><div class="line">mkdir learnApue</div><div class="line">cd learnApue</div><div class="line">wget http://www.apuebook.com/src.tar.gz</div><div class="line">tar -zxvf src.tar.gz</div></pre></td></tr></table></figure></p>
<p>解压后的文件在目录”aupe.3e”下。</p>
<h4 id="头文件配置"><a href="#头文件配置" class="headerlink" title="头文件配置"></a>头文件配置</h4><p>经过上面的步骤，当前所在目录应该是”/home/learnApue/“<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ./src.3e/apue.3e</div><div class="line">cp ./include/apue.h /usr/include/</div><div class="line">cp ./lib/error.c /usr/include/</div></pre></td></tr></table></figure></p>
<h4 id="编辑”-usr-include-apue-h”"><a href="#编辑”-usr-include-apue-h”" class="headerlink" title="编辑”/usr/include/apue.h”"></a>编辑”/usr/include/apue.h”</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /usr/include/apue.h</div></pre></td></tr></table></figure>
<p>光标移动到文件最后一行”#endif”的前面，然后添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include &quot;error.c&quot;</div></pre></td></tr></table></figure></p>
<p>保存退出</p>
<h4 id="make报错及其解决方案"><a href="#make报错及其解决方案" class="headerlink" title="make报错及其解决方案"></a>make报错及其解决方案</h4><p>经过上面的操作，然后就可以编译了，这时你所在目录应该是”/home/learnApue/src.3e/apue.3e/“<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make</div></pre></td></tr></table></figure></p>
<p>正常情况下都会报error，下面是我遇到的error</p>
<h5 id="error类型1"><a href="#error类型1" class="headerlink" title="error类型1"></a>error类型1</h5><p><img src="../../../../pictures/UNIX/20170514211405.png" alt=""><br>根据错误提示，systype.sh无法执行，我的方法是更改权限然后再编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod 755 systype.sh</div><div class="line">make</div></pre></td></tr></table></figure></p>
<h5 id="error类型2"><a href="#error类型2" class="headerlink" title="error类型2"></a>error类型2</h5><p><img src="../../../../pictures/UNIX/20170514211448.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod 755 ./advio/fixup.awk</div><div class="line">make</div></pre></td></tr></table></figure></p>
<p>继续更改权限，只要是执行权限问题，都可以更改权限后再编译</p>
<h5 id="error类型3"><a href="#error类型3" class="headerlink" title="error类型3"></a>error类型3</h5><p>下面的这个错误我没有碰到，来自于网友的报错，这里给出关键报错信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ld: cannot find -lbsd</div><div class="line">...</div><div class="line">make: ***[all] Error 1</div></pre></td></tr></table></figure></p>
<p>根据这个error提示，应该是缺少一个库，解决方案如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install libbsd-dev</div><div class="line">make</div></pre></td></tr></table></figure></p>
<p>要说明的是我是roor权限，不是roor权限的在上一条命令前加sudo，再编译。<br>希望对各位正在使用UNIX环境高级编程一书的同行们有帮助，有错误还请指出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;初次学UNIX环境高级编程（第三版）都会遇到头文件”apue.h”怎么添加的问题，这里说下从下载源码到编译通过的整个过程。当然在编译中会遇到各种error，本人也踩了好几个坑，好在都解决了。&lt;br&gt;
    
    </summary>
    
      <category term="UNIX/LINUX" scheme="http://yoursite.com/categories/UNIX-LINUX/"/>
    
    
  </entry>
  
</feed>
