<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凡是过去 皆为序曲</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-26T08:34:03.635Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序问题</title>
    <link href="http://yoursite.com/2018/03/25/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/25/排序问题/</id>
    <published>2018-03-25T15:24:55.000Z</published>
    <updated>2018-03-26T08:34:03.635Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;目前正在看《算法导论》，之前看了一部分，没坚持看完，而今迈步重头越，顺便写个博客记录一下，避免下次出现类似情况。这篇博客主要是记录《算法导论》第一部分的排序问题，排序问题是算法中的基本问题，也是一个重要问题。<br><a id="more"></a><br>&emsp;&emsp;在正式介绍排序排序算法之前，先声明一下什么是原址排序：如果输入数组中仅有常数个元素需要在排序过程中存储在数组之外，则称排序是原址的。</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>&emsp;&emsp;插入排序的主要思想是假设array[0] to array[j-1]是已排好序的，array[j]是当前待插入的数，array[j+1] to array[n]是无序的。那么先使用变量key保存array[j]的值，使用i记录array[j]前一个值的下标，然后将array[j-1] to array[0]依次与key比较，直到i &lt; 0 or array[i] &lt; key，此时便找到了key要插入的位置。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">InsertionSort(int* array, int length)</div><div class="line">&#123;</div><div class="line">    int key, i;//key表示待插入的数</div><div class="line"></div><div class="line">    for (int j = 1; j &lt; length; j++) &#123;</div><div class="line">        key = array[j];</div><div class="line">        i = j - 1;</div><div class="line">        while (i &gt;= 0 &amp;&amp; array[i] &gt; key) &#123;//循环结束条件</div><div class="line">            array[i+1] = array[i];//将大于key的数依次向后移</div><div class="line">            i = i - 1;</div><div class="line">        &#125;</div><div class="line">        array[i+1] = key;//i+1为key要插入的位置</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;对于小规模输入，插入排序是一种非常快的原址排序算法。插入排序的时间复杂度为$O(n^2)$</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>&emsp;&emsp;归并排序是时间复杂度相比于插入排序更低的方法，但缺点是需要更多的额外空间开销。这是一个很普遍的问题，要么用时间换取空间，要么用空间换取时间，就看问题具体的要求了。<br>&emsp;&emsp;归并排序的主要思想是先将一个大问题分解成若干子问题，如果子问题不能直接解决，就继续递归分解，知道能够被直接解决为止，最后再合并这些子问题的解成原问题的解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">void MergeSort(int* array, int begin, int end)</div><div class="line">&#123;</div><div class="line">    if (begin &lt; end) &#123;//停止分解条件</div><div class="line">        int mid = (begin + end)/2;</div><div class="line">        MergeSort(array, begin, mid);//继续分解左子问题</div><div class="line">        MergeSort(array, mid+1, end);//继续分解右子问题</div><div class="line">        Merge(array, begin, mid, end)//合并子问题</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Merge(int* array, int begin, int mid, int end)</div><div class="line">&#123;</div><div class="line">    int n1 = mid - begin + 1;//计算左子数组的长度</div><div class="line">    int n1 = end - mid;//计算右子数组的长度</div><div class="line">    /* 分配一个数组用于临时存放子树组，可以发现LArray.length()</div><div class="line">     * 要比n1大1，RArray.length()也要比n2大1，这么做的原因是每</div><div class="line">     * 个临时数组都需要用一位来存放哨兵。*/</div><div class="line">    int LArray[n1+1];</div><div class="line">    int RArray[n2+1];</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; n1; i++)//将已排好序的左数组放到临时数组</div><div class="line">        LArray[i] = array[begin+i];</div><div class="line">    for (int j = 0; j &lt; n2; j++)//将已排好序的有数组放到临时数组</div><div class="line">        RArray[j] = array[mid+j+1];</div><div class="line"></div><div class="line">    LArray[n1] = INT_MAX;//设置哨兵</div><div class="line">    RArray[n2] = INT_MAX;//设置哨兵</div><div class="line"></div><div class="line">    int i = 0;</div><div class="line">    int j = 0;</div><div class="line">    //合并左右子数组</div><div class="line">    for (int k = 0; k &lt;= end; k++) &#123;</div><div class="line">        if (LArray[i] &gt; RArray[j]) &#123;</div><div class="line">            array[k] = RArray[j];//复制回原数组</div><div class="line">            j++;</div><div class="line">        &#125; else &#123;</div><div class="line">            array[k] = LArray[i];//复制回原数组</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以发现归并排序在排序过程中每次合并都需要借助额外数组，假设借用的额外数组规模为$f(n)$，那么有<br>$$f(n) = 1+2+…+n = \frac{n(n+1)}{2}$$<br>所以归并排序不是原址的。归并排序的时间复杂度为$O(nlgn)$</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>&emsp;&emsp;如果是非递减排序，冒泡排序的思想就是每次找到未排序数组中的最小值；如果是非递增排序，那么冒泡排序就是每次找到未排序数组中的最大值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void BubbleSort(int* array, int length)</div><div class="line">&#123;</div><div class="line">    for (int i = 0; i &lt; length-1; i++)</div><div class="line">        for (int j = i+1; j &lt; length; j++)</div><div class="line">            //array[i]永远记录未排序数组中的最小值</div><div class="line">            if (array[i] &gt; array[j])</div><div class="line">                swap(array[i], array[j]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;冒泡排序就不需要多做解释了吧！每一个写程序的人应该都能随手一挥就搞定的最基础的排序算法。冒泡排序的时间复杂度为$O(n^2)$</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>&emsp;&emsp;堆排序结合了插入排序和归并排序的有点，时间复杂度为$O(nlgn)$，且只有常数量的额外空间开销，属于原址排序。<br>&emsp;&emsp;这里的堆排序主要通过三个函数完成：<br>&emsp;&emsp;(1) void MaxHeapify(int<em> array, int i)该函数主要用于维护堆的性质，<br>                MaxHeapify()保证以i为根的子树是一个最大堆；<br>&emsp;&emsp;(2) void BuildHeap(int</em> array)保证整个堆是一个大顶堆；<br>&emsp;&emsp;(3) void HeapSort(int* array)通过利用堆的性质对数组进行排序；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"> #define PARENTS(i-1)/2   //计算父节点的下标</div><div class="line"> #define LEFT(i) 2*i + 1  //计算左孩子的下标</div><div class="line"> #define RIGHT(i) 2*i + 2 //计算右孩子的下标</div><div class="line"></div><div class="line">/* MaxHeapify()假设节点i的左右子树已经是大顶堆，现在只需要比较节点i和其左右孩子</div><div class="line"> * 如果节点i满足比其左右孩子都大，那么以节点i为根的堆就已经是一个大顶堆了。如果</div><div class="line"> * 不满足，那就需要调整。*/</div><div class="line"> void MaxHeapify(int* array, i)</div><div class="line"> &#123;</div><div class="line">    int l = LEFT(i);</div><div class="line">    int r = RIGHT(i);</div><div class="line">    int largest = i; </div><div class="line"></div><div class="line">    if ( (l &gt; heapSize) &amp;&amp; (array[l] &gt; array[i]) )</div><div class="line">        largest = l; //如果该节点小于其左孩子，那么就用largest记录左孩子的下标</div><div class="line">    else</div><div class="line">        largest = i;</div><div class="line"></div><div class="line">    if ( (r &gt; heapSize) &amp;&amp; (array[r] &gt; array[largest]) )</div><div class="line">        largest = r; //如果该节点小于其右孩子，那么就用largest记录右孩子的下标</div><div class="line"></div><div class="line">    //如果largest记录的值不等于i，说明array[i]与其左孩子或右孩子进行了交换，需</div><div class="line">      要递归继续比较</div><div class="line">    if (largest != i)</div><div class="line">        MaxHeapify(array, largest);</div><div class="line"> &#125; </div><div class="line"></div><div class="line">/* 依次对每一个非叶子结点调用MaxHeapify()，这样便可保证建一个大顶堆 */</div><div class="line"> void BuildHeap(int* array)</div><div class="line"> &#123;</div><div class="line">    for (int i = heapSize/2; i &gt;= 0; i--)</div><div class="line">    &#123;</div><div class="line">        MaxHeapify(array, i);</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">/* 因为数组中的最大元素总在根节点，所以只需将根节点与array[heapSize-1]交换，然</div><div class="line"> * 后从堆中去掉节点heapSize-1，再调用MaxHeapify()更新大顶堆。*/</div><div class="line"> void HeapSort(int* array)</div><div class="line"> &#123;</div><div class="line">    BuildHeap(array);//建立大顶堆</div><div class="line">    for (int i = heapSize-1; i &gt; 0; i--) &#123;</div><div class="line">        swap(array[0], array[i]);//将数组的最大元素放到数组的最后</div><div class="line">        heapSize = heapSize - 1;//去掉堆中的节点heapSize-1</div><div class="line">        MaxHeapify(array, 0);//更新大顶堆</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;目前正在看《算法导论》，之前看了一部分，没坚持看完，而今迈步重头越，顺便写个博客记录一下，避免下次出现类似情况。这篇博客主要是记录《算法导论》第一部分的排序问题，排序问题是算法中的基本问题，也是一个重要问题。&lt;br&gt;
    
    </summary>
    
      <category term="Intruduction to Algorithm" scheme="http://yoursite.com/categories/Intruduction-to-Algorithm/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>I/O通信技术</title>
    <link href="http://yoursite.com/2018/03/03/I-O%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/03/03/I-O通信技术/</id>
    <published>2018-03-03T01:17:59.000Z</published>
    <updated>2018-03-03T07:07:31.169Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;对I/O操作有三种可能的技术：可编程I/O、中断驱动I/O、直接内存存取（DMA）。<br><a id="more"></a></p>
<h4 id="可编程I-O"><a href="#可编程I-O" class="headerlink" title="可编程I/O"></a>可编程I/O</h4><p>&emsp;&emsp;当处理器正在执行程序并遇到一个与I/O相关的指令时，它通过给相应的I/O模块发命令来执行这个指令。<br>&emsp;&emsp;可编程I/O的问题是处理器通常必须等待很长的时间，以确定I/O模块是否做好了接收或发送更多数据的准备。处理器在等待期间必须不断的询问I/O木块的状态，其结果是严重地降低了整个系统的性能。</p>
<h4 id="中断驱动I-O"><a href="#中断驱动I-O" class="headerlink" title="中断驱动I/O"></a>中断驱动I/O</h4><p>&emsp;&emsp;从I/O模块的角度看，输入操作的过程如下：I/O模块从处理器中接收一个READ命令，然后开始从相关的外围设备读数据。一旦数据被读入该模块的数据寄存器，模块通过控制线给处理器发送一个中断信号，然后等待直到处理器请求该数据。当处理器发出这个请求后，模块把数据放到数据总线上，然后准备下一次的I/O操作。<br>&emsp;&emsp;中断驱动I/O比可编程I/O更有效，因为消除了不必要的等待。但是，由于数据中的每个字无论是从存储器到I/O模块，还是从I/O模块到存储器都必须通过处理器处理，这导致中断驱动I/O仍然会花费很多处理器时间。</p>
<h4 id="直接内存存取"><a href="#直接内存存取" class="headerlink" title="直接内存存取"></a>直接内存存取</h4><p>&emsp;&emsp;当需要移动大量的数据时，一种更有效的技术是采用直接内存存取（DMA）。DMA模块直接与存储器交互，传送整个数据块，每次传送一个字。这个过程不需要处理器参与，当传送完成后，DMA模块给处理器发一个中断信号。因此只有在开始传送和传送结束时处理器才会参与。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;对I/O操作有三种可能的技术：可编程I/O、中断驱动I/O、直接内存存取（DMA）。&lt;br&gt;
    
    </summary>
    
      <category term="操作系统精髓与设计原理" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>tc用户程序设计及其内核实现</title>
    <link href="http://yoursite.com/2018/01/11/tc%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/01/11/tc用户程序设计及其内核实现/</id>
    <published>2018-01-11T01:02:00.000Z</published>
    <updated>2018-03-04T02:23:25.662Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;tc是一个用户程序，重写并且更新Linux中的默认排队规则。它使用netlink作为用户空间与内核空间进行交互的通信信道。它添加新的排队规则、流量类别、过滤器等。<br><a id="more"></a></p>
<h4 id="函数tc-modify-qdisc"><a href="#函数tc-modify-qdisc" class="headerlink" title="函数tc_modify_qdisc()"></a>函数tc_modify_qdisc()</h4><p>&emsp;&emsp;在添加qdisc到排队规则时，doit函数指针指向tc_modify_qdisc()。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line">linux-4.13.11@net/sched/sch_api.c</div><div class="line"></div><div class="line">static int tc_modify_qdisc(struct sk_buff *sk, struct nlmsghdr *n, void *arg)</div><div class="line">&#123;</div><div class="line">    struct net *net = sock_net(skb-&gt;sk);</div><div class="line">    //tcmsg结构体定义了跟流量控制相关的消息内容</div><div class="line">    struct tcmsg *tcm; //tc消息指针</div><div class="line">    struct nlattr *tca[TCA_MAX + 1];</div><div class="line">    struct net_device *dev; //网络设备指针</div><div class="line">    u32 clid; //class id</div><div class="line">    //发送队列策略结构体</div><div class="line">    struct Qdisc *q, *p;</div><div class="line">    int err;</div><div class="line"></div><div class="line">    if (!netlink_ns_capable(skb, net-&gt;user_ns, CAP_NET_ADMIN)</div><div class="line">        return -ERROR;</div><div class="line"></div><div class="line">replay:</div><div class="line">    err = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL, extack);</div><div class="line">    if (err &lt; 0)</div><div class="line">        return err;</div><div class="line"></div><div class="line">    tcm = nlmsg_data(n);</div><div class="line">    /* 将tcm_parent的值赋给clid */</div><div class="line">    clid = tcm-&gt;tcm_parent;</div><div class="line">    q = p = NULL;</div><div class="line"></div><div class="line">    /* 根据参数ifindex搜索一个接口并返回设备的指针。 */</div><div class="line">    dev = __dev_get_by_index(net, tcm-&gt;tcm_ifindex);</div><div class="line">    /* 指向设备的指针为空，则返回一个错误 */</div><div class="line">    if (!dev)</div><div class="line">        return -ENODEV;</div><div class="line"></div><div class="line">    /* tcm_parent的值为真 */</div><div class="line">    if (clid) &#123;</div><div class="line">        /* 这里chid != TC_H_ROOT表示排队规则不是根，有父类。 */</div><div class="line">        if (clid != TC_H_ROOT) &#123;</div><div class="line">            /* 非ingress节点时，根据类别ID的高16位查找Qdisc节点 */</div><div class="line">            if (chid != TC_H_INGRESS) &#123;</div><div class="line">                //查找父类排队规则</div><div class="line">                if ((p = qdisc_lookup(dev, TC_H_MAJ(chid))) == NULL)</div><div class="line">                    return -ENOENT;</div><div class="line">                //获取p节点的叶子节点</div><div class="line">                q = qdisc_leaf(p, clid);</div><div class="line">            &#125; else &#123;</div><div class="line">                //使用设备ingress流控</div><div class="line">                q = dev-&gt;qdisc_ingress;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            /* 根节点情况下流控用的是设备的qdisc_sleeping，qdisc_sleeping指向配</div><div class="line">             * 置的当前配置队列规则。</div><div class="line">             */</div><div class="line">            q = dev-&gt;qdisc_sleeping;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* it may be default qdisc, ignore it */</div><div class="line">        if (q &amp;&amp; q-&gt;handle == 0)</div><div class="line">            q = NULL;</div><div class="line"></div><div class="line">        /* 没找到Qdisc节点，或者没在tc消息中指定句柄，或者找到的Qdisc句柄和tc消</div><div class="line">         * 息中的句柄不同。</div><div class="line">         */</div><div class="line">        if (!q || !tcm-&gt;tcm_handle || q-&gt;handle != tcm-&gt;tcm_handle) &#123;</div><div class="line">            //tc制定了句柄</div><div class="line">            if (tcm-&gt;tcm_handle) &#123;</div><div class="line">                //如果Qdisc存在但不是更新命令，返回对象存在错误</div><div class="line">                if (q &amp;&amp; !(n-&gt;nlmsg_flags &amp; NLM_F_REPLACE))</div><div class="line">                    return -EEXIST;</div><div class="line">                //tc句柄低16位不能为0</div><div class="line">                if (TC_H_MIN(tcm-&gt;tcm_handle))</div><div class="line">                    return -EINVAL;</div><div class="line">                /* 根据tc句柄查找该设备上的Qdisc，找不到的话跳转到创建新节点操</div><div class="line">                 * 作。</div><div class="line">                 */</div><div class="line">                q = qdisc_lookup(dev, tcm-&gt;tcm_handle);</div><div class="line">                if (!q)</div><div class="line">                    goto create_n_graft;</div><div class="line">                ......</div><div class="line">                goto graft;</div><div class="line">            //没指定TC句柄</div><div class="line">            &#125; else &#123;</div><div class="line">                //如果没找到Qdisc，跳转到创建新节点</div><div class="line">                if (q == NULL)</div><div class="line">                    goto create_n_graft;</div><div class="line">                //检查各种标志是否冲突，Qdisc名称是否正确</div><div class="line">                if ((n-&gt;nlmsg_flags&amp;NLM_F_CREATE) &amp;&amp;</div><div class="line">                    (n-&gt;nlmsg_flags&amp;NLM_F_REPLACE) &amp;&amp;</div><div class="line">                    ((n-&gt;nlmsg_flags&amp;NLM_F_EXCL) ||</div><div class="line">                    (tca[TCA_KIND-1] &amp;&amp;</div><div class="line">                    rtattr_strcmp(tca[TCA_KIND-1], q-&gt;ops-&gt;id))))</div><div class="line">                    goto create_n_graft;</div><div class="line">            &#125; //else</div><div class="line">        &#125; //if</div><div class="line">    //没有指定类别ID</div><div class="line">    &#125; else &#123;</div><div class="line">        //从tc消息的句柄来查找Qdisc</div><div class="line">        if (!tcm-&gt;tcm_handle)</div><div class="line">            return -EINVAL;</div><div class="line">        q = qdisc_lookup(dev, tcm-&gt;tcm_handle);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Change qdisc parameter */</div><div class="line">    //没找到Qdisc节点，返回错误</div><div class="line">    if (q == NULL)</div><div class="line">        return -ENOENT;</div><div class="line">    //找到Qdisc节点，但设置了NLM_F_EXCL(排斥)标志，返回对象存在错误</div><div class="line">    if (n-&gt;nlmsg_flags &amp; NLM_F_EXCL)</div><div class="line">        return -EEXIST;</div><div class="line">    //检查找到的Qdisc节点的名称和tc中指定的是否匹配</div><div class="line">    if (tca[TCA_KIND] &amp;&amp; nla_strcmp(tca[TCA_KIND], q-&gt;ops-&gt;id))</div><div class="line">        return -EINVAL;</div><div class="line">    //修改Qdisc参数</div><div class="line">    err = qdisc_change(q, tca);</div><div class="line">    if (err == 0)</div><div class="line">        qdisc_notify(net, skb, n, clid, NULL, q);</div><div class="line">    return err;</div><div class="line"></div><div class="line">create_n_graft:</div><div class="line">    //检查nlmsg_flags是否设置了NLM_F_CREATE，没有就返回错误</div><div class="line">    if (!(n-&gt;nlmsg_flags &amp; NLM_F_CREATE))</div><div class="line">        return -ENOENT;</div><div class="line">    //class id = TC_H_INGRESS就创建新Qdisc节点</div><div class="line">    if (clid == TC_H_INGRESS) &#123;</div><div class="line">        if (dev_ingress_queue(dev))</div><div class="line">            //分配并初始化新的qdisc</div><div class="line">            q = qdisc_create(dev, dev_ingress_queue(dev), p, </div><div class="line">            tcm-&gt;tcm_parent, tcm-&gt;tcm_parent, tca, &amp;err);</div><div class="line">        else    </div><div class="line">            err = -ENOENT;</div><div class="line">    &#125; else &#123;</div><div class="line">        struct netdev_queue *dev_queue;</div><div class="line">        if (p &amp;&amp; p-&gt;ops-&gt;cl_ops &amp;&amp; p-&gt;ops-&gt;cl_ops-&gt;select_queue)</div><div class="line">            dev_queue = p-&gt;ops_cl_ops-&gt;select_queue(p, tcm);</div><div class="line">        else if (p)</div><div class="line">            dev_queue = p-&gt;dev_queue;</div><div class="line">        else</div><div class="line">            dev_queue = netdev_get_tx_queue(dev, 0);</div><div class="line"></div><div class="line">        q = qdisc_create(dev, dev_queue, p, tcm_parent,</div><div class="line">            tcm-&gt;tcm_handle, tca, &amp;err);</div><div class="line">    &#125;</div><div class="line">    if (q == NULL) &#123;</div><div class="line">        if (err == -EAGAIN)</div><div class="line">            goto replay;</div><div class="line">        return err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">graft:</div><div class="line">    err = qdisc_graft(dev, p, skb, n, clid, q, NULL);</div><div class="line">    if (err) &#123;</div><div class="line">        if (q)</div><div class="line">            qdisc_destroy(q);</div><div class="line">        return err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="相关结构体的定义"><a href="#相关结构体的定义" class="headerlink" title="相关结构体的定义"></a>相关结构体的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">linux-4.13.11@include/uapi/linux/netlink.h</div><div class="line"></div><div class="line">struct nlattr &#123;</div><div class="line">    __u16   nla_len;</div><div class="line">    __u16   nla_type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">linux-4.13.11@include/uapi/linux/rtnetlink.h</div><div class="line"></div><div class="line">struct tcmsg &#123;</div><div class="line">    unsigned char   tcm_family;</div><div class="line">    unsigned char   tcm__pad1;</div><div class="line">    unsigned short  tcm__pad2;</div><div class="line">    int             tcm_ifindex;</div><div class="line">    __u32           tcm_handle;</div><div class="line">    __u32           tcm_parent;</div><div class="line">    __u32           tcm_info;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">linux-4.13.11@include/linux/netdevice.h</div><div class="line">/* 该结构体描述每一个网络设备 */</div><div class="line">struct net_device &#123;</div><div class="line">    </div><div class="line">    char                name[IFNAMSIZ]; //用于存放网络设备的设备名称</div><div class="line">    /* 这个字段用于构建网络设备名的哈希散列表，name_list指</div><div class="line">     * 向每个哈希散列表的链表头。</div><div class="line">     */</div><div class="line">    struct hlist_node   name_hlist;</div><div class="line">    char                *ifalias;  //网络设备的别名</div><div class="line"></div><div class="line">    //网络设备的接口索引值，独一无二的网络设备标识符</div><div class="line">    int                 ifindex;</div><div class="line">    //网络设备接口的最大传输单元</div><div class="line">    unsigned            mtu;</div><div class="line"></div><div class="line">    //网络设备接口的数据包接收队列</div><div class="line">    struct netdev_queue rx_queue;</div><div class="line">    //网络设备接口的数据包发送队列</div><div class="line">    struct netdev_queue *tx;</div><div class="line">    ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;本文主要对tc_modify_qdisc()做了注解，有错误之处请指出，还有函数tc_modify_qdisc()的最后一部分没有做注解，因为还未弄懂。</p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;tc是一个用户程序，重写并且更新Linux中的默认排队规则。它使用netlink作为用户空间与内核空间进行交互的通信信道。它添加新的排队规则、流量类别、过滤器等。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP架构、设计及应用" scheme="http://yoursite.com/categories/TCP-IP%E6%9E%B6%E6%9E%84%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="tc" scheme="http://yoursite.com/tags/tc/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的IP服务质量</title>
    <link href="http://yoursite.com/2018/01/09/Linux%E4%B8%AD%E7%9A%84IP%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/"/>
    <id>http://yoursite.com/2018/01/09/Linux中的IP服务质量/</id>
    <published>2018-01-09T10:43:43.000Z</published>
    <updated>2018-03-04T02:25:18.093Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Linux中的服务质量（排队规则）的基本功能是决定如何按顺序接受输入的网络报文，以及使用什么带宽速率接收，并且决定何时以及如何将报文安排进队列中并按照分配的带宽速率进行传输。它主要是根据应用程序需求管理带宽。<br><a id="more"></a><br>&emsp;&emsp;下面是Linux支持的排队规则类型：<br>&emsp;&emsp;（1）先进先出（First In First Out, FIFO）<br>&emsp;&emsp;（2）带优先级的先进先出（Priority FIFO, PFIFO）<br>&emsp;&emsp;（3）令牌通流（Token Bucket Flow, TBF）<br>&emsp;&emsp;（4）异步传输模式（Asynchronous Transfer Mode, ATM）<br>&emsp;&emsp;（5）随机早检测（Random Early Detection, RED）<br>&emsp;&emsp;（6）随机公平队列（Stochastic Fair Queueing, SFQ）<br>&emsp;&emsp;（7）可分类排队规则（Class-Bassed Queueing Discipline, CBQ）<br>&emsp;&emsp;（8）通用随机早检测（Generalized GED）</p>
<h4 id="Linux流量控制的基本组件"><a href="#Linux流量控制的基本组件" class="headerlink" title="Linux流量控制的基本组件"></a>Linux流量控制的基本组件</h4><p>&emps;&emsp;（1）排队规则（Queueing Discipline）<br>&emsp;&emsp;（2）类别（Class）<br>&emsp;&emsp;（3）过滤器/分类器（Filter/Classifier）<br>&emsp;&emsp;（4）策略（Policing）<br>&emsp;&emsp;<strong>排队规则</strong> Linux上的每个网络设备都有一个排队规则，它控制报文在传输前如何入队和出队。<br>&emsp;&emsp;<strong>类别</strong> 只有基于类的排队规则才支持类别。可以在传输网络流量之前根据过滤器（IP地址、TCP/IP端口等）将其分为不同的类别，每种类别会根据其优先级来调度报文的出队。<br>&emsp;&emsp;<strong>过滤器</strong> 过滤器根据特定参数（IP地址、TCP/IP端口等）将报文组织到不同的类别中。<br>&emsp;&emsp;<strong>策略</strong> 在将网络报文从队列中移出以后，可以对报文设置策略：发送报文、丢弃报文或者发送并标记报文。<br>&emsp;&emsp;Linux中的pfifo_fast排队规则的流程图如下图所示。<br><img src="../../../../pictures/TCP/20180110083808.png" alt=""></p>
<h4 id="Linux中pfifo-fast排队规则的实现"><a href="#Linux中pfifo-fast排队规则的实现" class="headerlink" title="Linux中pfifo_fast排队规则的实现"></a>Linux中pfifo_fast排队规则的实现</h4><p>&emsp;&emsp;pfifo_fast排队规则是Linux系统中所有网络接口的默认排队规则。pfifo_fast排队规则可以被Linux系统中的任何其他排队规则替换。pfifo_fast包含三个不同的FIFO队列，他们根据优先级将报文加入队列。最高优先级的报文进入FIFO 0，接下来依次是FIFO 1和FIFO 2。<br>&emsp;&emsp;pfifo_fast不是由用户配置的，而是默认硬编码的。报文的优先级是内核分配的，并且根据报文的TOS octet映射到适当的波段中。对于报文入队和出队，pfifo_fast排队规则使用pfifo_fast_enqueue()和pfifo_fast_dequeue()函数。</p>
<h4 id="排队规则数据结构"><a href="#排队规则数据结构" class="headerlink" title="排队规则数据结构"></a>排队规则数据结构</h4><p>&emsp;&emsp;<strong>（1）结构Qdisc</strong> struct Qdisc数据结构表示流量排队规则的一个qdisc，它与网络设备相关联。这个排队规则用于在将报文发送到Linux系统的网络接口之前的流量控制（报文排队）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">include/net/pkt_sched.h</div><div class="line"></div><div class="line">struct Qdisc </div><div class="line">&#123;</div><div class="line">    /* 指向排队规则的入队函数的函数指针。如果没有配置其他队列规则，则默认的函数</div><div class="line">     * 是pfifo_fast_enqueue。入队函数的主要作用是将sk_buff加入到调度器的恰当的</div><div class="line">     * 队列中。</div><div class="line">     */</div><div class="line">    int                 (*enqueue)(sturct sk_buff *skb, struct Qdisc *dev);</div><div class="line">    /* 指向队列规则的出队函数的函数指针。默认函数是pfifo_fast_dequeue()</div><div class="line">     * 。出队函数的主要作用是，从优先级最高的非空队列中移出报文。</div><div class="line">     */</div><div class="line">    struct sk_buff*     (*dequeue)(struct Qdisc *dev);</div><div class="line">    unsigned            flags;</div><div class="line">    ......</div><div class="line">    /* 每个排队规则都有一个用于控制其操作的函数集，Qdisc_ops数据结构包含了所有</div><div class="line">     * 这些控制函数。</div><div class="line">     */</div><div class="line">    struct Qdisc_ops    *ops;</div><div class="line">    /* Linux网络设备维护了qdisc_list，以链接所有用于设备排队的排队规则。这里，</div><div class="line">     * next指针指向设备的下一个排队规则。</div><div class="line">     */</div><div class="line">    struct Qdisc        *next;</div><div class="line">    /* 内核中有多个排队规则实例，每个排队规则实例都通过32位的数字来标识。*/</div><div class="line">    u32                 handle;</div><div class="line">    atomic_t            refcnt;</div><div class="line">    /* q表示队列的头部 */</div><div class="line">    struct sk_buff_head q;</div><div class="line">    /* 指向网络设备 */</div><div class="line">    struct net_device   *dev;</div><div class="line">    /* 表示统计，即入队的字节数与报文数、丢弃的报文数等。*/</div><div class="line">    struct tc_stats     stats;</div><div class="line">    int                 (*reshape_fail)(struct sk_buff *skb, struct Qdisc *q);</div><div class="line">    ......</div><div class="line">    struct Qdisc        *__parents;</div><div class="line">    /* 这是一个位置指针。对于默认的pfifo_fast，它指向一个sk_buff_head结构的数</div><div class="line">     * 组；对于CBQ，它指向cbq_sched_data数据结构，这个数据结构包含了用于不同队</div><div class="line">     * 列的类型。</div><div class="line">     */</div><div class="line">    char                data[0];</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>（2）结构Qdisc_ops</strong> struct Qdisc_ops数据结构提供了用于各种操作的控制函数集，这些操作在排队规则上执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">include/net/pkt_sched.h</div><div class="line"></div><div class="line">struct Qdisc_ops</div><div class="line">&#123;</div><div class="line">    /* 指向下一个Qdisc_ops，以链接所有在内核中注册的排队规则操作。*/</div><div class="line">    struct Qdisc_ops        *next;</div><div class="line">    /* 这是一个类别操作数据结构Qdisc_class_ops，它为某个特定的类别提供一个函</div><div class="line">     * 数集。</div><div class="line">     */</div><div class="line">    struct Qdisc_class_ops  *cl_ops;</div><div class="line">    /* 包含排队规则标识（例如，pfifo、cbq等）的字符数组。*/</div><div class="line">    char                    id[IFNAMSIZ];</div><div class="line">    int                     priv_size;</div><div class="line"></div><div class="line">    int                     (*enqueue)(struct sk_buff *, struct Qdisc *);</div><div class="line">    struct sk_buff *        (*dequeue)(struct Qdisc *);</div><div class="line">    /* 如果报文已经发送，但是由于未知的原因而发送失败，则requeue()</div><div class="line">     * 函数将报文放回到它原来在队列中的位置。</div><div class="line">     */</div><div class="line">    int                     (*requeue)(struct sk_buff *, struct Qdisc);</div><div class="line">    /* 从队列中删除并丢弃报文 */</div><div class="line">    int                     (*drop)(struct Qdisc *);</div><div class="line"></div><div class="line">    int                     (*init)(struct Qdisc *, struct rtattr *arg);</div><div class="line">    /* 将排队规则重新设置到初始状态 */</div><div class="line">    void                    (*reset)(struct Qdisc *);</div><div class="line">    /* 销毁在排队规则初始化期间使用的资源 */</div><div class="line">    void                    (*destroy)(struct Qdisc *);</div><div class="line">    /* 改变一个排队规则的参数值 */</div><div class="line">    int                     (*change)(struct Qdisc *, struct rtattr *arg);</div><div class="line">    /* 显示排队规则的统计信息 */</div><div class="line">    int                     (*dump)(struct Qdisc * struct sk_buff);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>（3）结构Qdisc_class_ops</strong> 这是一个类别操作数据结构，它为某个特定的类别提供了一个控制函数集。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">include/net/pkt_sched.h</div><div class="line"></div><div class="line">struct Qdisc_class_ops</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    /* 作用是将一个新的排队规则附加到一个类别上，并将之前附加的排队规则返回 */</div><div class="line">    int              (*qrqft)(struct Qdisc *, unsigned long c1, struct Qdisc</div><div class="line">                           *, struct Qdisc **);</div><div class="line">    /* 返回一个指向类别的排队规则的指针 */</div><div class="line">    struct Qdisc *   (*leaf)(struct Qdisc *, unsigned long c1);</div><div class="line">    ......</div><div class="line">    /* 返回类别的内部ID */</div><div class="line">    unsigned long    (*get)(struct Qdisc *, u32 classid);</div><div class="line">    /* 当get返回的类别不再被引用时调用该函数 */</div><div class="line">    void             (*put)(struct Qdisc *, unsigned long);</div><div class="line">    /* 改变类别的属性，也用于创建新的类别 */</div><div class="line">    int              (*change)(struct Qdisc *, u32, u32, struct rtattr **, </div><div class="line">                           unsigned long *);</div><div class="line">    /* 删除一个类别 */</div><div class="line">    int              (*delete)(struct Qdisc *, unsigned long);</div><div class="line">    /* 遍历一个排队规则上所有的类别，用于获取所有类别的诊断数据 */</div><div class="line">    void             (*walk)(struct Qdisc *, struct qdisc_walker *org);</div><div class="line">    ......</div><div class="line">    /* 返回指向类别的过滤器列表的指针，用于管理过滤器列表 */</div><div class="line">    struct tcf_proto ** (*tcf_chain)(struct Qdisc *, unsigned long);</div><div class="line">    /* 绑定一个过滤器实例到类别 */</div><div class="line">    unsigned long    (*bind_tcf)(struct Qdisc *, unsigned long, u32 classid);</div><div class="line">    /* 从类别中删除一个过滤器实例 */</div><div class="line">    void             (*unbind_tcf)(struct Qdisc *, unsigned long);</div><div class="line">    ......</div><div class="line">    /* 返回类别的统计信息 */</div><div class="line">    int              (*dump)(struct Qdisc *, unsigned long, struct sk_buff </div><div class="line">                          *skb, struct tcmsg*);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>（4）结构cbq_class</strong> 该数据结构表示cbq排队规则的流量类型，用于根据为类型分配的带宽调度报文。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">net/sched/sch_cbq.c</div><div class="line"></div><div class="line">struct cbq_class</div><div class="line">&#123;</div><div class="line">    /* 指向类别中cbq_class中下一个类别 */</div><div class="line">    struct cbq_class     *next;</div><div class="line">    /* cbq调度算法维护了活动的流量类别类型，用于根据优先级调度类别*/</div><div class="line">    struct cbq_class     *next_alive;</div><div class="line">    ......</div><div class="line">    /* 在cbq排队规则中每个类别都通过一个编号（id）来表示。这个域包含了一个cbq类</div><div class="line">     *别的唯一编号。</div><div class="line">     */</div><div class="line">    u32                  classid;</div><div class="line">    /* 这个域包含了类别优先级，它用于调度cbq类别 */</div><div class="line">    unsigned char        priority;</div><div class="line">    /* 这个域包含了overtime之后使用的类别优先级。一个cbq类别有三种类型：</div><div class="line">     * overtime、underlimit和atlimit。</div><div class="line">     */</div><div class="line">    unsigned char        priority2;</div><div class="line">    /* 这个域用于计算空闲时间，计算是在cbq调度函数中指定的 */</div><div class="line">    unsigned char        ewma_log;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Linux中的服务质量（排队规则）的基本功能是决定如何按顺序接受输入的网络报文，以及使用什么带宽速率接收，并且决定何时以及如何将报文安排进队列中并按照分配的带宽速率进行传输。它主要是根据应用程序需求管理带宽。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP架构、设计及应用" scheme="http://yoursite.com/categories/TCP-IP%E6%9E%B6%E6%9E%84%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>延时确认定时器</title>
    <link href="http://yoursite.com/2018/01/03/TCP%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/03/TCP定时器（四）/</id>
    <published>2018-01-03T02:59:58.000Z</published>
    <updated>2018-03-03T01:50:26.855Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;TCP实现了两种确认模式：<br>&emsp;&emsp;快速确认<br>&emsp;&emsp;延时确认<br>&emsp;&emsp;在有些情况下，我们需要快速地得到ACK，以便于发送端在接收到ACK后，发出更多的数据，其原因是每个新数据的确认都会导致拥塞窗口加1。另外一些需要得到快速确认的情况是接收到乱序分段时，或者所接收数据的断档被填补时。也有一些情况需要延时确认，在这些情况中，会话是交互式的，如telnet、rlogin等，所要键入的每个字符都要回送。在这种情况下，如果为每个分段（只包含一个字符）生成确认，这将在网络中生成大量的报文。<br><a id="more"></a><br>&emsp;&emsp;Linux在struct ack结构中维护所有ACK相关的信息，它是struct_opt结构的一部分。源码如下：<br>include/net/sock.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct &#123;</div><div class="line">    __u8 pending; //表示任何给定时刻ACK的状态</div><div class="line">    __u8 quick; //</div><div class="line">    __u8 pingpong; //会话是交互式的</div><div class="line">    __u8 blocked; //延迟ACK被套接字锁阻塞</div><div class="line">    __u32 ato; //软时钟的预测滴答数</div><div class="line">    unsigned long timeout; //当前调度超时</div><div class="line">    __u32 lrcvtime; //收到最后一个数据包的时间戳</div><div class="line">    __u16 last_seq_size; //最后一个到来分段的大小</div><div class="line">    __u16 rcv_mss; //MSS用于延迟ACK决策</div><div class="line">&#125;ack;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;TCP ACK的状态有三个，源码如下：<br>include/net/tcp.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum tcp_ack_state_t</div><div class="line">&#123;</div><div class="line">    TCP_ACK_SCHED = 1; //表示调度了ACK</div><div class="line">    TCP_ACK_TIMER = 2; //表示已经安装了延时确认定时器</div><div class="line">    TCP_ACK_PUSHED = 4; //表示ACK需要尽早被发送出去</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="ACK的调度时机"><a href="#ACK的调度时机" class="headerlink" title="ACK的调度时机"></a>ACK的调度时机</h4><p>&emsp;&emsp;一旦从对等端得到数据，就需要调度ACK。调用tcp_schedule_ack()来设置TCP_ACK_SCHED标志。从tcp_rcv_established()和tcp_data_queue()中调用tcp_event_data_recv()接收数据时，都要调度ACK。<br>include/net/tcp.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static inline void tcp_schedule_ack(struct tcp_opt *tp)</div><div class="line">&#123;</div><div class="line">    tp-&gt;ack.pending |= TCP_ACK_SCHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;调用tcp_schedule_ack()可以调度一个ACK，但是不能基于该标志来强制发送ACK。ACK是立即发送还是延迟一段时间发送需要满足一定的条件。<br>net/ipv4/tcp_input.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">int tcp_rcv_established(struct sock *sk, struct sk_buff *skb, </div><div class="line">    struct tcphdr *th, unsigned len)</div><div class="line">&#123;</div><div class="line">    struct tcp_opt *tp = &amp;(sk-&gt;pinfo.af_tcp);</div><div class="line">    ......</div><div class="line">        if (eaten) &#123;</div><div class="line">            /* 检查是否处于快速ACK模式 */</div><div class="line">            if (tcp_in_quickack_mode(tp)) &#123;</div><div class="line">                /* 如果是，就立即生成ACK */</div><div class="line">                tcp_send_ack(sk);</div><div class="line">            &#125; else &#123;</div><div class="line">                /* 否则推迟一段时间 */</div><div class="line">                tcp_send_delayed_ack(sk);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; else &#123;</div><div class="line">            /* 如果应用程序没有读取数据，而是在接受对中排队，</div><div class="line">             * 就调用__tcp_ack_snd_check()做更严格的检查。</div><div class="line">             */</div><div class="line">            __tcp_ack_snd_check(sk, 0);</div><div class="line">        &#125;</div><div class="line">    ......</div><div class="line">    tcp_ack_snd_check(sk);</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;TCP实现了两种确认模式：&lt;br&gt;&amp;emsp;&amp;emsp;快速确认&lt;br&gt;&amp;emsp;&amp;emsp;延时确认&lt;br&gt;&amp;emsp;&amp;emsp;在有些情况下，我们需要快速地得到ACK，以便于发送端在接收到ACK后，发出更多的数据，其原因是每个新数据的确认都会导致拥塞窗口加1。另外一些需要得到快速确认的情况是接收到乱序分段时，或者所接收数据的断档被填补时。也有一些情况需要延时确认，在这些情况中，会话是交互式的，如telnet、rlogin等，所要键入的每个字符都要回送。在这种情况下，如果为每个分段（只包含一个字符）生成确认，这将在网络中生成大量的报文。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP架构、设计及应用" scheme="http://yoursite.com/categories/TCP-IP%E6%9E%B6%E6%9E%84%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>零窗口探测定时器</title>
    <link href="http://yoursite.com/2018/01/02/TCP%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/02/TCP定时器（三）/</id>
    <published>2018-01-02T10:23:59.000Z</published>
    <updated>2018-01-03T02:55:32.061Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;接收端TCP在接受缓冲区满时，通告零窗口一旦应用程序从接受缓冲区中读取数据，就检查是否在接受缓冲区中释放了足够的空间，以向发送端通告新窗口。如果是，就发出通告新窗口的ACK分段。如果该分段丢失，在仅有单向数据流动时，很可能会导致发送端和接收端之间产生死锁。为了避免这种情况发生，发送端实现了零窗口探测定时器。<br><a id="more"></a></p>
<h4 id="首次安装探测定时器的时机"><a href="#首次安装探测定时器的时机" class="headerlink" title="首次安装探测定时器的时机"></a>首次安装探测定时器的时机</h4><p>&emsp;&emsp;当要传输新分段时，需要在很多地方做检查：<strong>tcp_push_pending_frames()、tcp_data_snd_check()。</strong>tcp_push_pending_frames()在将数据从应用程序发往套接字传输队列时调用，tcp_data_snd_check()在从对等段接收到分段时调用。这些函数检查是否能够发出新分段，如果不能，就调用tcp_check_probe_timer()检查是否接收窗口不允许数据分段发送而引发的。tcp_check_probe_timer()检查是否没有未确认数据（!tp-&gt;packets_out）且没有安装定时器（!tp-&gt;pending）。源码如下：<br>include/net/tcp.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static __inline__ </div><div class="line">void tcp_check_probe_timer(struct sock *sk, struct tcp_opt *tp)</div><div class="line">&#123;   </div><div class="line">    /* 检查是否有未确认数据且没有安装定时器 */</div><div class="line">    if (!tp-&gt;packets_out &amp;&amp; !tp-&gt;pending)</div><div class="line">        /* 设置零窗口定时器的超时值为tp-&gt;rto */</div><div class="line">        tcp_reset_xmit_timer(sk, TCP_TIME_PROBE0, tp-&gt;rto);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="取消连接探测定时器的时机"><a href="#取消连接探测定时器的时机" class="headerlink" title="取消连接探测定时器的时机"></a>取消连接探测定时器的时机</h4><p>&emsp;&emsp;当在tcp_ack()中处理输入ACK时，我们要检查这是否是一个有效的ACK，同时还有没有未确认的数据。如果是一个有效ACK，且有未确认的数据，那么可以判断这可能是窗口更新或者零窗口探测而引发的ACK。于是需要处理窗口更新，首先清除探测计数器（tp-&gt;probes_out），此外，如果还有任何待传输的新分段（tp-&gt;send_head != NULL），就调用tcp_ack_probe()来做进一步处理。源码如下：<br>net/ipv4/tcp_input.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void tcp_ack_probe(struct sock *sk)</div><div class="line">&#123;</div><div class="line">    struct tcp_opt *tp = &amp;(sk-&gt;tp_pinfo.af_tcp);</div><div class="line">    ......</div><div class="line">    /* 检查下一要传输的分段是否位于对等端所打开的窗口内 */</div><div class="line">    if (!after(TCP_SKB_CB(tp-&gt;send_head)-&gt;end_seq, tp-&gt;snd_una + tp-&gt;snd_wnd)) &#123;</div><div class="line">        tp-&gt;backoff = 0;</div><div class="line">        /* 如果传输队列头的结束序列号（tp-&gt;send_head）位于所打开窗口序</div><div class="line">         * 列空间内，就可以调用tcp_clear_xmit_timer()来停止零窗口探测。</div><div class="line">         */</div><div class="line">        tcp_clear_xmit_timer(sk, TCP_TIME_PROBE0);</div><div class="line">        ......</div><div class="line">    &#125; else &#123;</div><div class="line">        /* 否则，表示没有足够的空间来容纳传输队列头中的全部数据，因此，重置</div><div class="line">         * 有tp-&gt;rto和tp-&gt;backoff控制的定时器超时值，以继续零窗口探测。</div><div class="line">         */</div><div class="line">        tcp_reset_xmit_timer(sk, TCP_TIME_PROBE0, min(tp-&gt;rto &lt;&lt; tp-&gt;backoff, TCP_RTO_MAX));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="窗口探测定时器的工作原理"><a href="#窗口探测定时器的工作原理" class="headerlink" title="窗口探测定时器的工作原理"></a>窗口探测定时器的工作原理</h4><p>&emsp;&emsp;重传定时器和窗口探测定时器有一个公共的定时器回调函数，即tcp_write_timer()。tcp_write_timer()根据tp-&gt;pending标志来决定所要调用的函数。在任何时刻，只能安装一个定时器，也就是说，重传定时器或者窗口探测定时器。当窗口探测定时器超时时，需要调用tcp_probe_timer()来传输零窗口探测分段。源码如下：<br>net/ipv4/tcp_timer.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">static void tcp_probe_timer(struct sock *sk)</div><div class="line">&#123;</div><div class="line">    struct tcp_opt *tp = &amp;sk-&gt;tp_pinfo.af_tcp;</div><div class="line">    int max_probes;</div><div class="line"></div><div class="line">    /* 检查是否有未确认数据，如果tp-&gt;packets_out大于1，就意味着安装了零窗口探测</div><div class="line">     * 定时器后，已传输了一些新分段。第二个条件检查是否有要传输的新分段，如果没</div><div class="line">     * 有新数据要传输，就没有必要安装窗口探测器了。</div><div class="line">     */</div><div class="line">    if (tp-&gt;packets_out || !tp-&gt;send_head) &#123;</div><div class="line">        tp-&gt;probes_out = 0;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    max_probes = sysctl_tcp_retries2;</div><div class="line">    /* 检查与连接相关联的套接字是否已经死亡，如果是，就检查是否可以放弃该连接*/</div><div class="line">    if (sk-&gt;dead) &#123;</div><div class="line">        int alive = ((tp-&gt;rto &lt;&lt; tp-&gt;backoff) &lt; TCP_RTO_MAX);</div><div class="line">        ......</div><div class="line">        /* 检查是否可以立即放弃该连接。如果TCP套接字已经处于死亡状态，就需要根</div><div class="line">         * 据系统中孤立套接字的总量来对死亡套接字做出某种操作，也就是说，如果连</div><div class="line">         * 接很长时间内没有任何操作，就确认立即关闭该连接，以释放所占用的资源。</div><div class="line">         */</div><div class="line">        if (tcp_out_of_resources(sk, alive || tp-&gt;probes_out &lt;= max_probes))</div><div class="line">            return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* 检查探测次数是否超出了系统级控制参数 */</div><div class="line">    if (tp-&gt;probes_out &gt; max_probes) &#123;</div><div class="line">        /* 如果是，就放弃该连接 */</div><div class="line">        tcp_write_err(sk);</div><div class="line">    &#125; else &#123;</div><div class="line">        /* 否则发出零窗口探测 */</div><div class="line">        tcp_send_probe0(sk);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;接收端TCP在接受缓冲区满时，通告零窗口一旦应用程序从接受缓冲区中读取数据，就检查是否在接受缓冲区中释放了足够的空间，以向发送端通告新窗口。如果是，就发出通告新窗口的ACK分段。如果该分段丢失，在仅有单向数据流动时，很可能会导致发送端和接收端之间产生死锁。为了避免这种情况发生，发送端实现了零窗口探测定时器。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP架构、设计及应用" scheme="http://yoursite.com/categories/TCP-IP%E6%9E%B6%E6%9E%84%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TCP重传定时器</title>
    <link href="http://yoursite.com/2018/01/02/TCP%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/02/TCP定时器（二）/</id>
    <published>2018-01-02T07:21:20.000Z</published>
    <updated>2018-01-02T10:20:26.982Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;TCP重传定时器是TCP状态机的一部分，用来检查网络拥塞/数据丢失。TCP就其所接收到的每个字节发出确认，一次来维护数据完整性。发送端根据确认报文中的时间戳选型来计算RTT（往返时间），然后根据RTT计算重传超时时间。<br><a id="more"></a><br>&emsp;&emsp;当发出窗口中的第一个分段时，就需要安装一个重传定时器，超时时间为一个RTO。这确保TCP在分段发送后的RTO时间内收到ACK，如果没有得到确认，重传定时器就超时，据此判断出所有窗口中的数据都已丢失。</p>
<h4 id="安装重传定时器的时机"><a href="#安装重传定时器的时机" class="headerlink" title="安装重传定时器的时机"></a>安装重传定时器的时机</h4><p>&emsp;&emsp;传输当前窗口的第一个报文时就需要安装重传定时器。packet_out记录了已经传输但还没确认的报文，一旦传输一个新的报文，就要将packet_out加一。在传输结束后，检查packet_out是否为零，如果是，就启动重传定时器在tp-&gt;rto时间后超时。<br>net/ipv4/tcp_output.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static __inline__ </div><div class="line">void update_send_head(struct sock *sk, struct tcp_opt *tp, struct sk_buff *skb)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    /* tcp_write_xmit()在成功传输完第一个分段后，将调用updata_send_head()</div><div class="line">     * 重置第一个分段的重传定时器。</div><div class="line">     */</div><div class="line">    if (tp-&gt;packets_out++ == 0)</div><div class="line">        tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp-&gt;rto); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="重置或取消重传定时器的时机"><a href="#重置或取消重传定时器的时机" class="headerlink" title="重置或取消重传定时器的时机"></a>重置或取消重传定时器的时机</h4><p>&emsp;&emsp;每收到一个ACK，TCP都要重置重传定时器，该ACK通告了一个发送窗口，调用顺序是tcp_ack()-&gt;tcp_clean_rtx_queue()调用tcp_ack_packets_out()。源码如下：<br>net/ipv4/tcp_output.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static __inline__ void tcp_ack_packets_out(struct sock *sk, struct tcp_opt *tp)</div><div class="line">&#123;</div><div class="line">    /* 如果所有分段都收到确认，就删除重传定时器 */</div><div class="line">    if (tp-&gt;packets_out == 0) &#123;</div><div class="line">        tcp_clear-xmit_timer(sk, TCP_TIME_RETRANS);</div><div class="line">    /* 否则重置重传定时器 */</div><div class="line">    &#125; else &#123;</div><div class="line">        tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp-&gt;rto);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在丢失恢复过程中传输分段时，如果在tcp_xmit_retransmit_queue()中重新传输重传队列的第一个分段，就重置重传定时器。重传定时器不仅仅考虑重传，还要调整超时值、重置路由、检查重试次数是否超出了限度等。<br>net/ipv4/tcp_output.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">static void tcp_retransmit_timer(struct sock *sk)</div><div class="line">&#123;</div><div class="line">    struct tcp_opt *tp = &amp;sk-&gt;tp_pinfo.af_tcp;</div><div class="line">    /* 乳沟没有报文传输，就返回，表示没有要重传的分段 */</div><div class="line">    if (tp-&gt;packets_out == 0)</div><div class="line">        goto out;</div><div class="line">    ......</div><div class="line">    /* 检查发送窗口是否关闭，套接字是否仍然活跃 */</div><div class="line">    if (tp-&gt;snd_wnd == 0 &amp;&amp; !sk-&gt;dead &amp;&amp; </div><div class="line">        !(1 &lt;&lt; sk-&gt;state)&amp;(TCPF_SYN_SENT|TCPF_SYN_RECV)) &#123;</div><div class="line">            ......</div><div class="line">            /* 如果超过了TCP_RTO_MAX的时间后还没有收到ACK，就需要设置该连接为超</div><div class="line">             * 时。</div><div class="line">             */</div><div class="line">            if (tcp_time_stamp - tp-&gt;rcv_tstamp &gt; TCP_RTO_MAX) &#123;</div><div class="line">                tcp_write_err(sk);</div><div class="line">                goto out;</div><div class="line">            &#125;</div><div class="line">            /* 如果该连接没有超时，就进入慢启动表示进入报文丢失状态 */</div><div class="line">            tcp_entry_loss(sk, 0);</div><div class="line">            /* 重新传输重传队列的头部 */</div><div class="line">            tcp_retransmit_skb(sk, skb_peek(&amp;sk-&gt;write_queue));</div><div class="line">            /* 使目的地址失效 */</div><div class="line">            __sk_dst_reset(sk);</div><div class="line">            /* 无法与对等端通信时，会导致窗口无法更新，这时会产生替代路由 */</div><div class="line">            goto out_reset_timer;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* 检查是否已超出重传次数 */</div><div class="line">        if (tcp_write_timeout(sk))</div><div class="line">            goto out;</div><div class="line">            ......</div><div class="line">        /* 表示没有超出重传次数，进入慢启动阶段 */</div><div class="line">        tcp_entry_loss(sk, 0);</div><div class="line"></div><div class="line">        /* 返回值大于0表示重传失败 */</div><div class="line">        if (tcp_retransmit_skb(sk, skb_peek(&amp;sk-&gt;write_queue)) &gt; 0) &#123;</div><div class="line">            /* tp-&gt;retransmits记录了重传丢失分段的次数 */</div><div class="line">            if (!tp-&gt;retransmits)</div><div class="line">                tp-&gt;retransmits = 1;</div><div class="line">            /* 重置重传定时器为rto和TCP_RESOURCE_PROBE_INTERVAL的较小值 */</div><div class="line">            tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, </div><div class="line">                min(tp-&gt;rto, TCP_RESOURSE_INTERVAL));</div><div class="line">            goto out;</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        /* 表示成功传输了丢失的分段 */</div><div class="line">        tp-&gt;backoff++;</div><div class="line">        tp-&gt;retransmits++;</div><div class="line"></div><div class="line">out_reset_timer:</div><div class="line">        /* 超时值取tp-&gt;rto和TCP_RTO_MAX中的较小值 */</div><div class="line">        tp-&gt;rto = min(tp-&gt;rto&lt;&lt;1, TCP_RTO_MAX);</div><div class="line">        /* 重置重传定时器 */</div><div class="line">        tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp-&gt;rto);</div><div class="line">        /* 检查重传最大次数是否超出了路由复位的次数 */</div><div class="line">        if (tp-&gt;retransmits &gt; sysctl_tcp_retries1)</div><div class="line">            __sk_dst_reset(sk);</div><div class="line"></div><div class="line">out:;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;连接超时有4个系统控制参数：<br>&emsp;&emsp;sysctl_tcp_retries1<br>&emsp;&emsp;sysctl_tcp_retries2<br>&emsp;&emsp;sysctl_tcp_syn_retries<br>&emsp;&emsp;sysctl_tcp_orphan_retries<br>&emsp;&emsp;sysctl_tcp_retries1是最大重传次数，超出该次数之后，要检查中间路由器是否失效。sysctl_tcp_retries2是分段重传的最大尝试次数，超出重试次数后，将放弃该连接。sysctl_tcp_syn_retries是重传SYN分段的最大尝试次数，在此之后，将放弃重试。sysctl_tcp_orphan_retries是孤立套接字的最大重试次数。</p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;TCP重传定时器是TCP状态机的一部分，用来检查网络拥塞/数据丢失。TCP就其所接收到的每个字节发出确认，一次来维护数据完整性。发送端根据确认报文中的时间戳选型来计算RTT（往返时间），然后根据RTT计算重传超时时间。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP架构、设计及应用" scheme="http://yoursite.com/categories/TCP-IP%E6%9E%B6%E6%9E%84%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的定时器</title>
    <link href="http://yoursite.com/2018/01/02/TCP%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/02/TCP定时器（一）/</id>
    <published>2018-01-01T17:55:01.000Z</published>
    <updated>2018-01-02T10:23:27.174Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;TCP是一个事件驱动的状态机。TCP为实现可靠的传输，主要定义并实现了以下定时器：重传定时器、延时确认定时器、零窗口探测定时器（持久定时器）、keepalive定时器、TIME_WAIT定时器、SYN-ACK定时器（监听套接字定时器）。<br><a id="more"></a><br>&emsp;&emsp;重传定时器、延时确认定时器和零窗口探测定时器是TCP状态机核心实现的一部分。keepalive定时器用来管理已建立的连接。TIME_WAIT定时器用来管理关闭的连接，并等待2*MSL后超时。SYN-ACK定时器用来管理新连接请求。TCP提供了如下三个函数来管理这些定时器：<br>&emsp;&emsp;tcp_reset_xmit_timeer()<br>&emsp;&emsp;tcp_reset_keepalive_timer()<br>&emsp;&emsp;tcp_clear_xmit_timer()<br>&emsp;&emsp;tcp_reset_xmit_timer()是用来重置TCP状态机定时器的通用函数。tcp_reset_keepalive_timer()是重置连接管理定时器的接口，如keepalive定时器和SYN-ACK定时器。tcp_clear_xmit_timer()用来清楚或删除已安装的TCP定时器。</p>
<h3 id="Linux中的定时器"><a href="#Linux中的定时器" class="headerlink" title="Linux中的定时器"></a>Linux中的定时器</h3><p>&emsp;&emsp;Linxu实现定时器的数据结构是struct timer_list，源码如下：<br>include/linux/timer.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct timer_list &#123;</div><div class="line">    /* list指向列表头的指针，这时定时器所在的位置 */</div><div class="line">    struct list_head list;</div><div class="line">    /* 存储定时器启动所需的时钟周期数 */</div><div class="line">    unsigned long expires;</div><div class="line">    /* 包含传递给定时器回调函数的参数 */</div><div class="line">    unsigned long data;</div><div class="line">    /* 定时器超时时，所需要执行的回调函数 */</div><div class="line">    void (*functian) (unsigned long);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="mod-timer"><a href="#mod-timer" class="headerlink" title="mod_timer()"></a>mod_timer()</h4><p>&emsp;&emsp;当需要修改定时器的超时时间时，就需要调用mod_timer()，源码如下：<br>kernel/timer.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int mod_timer(struct time_list *timer, unsigned long expires)</div><div class="line">&#123;</div><div class="line">    int ret;</div><div class="line">    unsigned long flags;</div><div class="line">    /* 修改定时器的expires域要获取全局定时器旋转锁timerlist_lock */</div><div class="line">    spin_lock_irqsave(&amp;timertlist_lock, flags);</div><div class="line">    timer-&gt;expires = expires;</div><div class="line">    /* 将已安装定时器从全局列表中删除 */</div><div class="line">    ret = detach_timer(timer);</div><div class="line">    /* 在全局列表中添加定时器 */</div><div class="line">    internal_add_timer(timer);</div><div class="line">    spin_unlockirqrestore(&amp;timerlist_lock, flags);</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="detach-timer"><a href="#detach-timer" class="headerlink" title="detach_timer()"></a>detach_timer()</h4><p>&emsp;&emsp;该函数将已安装的定时器从全局列表中分离，源码如下：<br>kernel/timer.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static inline int detach_timer()</div><div class="line">&#123;</div><div class="line">   /* timer_pending()函数检查定时器是否安装在全局列表中，如果没有安装，那么定</div><div class="line">    * 时器列表头的next域为NULL，直接返回0. </div><div class="line">    */</div><div class="line">   if (!timer_pending(timer));</div><div class="line">       return 0;</div><div class="line">   /* 如果已经安装，那么调用list_del()将已安装定时器从全局列表中分离 */</div><div class="line">   list_del(&amp;timer-&gt;list);</div><div class="line">   return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="del-timer"><a href="#del-timer" class="headerlink" title="del_timer()"></a>del_timer()</h4><p>&emsp;&emsp;当要求取消某定时器时，首先调用timer_pending()来检查该定时器是否安装。如果定时器已经安装，就调用del_timer()从列表中删除定时器，将定时器从全局列表中删除的操作需要获取全局宣转锁timerlist_lock。源码如下：<br>kernel/timer.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int del_timer(struct timer_list *timer)</div><div class="line">&#123;</div><div class="line">    int ret;</div><div class="line">    unsigned long flags;</div><div class="line"></div><div class="line">    spin_lock_irqsave(&amp;timertlist_lock, flags);</div><div class="line">    /* 调用detach_timer()来从全局列表中分离该定时器 */</div><div class="line">    ret = detach-timer(timer);</div><div class="line">    /* 将定时器列表头的next和previous域置为NULL */</div><div class="line">    timer-&gt;list.next = timer-&gt;list.prev = NULL;</div><div class="line">    spin_unlockirqrestore(&amp;timerlist_lock, flags);</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="执行定时器函数的时机"><a href="#执行定时器函数的时机" class="headerlink" title="执行定时器函数的时机"></a>执行定时器函数的时机</h4><p>&emsp;&emsp;定时器中断每10ms一次，也就是说，一个时钟周期产生一次。该中断通过从do_timer()调用mark_bh()来产生软中断处理定时器。调用mark_bh()要传递bh_task_vec[]中的偏移量，mark_bh()调用tasklet_hi_schedule()来调度bh_task_vec[TIMER_BH]所指向的任务。在此要首先检查是否已经调度了该任务，如果该任务还没有调度，就调度<strong>tasklet_hi_schedule()来调度它，这可以保证一个任务仅在一个CPU上调度，同样的任务不能也不能在同一个CUP上调用两次。</strong>tasklet_hi_schedule()将在当前的CPU上调度该定时器任务。在每个CPU的tasklet_hi_vec[cpu].list列表中添加任务，然后产生HI_SOFTIRQ软中断。<br>kernel/timer.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void __tasklet_hi_schedule(struct tasklet_struct *t)</div><div class="line">&#123;</div><div class="line">    int cpu = smp_processor_id();</div><div class="line">    unsigned long flags;</div><div class="line"></div><div class="line">    local_irq_save(flags);</div><div class="line">    t-&gt;next = tasklet_hi_vec[cpu].list;</div><div class="line">    tasklet_hi_vec[cpu].list = t;</div><div class="line">    cpu_raise_softirq(cpu, HI_SOFTIRQ);</div><div class="line">    local_irq_restore(flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;TCP是一个事件驱动的状态机。TCP为实现可靠的传输，主要定义并实现了以下定时器：重传定时器、延时确认定时器、零窗口探测定时器（持久定时器）、keepalive定时器、TIME_WAIT定时器、SYN-ACK定时器（监听套接字定时器）。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP架构、设计及应用" scheme="http://yoursite.com/categories/TCP-IP%E6%9E%B6%E6%9E%84%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TCP接收</title>
    <link href="http://yoursite.com/2017/12/31/TCP%E6%8E%A5%E6%94%B6/"/>
    <id>http://yoursite.com/2017/12/31/TCP接收/</id>
    <published>2017-12-31T01:52:31.000Z</published>
    <updated>2018-01-03T02:55:31.647Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;应用程序向内核发出请求，从TCP套接字接收正常或者紧急数据。内核套接字实现必须区分这两种不同类型的请求。当应用程序希望接收一个紧急字节的OOB数据时，它必须选择合适的时机已读取数据；否则可能会导致数据丢失。<br>&emsp;&emsp;TCP将数据看做是字节流，TCP接受缓冲区仅排列按序收到的字节，乱序数据则进入另外一个队列，并且来自该队列的数据不能响应应用程序请求。<br><a id="more"></a></p>
<h4 id="排队机制"><a href="#排队机制" class="headerlink" title="排队机制"></a>排队机制</h4><p>&emsp;&emsp;接收输入TCP报文时，有三个队列：<br>&emsp;&emsp;（1）待处理队列（sk-&gt;backlog）；<br>&emsp;&emsp;（2）预排队队列（tp-&gt;ucopy.prequeue）；<br>&emsp;&emsp;（3）接受队列（sk-&gt;receive_queue）；<br>&emsp;&emsp;sk-&gt;receive_queue包含了处理过的TCP数据包，也就是说，去除了全部的协议头，正准备将数据复制到用户应用程序。sk-&gt;receive_queue包含了所有按顺序接收的数据段，在其他两个队列中的TCP数据段则需要进一步处理。<br>&emsp;&emsp;TCP报文首先由tcp_v4_rcv()进行处理。该函数要决定是否需要处理报文或者在backlog和prequeue队列中排队。源码如下：<br>net/ipv4/tcp_ipv4.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">int tcp_v4_rcv(struct sk_buff *skb)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    bh lock_sock(sk); //获取套接字旋转锁</div><div class="line">    ret = 0;</div><div class="line">    </div><div class="line">    if (!sk-&gt;lock.users) &#123; //检查套接字是否处于使用状态</div><div class="line">        if (!tcp_prequeue(sk, skb))</div><div class="line">            ret = tcp_v4_do_rav(sk, skb);</div><div class="line">    &#125; else </div><div class="line">        /* 如果套接字处于使用状态，就将数据包放入待处理队列 */</div><div class="line">        sk_add_backlog(sk, skb);</div><div class="line">    bh_unlock_sock(sk);</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;应用程序向内核发出请求，从TCP套接字接收正常或者紧急数据。内核套接字实现必须区分这两种不同类型的请求。当应用程序希望接收一个紧急字节的OOB数据时，它必须选择合适的时机已读取数据；否则可能会导致数据丢失。&lt;br&gt;&amp;emsp;&amp;emsp;TCP将数据看做是字节流，TCP接受缓冲区仅排列按序收到的字节，乱序数据则进入另外一个队列，并且来自该队列的数据不能响应应用程序请求。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP架构、设计及应用" scheme="http://yoursite.com/categories/TCP-IP%E6%9E%B6%E6%9E%84%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>构建和解析协议层的协议头</title>
    <link href="http://yoursite.com/2017/12/29/%E6%9E%84%E5%BB%BA%E5%92%8C%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%A4%B4/"/>
    <id>http://yoursite.com/2017/12/29/构建和解析协议层的协议头/</id>
    <published>2017-12-29T07:06:24.000Z</published>
    <updated>2018-03-04T02:27:04.308Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在上一篇博客说了sk_buff和协议头，这里说下如何构建向下遍历协议层时的协议头和解析向上遍历协议层时的协议头。<br><a id="more"></a></p>
<h3 id="构建向下遍历协议层时的协议头"><a href="#构建向下遍历协议层时的协议头" class="headerlink" title="构建向下遍历协议层时的协议头"></a>构建向下遍历协议层时的协议头</h3><h4 id="TCP头的添加"><a href="#TCP头的添加" class="headerlink" title="TCP头的添加"></a>TCP头的添加</h4><p><img src="../../../../pictres/TCP/20171229154204.png" alt=""><br>&emsp;&emsp;在TCP载荷（skb-&gt;data）前面添加TCP协议头，TCP调用tcp_transmit_skb()来为TCP数据构建一个TCP头。首先计算TCP头的长度，要考虑当前TCP连接所使用的TCP选项。一旦完成该操作，就需要调用skb_push()来为TCP头分配空间，该函数将data指针向head指针方向移动TCP头所请求的长度。如上图所示，当skb_push()返回时，skb-&gt;h.th将指向skb-&gt;data。下面是分配TCP头的源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">net/ipv4/tcp_output.c</div><div class="line"></div><div class="line">        if (sysctl_tcp_window_scaling) &#123;</div><div class="line">            tcp_header_size += TCPOLEN_WSCALE_ALLGNED;</div><div class="line">            sysctl_flags |= SYSCTL_FLAG_WSCALE;</div><div class="line">        &#125;</div><div class="line">    ......</div><div class="line">    /* 调用skb_push()来为TCP头分配空间 */</div><div class="line">    th = (struct tcphdr *) skb_push(skb, tcp_header_size);</div><div class="line">    /* 将skb-&gt;h.th指向skb-&gt;data */</div><div class="line">    skb-&gt;h.th = th;</div><div class="line">    ......</div><div class="line">    th-&gt;source = sk-&gt;sport; //指向源端口</div><div class="line">    th-&gt;dest   = sk-&gt;dport; //指向目的端口</div><div class="line">    th-&gt;seg    = htonl(tcb-&gt;seq);</div></pre></td></tr></table></figure></p>
<h4 id="IP头的添加"><a href="#IP头的添加" class="headerlink" title="IP头的添加"></a>IP头的添加</h4><p><img src="../../../../pictures/TCP/20171229154141.png" alt=""><br>&emsp;&emsp;当添加完TCP头后，报文会被传递给IP层，这时IP层会调用ip_build_and_pkt()构建自己的IP头，并添加到报文的起始处（skb-&gt;data之前），然后发送给链路层。处理过IP选项后，接下来会计算IP头的长度，然后调用skb_push()为IP头分配空间，该函数返回skb-&gt;data指针。源代码如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">net/ipv4/tcp_output.c</div><div class="line"></div><div class="line">int in_build_and_send_pkt(struct sk_buff *skb, struct sock *sk, u32 saddr, u32 daddr, struct ip_options *opt)</div><div class="line">&#123;</div><div class="line">    struct rtable *rt = (struct rtable *)skb-&gt;dst;</div><div class="line">    struct iphdr *iph;</div><div class="line">    /* 有选项的话，加上选项长度 */</div><div class="line">    if (opt)</div><div class="line">        iph=(struct iphdr *)skb_push(skb, sizeof(struct iphdr) + opt-&gt;sptlen);</div><div class="line">    else //没有选项，就只需加上IP头长度</div><div class="line">        iph=(struct iphdr *)skb-&gt;push(skb, sizeof(struct iphdr));</div><div class="line">    iph-&gt;version = 4; //表示IPV4</div><div class="line">    iph-&lt;ihl     = 5;</div><div class="line">    iph-&gt;tos     = sk-&gt;protinfo.af_mettos; //数据包的类型</div><div class="line">    ......</div><div class="line">    /* 使用skb-&gt;nh.iph指向skb-&gt;data*/</div><div class="line">    skb-&gt;nh.iph  = iph;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="链路层头的添加"><a href="#链路层头的添加" class="headerlink" title="链路层头的添加"></a>链路层头的添加</h4><p><img src="../../../../pictures/TCP/20171229165915.png" alt=""><br>&emsp;&emsp;添加完TCP头和IP头后，报文会被传递到链路层，接下来会调用eth_header()添加MAC头。eth_header()将data指针向head指针推进ETH_HLEN字节。访问skb-&gt;data所指向的以太网头起始位置，并在此位置构建以太网头。下面是源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int eth_header(struct sk_buff *skb, struct net_device *dev, unsigned short type, void *daddr, void *asddr, unsigned len)</div><div class="line">&#123;</div><div class="line">    /* ETH_HLEN为链路层头的长度 */</div><div class="line">    struct ethhdr *eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解析向上遍历协议层时的协议头"><a href="#解析向上遍历协议层时的协议头" class="headerlink" title="解析向上遍历协议层时的协议头"></a>解析向上遍历协议层时的协议头</h3><h4 id="sk-buff指向链路层驱动要处理的链路层头"><a href="#sk-buff指向链路层驱动要处理的链路层头" class="headerlink" title="sk_buff指向链路层驱动要处理的链路层头"></a>sk_buff指向链路层驱动要处理的链路层头</h4><p><img src="../../../../pictures/TCP/20171229191911.png" alt=""><br>&emsp;&emsp;当新报文到达时，要为新报文分配一个新的sk_buff，其大小等于报文的长度。sk_buff的data域指向报文的起始位置（以太网头）。如图所示，链路层驱动根据其头来发现下一个协议头，然后正确的处理这些指针。以以太网驱动的接收例程e100_rx()为例，它的环缓冲区中得到所接受报文的指针，然后从以太网头域中查找下一个协议层协议。它调用eth_type_trans()，eth_type_trans()将sk_buff的data指针向下移动以太网头的长度，使其指向IP头，该例程在sk_buff到IP backlog队列排队之前完成。源代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">net/ethernet/eth.c</div><div class="line"></div><div class="line">    unsigned short eth_type_trans(struct sk_buff *skb, struct net_device *dev)</div><div class="line">    &#123;</div><div class="line">        struct ethhdr *eth;</div><div class="line">        unsigned char *rawp;</div><div class="line">        /* 指向报文的起始位置 */</div><div class="line">        skb-&gt;mac.raw = skb-&gt;data;</div><div class="line">        /* 调用skb_pull()指向IP头 */</div><div class="line">        skb_pull(skb, dev-&gt;hard_header_len);</div><div class="line">        eth = skb-&gt;mac.ethernet;</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="sk-buff指向IP层要处理的IP头"><a href="#sk-buff指向IP层要处理的IP头" class="headerlink" title="sk_buff指向IP层要处理的IP头"></a>sk_buff指向IP层要处理的IP头</h4><p><img src="../../../../pictures/TCP/20171229211749.png" alt=""><br>&emsp;&emsp;现在sk_buff处于IP bakclog队列中，由netif_receive_skb()负责处理，该函数将sk_buff从backlog队列中取出。nh.raw指向sk_buff的data域，根据nh.iph可以直接访问IP头，源码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">net/core/dev.c</div><div class="line">    int netif_receive_skb(struct sk_buff *skb)</div><div class="line">    &#123;</div><div class="line">        struct packet_type *ptype, *pt_prev;</div><div class="line">        ......</div><div class="line">        skb-&gt;h.raw = skb-&gt;nh.raw = skb-&gt;data; </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="sk-buff指向TCP层要处理的TCP头"><a href="#sk-buff指向TCP层要处理的TCP头" class="headerlink" title="sk_buff指向TCP层要处理的TCP头"></a>sk_buff指向TCP层要处理的TCP头</h4><p><img src="../../../../pictures/TCP/20171229212735.png" alt=""><br>&emsp;&emsp;最后，一个IP陈例程ip_local_deliver_finish()处理发往下一个协议的报文，并将sk_buff的data指针向前移动IP头的长度（包括IP选项），使其指向传输层头。因此，当sk_buff传递给传输层处理例程时，h.th指针指向传输层头的起始位置，如上图所示。源码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">net/ipv4/ip_input.c</div><div class="line"></div><div class="line">    static inline int ip_local_deliver_finish(struct sk_buff *skb)</div><div class="line">    &#123;</div><div class="line">        int ihl = skb-&gt;nh.iph-&gt;ihl*4;</div><div class="line">        ......</div><div class="line">        __skb_pull(skb, ihl);</div><div class="line">        ......</div><div class="line">        skb-&gt;h.raw = skb-&gt;data;</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最后传输层调用tcp_v4_do_rcv()处理传输层头报文。如果连接已建立，并且TCP报文中有数据，就调用skb_copy_datatram_iovec()将从skb-&gt;data的偏移量$I_dth$开始的数据复制给用户应用程序。如果由于某些原因不能复制数据给用户应用程序，就将sk_buff的data指针向前移动TCP头的长度（包括选项），然后将其发往套接字的接受队列排队。源代码和skb_buff图如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">net/ipv4/tcp_input.c</div><div class="line"></div><div class="line">int tcp_rvc_established(struct sock *sk, struct sk_buff *skb)</div><div class="line">&#123;</div><div class="line">    struct tcp_opt *tp = &amp;(sk-&gt;tp_pinfo.af_tcp);</div><div class="line">    ......</div><div class="line">        /* 将sk_buff的data指针向前移动TCP头长度 */</div><div class="line">        __skb_pull(skb, tcp_header_len);</div><div class="line">        /* */</div><div class="line">        __skb_queue_tail(&amp;sk-&gt;receive_queue, skb);</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="../../../../pictures/TCP/20171230085652.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在上一篇博客说了sk_buff和协议头，这里说下如何构建向下遍历协议层时的协议头和解析向上遍历协议层时的协议头。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP架构、设计及应用" scheme="http://yoursite.com/categories/TCP-IP%E6%9E%B6%E6%9E%84%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>sk_buff和协议头</title>
    <link href="http://yoursite.com/2017/12/26/sk-buff%E5%92%8C%E5%8D%8F%E8%AE%AE%E5%A4%B4/"/>
    <id>http://yoursite.com/2017/12/26/sk-buff和协议头/</id>
    <published>2017-12-26T00:23:44.000Z</published>
    <updated>2017-12-29T05:03:11.929Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在Linux TCP/IP协议栈中，sk_buff是代表网络报文的网络缓冲区。sk_buff有三个构成部分：sk_buff、线性数据缓冲区、分页数据（struct_skb_shared_info）。当请求sk_buff时，需要传递线性数据区域的长度。sk_buff中有一些页分别指向传输层、网络层和链路层头。<br>&emsp;&emsp;这篇博客主要讨论sk_buff结构中的各个域，以及处理sk_buff结构的头、尾、结束、数据以及长度域的函数，将对sk_buff结构的data_len域和处理该域的函数做出说明。还将阐述skb_shared_info结构以及该结构的用途，然后描述了各种与sk_buff复制和排队操作相关的各种函数。<br>&emsp;&emsp;sk_buff包含线性和非线性两部分的数据。线性数据由sk_buff的数据域表示。一般来说，能够在单页中容纳的IP报文才分配一页的线性数据。如果整个IP报文的长度超过了一页的容量，处理该报文就有两个选择。一种是分配一个长度可容纳整个IP报文的先行数据区，另一种是使用分页数据区来容纳报文的剩余部分（线性数据=1页，IP剩余部分则存储在sk_buff的分页数据区中）。<br><a id="more"></a></p>
<h4 id="结构sk-buff"><a href="#结构sk-buff" class="headerlink" title="结构sk_buff"></a>结构sk_buff</h4><p>&emsp;&emsp;在Linux中，sk_buff结构代表了一个报文，它由三个部分组成。<br>&emsp;&emsp;（1）sk_buff结构，也称为sk_buff头；<br>&emsp;&emsp;（2）包含数据的线性数据块；<br>&emsp;&emsp;（3）由struct skb_shared_info表示的非线性数据部分；<br>&emsp;&emsp;sk_buff结构包含指向特定协议头数据结构的指针域，因此，有些域包含了每一层的控制信息，以便构建协议头，同时还可以用来根据特定事件判断下一步的处理动作。有些域包含IP校验和，以及下一个协议信息。任何时候当要从某接口接收或者发送新报文时，都要为该数据块分配一个sk_buff结构，并将数据复制到sk_buff中，然后才进一步处理报文。根据需要，可以克隆（只复制sk_buff结构，但是共享数据块）或完全复制sk_buff（完全复制sk_buff结构，同时也复制了一份数据块）。<br>&emsp;&emsp;下面是sk_buff结构定义的代码块实现：<br>include/linux/skbuff.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">struct sk_buff &#123;</div><div class="line">    /*next和prev这两个域链接相关的sk_buff结构，当报文分段时，原始报文的每个分段</div><div class="line">     *通过next域链接在一起。</div><div class="line">     */</div><div class="line">    struct sk_buff *next; //指向下一个分段   </div><div class="line">    struct sk_buff *prev; //指向前一个分段</div><div class="line"></div><div class="line">    //list指针指向该sk_buff当前放置的队列或者列表</div><div class="line">    struct sk_buff_head *list;</div><div class="line">    struct sock *sk; //指向报文（sk_buff）所属套接字的指针</div><div class="line">    struct timeval stamp; //该域记录接收或者传输报文时刻的时间戳</div><div class="line"></div><div class="line">    /* 这是指向设备（struct net_device）的指针，报文通过此设备接收或者发送。</div><div class="line">     * net_device记录网络接口（数据链路层）信息以及该设备的相关操作。</div><div class="line">     */</div><div class="line">    struct net_device *dev;</div><div class="line"></div><div class="line">    /* 这是一个不同传输层头的指针联合，该域指向传输层头在报文中开始的位置 */</div><div class="line">    union &#123;</div><div class="line">        struct tcphdr  *th;</div><div class="line">        struct udphdr  *uh;</div><div class="line">        struct icmphdr *icmph;</div><div class="line">        struct igmphdr *igmph;</div><div class="line">        struct iphdr   *ipiph;</div><div class="line">        struct spxhdr  *spxh;</div><div class="line">        unsigned char  *raw;</div><div class="line">    &#125;h;</div><div class="line"></div><div class="line">    /* 这是一个不同网络层头的指针联合，该域指向网络层头在报文中开始的位置 */</div><div class="line">    union &#123;</div><div class="line">        struct iphdr    *iph;</div><div class="line">        struct ipv6hdr  *ipv6h;</div><div class="line">        struct arphdr   *arph;</div><div class="line">        struct ipxhdr   *ipxh;</div><div class="line">        unsigned char   *raw;</div><div class="line">    &#125;nh;</div><div class="line"></div><div class="line">    /* 这是一个不同MAC层头的指针联合，该域指向MAC层头在报文中开始的位置 */</div><div class="line">    union &#123;</div><div class="line">        struct ethhdr *ethernet;</div><div class="line">        unsigned char *raw;</div><div class="line">    &#125;max;</div><div class="line"></div><div class="line">    /* dst 指向dst_entry结构，该结构记录了到达给定目的地的路由信息，也记录了一</div><div class="line">     *些给定连接相关的网络特征信息，如PMTU、RTT等。</div><div class="line">     */</div><div class="line">    struct dst_entry *dst;</div><div class="line">    /* 该域保存协议相关的控制信息，每个协议层可能独立的使用这些信息。*/</div><div class="line">    char             cb[48];</div><div class="line"></div><div class="line">    unsigned int len; //该域记录sk_buff中数据的总长度</div><div class="line">    unsigned int data_len; //只有当sk_buff中有非线性数据时才使用该域</div><div class="line">    unsigned int csum; //这是某时刻协议的校验和</div><div class="line">    unsigned int char __unused, </div><div class="line">                 cloned, //该域保存当前sk_buff是原始数据还是克隆数据的信息</div><div class="line">                 /* 该域包含报文类型信息。类型通常为多播、广播、回路、主机、其</div><div class="line">                  * 他主机、传出等。</div><div class="line">                  */</div><div class="line">                 pkt_type,</div><div class="line">                 ip_summed; //该域表示驱动是否计算IP校验和</div><div class="line">    __u32 priority; //该域保存报文的排队优先级信息，这基于IP头中的TOS域</div><div class="line">    atomic_t users; //该域保存引用了sk_buff的数量</div><div class="line"></div><div class="line">     /* 该域保存了下一个协议层信息，在处理报文时由当前协议层设置 */</div><div class="line">    unsigned short protocol;</div><div class="line">    unsigned short security; //该域保存报文的安全级别</div><div class="line"></div><div class="line">     /* 该域保存为该缓冲区所分配的总内存。它包括sk_buff结构的大小+分配给该</div><div class="line">      * sk_buff的数据块的大小。</div><div class="line">      */</div><div class="line">    unsigned int truesize;</div><div class="line"></div><div class="line">    /* 该域指向线性数据区的开始（为sk_buff分配的线性数据区的首字节） */</div><div class="line">    unsigned char *head; </div><div class="line">    /* 该域指向驻留在线性数据区的数据的起始位置。驻留在线性数据区中的数据可能并</div><div class="line">     * 不总是从线性数据区的起始head开始。</div><div class="line">     */</div><div class="line">    unsigned char *data;</div><div class="line">    unsigned char *tail; //该域指向驻留在线性数据区的最后一个字节的数据</div><div class="line"></div><div class="line">    /* 该域指向线性数据区的结尾，与tail不同。驻留在线性数据区中的数据结尾并不是</div><div class="line">     * 总是在线性数据区的结尾。利用该域可以确保我们没有使用超出可用存储的缓冲区</div><div class="line">     */</div><div class="line">    unsigned char *end;</div><div class="line">    ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;head、data、end、tail这4个域维护了线性数据区，当为新的sk_buff分配缓冲区时，需要提供线性数据区的大小。同时还要初始化sk_buff的这4个域，以指向线性数据区中合适的位置。下图是当skb_alloc()刚返回时的sk_buff结构：<br><img src="../../../../pictures/TCP/20171226114708.png" alt=""></p>
<h4 id="结构skb-shared-info"><a href="#结构skb-shared-info" class="headerlink" title="结构skb_shared_info"></a>结构skb_shared_info</h4><p>&emsp;&emsp;处于线性数据区结尾的结构，包含sk_buff的分段信息和非线性数据信息。<br>include/linux/skbuff.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct skb_shared_info &#123;</div><div class="line">    atomic_t        dataref; //该域保存skb_shared_info对象的引用次数</div><div class="line"></div><div class="line">     /* 该域保存sk_buff分页段的数目，它表示frags[]</div><div class="line">      * 数组的元素数量，该数组包含sk_buff的分页数据。</div><div class="line">      */</div><div class="line">    unsigned int nr_frags;</div><div class="line"></div><div class="line">    /* 该域是一个指向原始报文（frag_list所属的sk_buff）sk_buffs分段列表的指针。</div><div class="line">     * 如果原始报文需要分段，所有表示这些分配的sk_buffs将链接到该链表中。</div><div class="line">     */ </div><div class="line">    struct sk_buff  *frag_list;</div><div class="line">    /* 该域是分段的数组，这些分段包含sk_buff的分页数据。分页数据由</div><div class="line">    *  skb_frag_struct表示，分页数据（由frags[]表示）的数据长度是每个页段中所含字节数（frags[i]-&gt;size）的总和，并存储在sk_buff的data_len域。</div><div class="line">    */</div><div class="line">    skb_frag_t      frags[MAX_SKB_FRAGS]; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="sk-buff和DMA-skb-frag-struct"><a href="#sk-buff和DMA-skb-frag-struct" class="headerlink" title="sk_buff和DMA-skb_frag_struct"></a>sk_buff和DMA-skb_frag_struct</h4><p>&emsp;&emsp;该结构是一个描述符，描述了包含sk_buff分页数据的每个分页段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct skb_frag_struct &#123;</div><div class="line">    /* 该域是一个指向页结构的指针，页结构包含了分页数据。每个分页段都包含了一页</div><div class="line">     * 所容纳的最大数据。</div><div class="line">     */</div><div class="line">    struct page *page; </div><div class="line">    __u16 page_offset; //该域是页偏移量指针，指向本页数据的起始位置</div><div class="line">    __u16 size; //该域是page域所指页中数据的总长度</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="sk-buff例程操作"><a href="#sk-buff例程操作" class="headerlink" title="sk_buff例程操作"></a>sk_buff例程操作</h4><p>（1） alloc_skb()<br>&emsp;&emsp;该函数分配一个新的sk_buff，该函数的参数为数据区的长度和内存分配的模式。数据区是分配给sk_buff的内存块，报文在这个数据区中构造。当alloc_skb()放回时，head、data、tail和end指针的位置在前面的图中已经给出了。可以看出，内存分配完成后，tail空间等于为sk_buff所请求的数据块的长度，head空间和数据长度则为0。<br>（2） skb_reserve()<br>&emsp;&emsp;该函数会改变sk_buff的head和tail空间，它主要用来为协议头预留空间。当需要为协议头保留空间时，就调用该函数，并向其传递头空间的长度。如下图所示。<br><img src="../../../../pictures/TCP/20171227101518.png" alt=""><br>（3） skb_put()<br>&emsp;&emsp;该例程用来处理sk_buff的线性数据区。该函数为分段数据在线性数据区的结尾预留空间。在大部分情况下，用户数据将在此处理，或者说TCP/UDP载荷在此处复制，它为报文载荷创建空间，如下图所示。<br><img src="../../../../pictures/TCP/20171227102803.png" alt=""><br>下面是skb_put()的源码<br>include/linux/skbuff.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)</div><div class="line">&#123;</div><div class="line">    unsigned char *tmp = skb-&gt;tail; //记录sk_buff的原始tail域</div><div class="line">    SKB_LINEAR_ASSERT(skb);</div><div class="line">    /* tail域加上请求的长度值，修改后的tail域扩展了sk_buff的总长度。</div><div class="line">     * 同样skb-&gt;len也要加上请求的长度值。</div><div class="line">     */</div><div class="line">    skb-&gt;tail += len; </div><div class="line">    skb-&gt;len += len;</div><div class="line">    /* 做完善性检查，以确保tail没有超过线性数据区的结束（skb-&gt;end）*/</div><div class="line">    if (skb-&gt;tail&gt;skb-&gt;end) &#123;</div><div class="line">        skb_over_panic(skb, len, current_text_addr());</div><div class="line">    &#125;</div><div class="line">    return tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（4） skb_push()<br>&emsp;&emsp;该函数处理sk_buff的data域，仅操作线性数据区。它将data域向head推进一个值，该值是以参数传递给该函数的字节数。数据长度增加多少，头空间就减少多少。skb_push()函数的源码如下所示。<br>include/linux/skbuff.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static inline unsigned char *skb_push()</div><div class="line">&#123;</div><div class="line">    skb-&gt;data -= len; //data根据请求的长度减少</div><div class="line">    /* data域向head的推导导致整个sk_buff长度的扩展，sk_buff的长度将增加请求的长</div><div class="line">     * 度。</div><div class="line">     */</div><div class="line">    skb-&gt;len += len;</div><div class="line">    /* 进行完善性检查*/</div><div class="line">    if (skb-&gt;data&lt;skb-&gt;head) &#123;</div><div class="line">        skb_under_panic(skb, len, current_text_addr());</div><div class="line">    &#125;</div><div class="line">    /* 检查通过，将一个数据指针引用放回给调用者。 */</div><div class="line">    return skb-&gt;data;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="../../../../pictures/TCP/20171229115947.png" alt=""><br>&emsp;&emsp;下图给出了调用skb_push()来处理data域的情形。$l_0$是sk_buff的原始长度，其中虚线表示data域指针。$l_r$是调用skb_push()所请求的长度。skb_push()处理完sk_buff后，线性数据区的总长度变为$l<em>r+l</em> 0$，黑线表示数据指针。<br>（5）skb_pull()<br>&emsp;&emsp;这个函数根据字节移动数据指针，字节数则以参数的形式传递给该函数，然后返回新的数据指针。它通过修改sk_buff的data域来处理sk_buff的线性数据区。该函数将skb-&gt;len减小请求的字节数大小，从而增加了sk_buff线性数据区头空间的大小。下面是源代码。<br>include/linux/skbuff.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static inline unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)</div><div class="line">&#123;</div><div class="line">    if (len &gt; skb-&gt;len)</div><div class="line">        return NULL;</div><div class="line">    return __skb_pull(skb, len);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)</div><div class="line">&#123;</div><div class="line">    skb-&gt;len -= len;</div><div class="line">    if (skb-&gt;len &lt; skb-&gt;data_len)</div><div class="line">        out_of_line_bug();</div><div class="line">    return skb-&gt;data += len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在Linux TCP/IP协议栈中，sk_buff是代表网络报文的网络缓冲区。sk_buff有三个构成部分：sk_buff、线性数据缓冲区、分页数据（struct_skb_shared_info）。当请求sk_buff时，需要传递线性数据区域的长度。sk_buff中有一些页分别指向传输层、网络层和链路层头。&lt;br&gt;&amp;emsp;&amp;emsp;这篇博客主要讨论sk_buff结构中的各个域，以及处理sk_buff结构的头、尾、结束、数据以及长度域的函数，将对sk_buff结构的data_len域和处理该域的函数做出说明。还将阐述skb_shared_info结构以及该结构的用途，然后描述了各种与sk_buff复制和排队操作相关的各种函数。&lt;br&gt;&amp;emsp;&amp;emsp;sk_buff包含线性和非线性两部分的数据。线性数据由sk_buff的数据域表示。一般来说，能够在单页中容纳的IP报文才分配一页的线性数据。如果整个IP报文的长度超过了一页的容量，处理该报文就有两个选择。一种是分配一个长度可容纳整个IP报文的先行数据区，另一种是使用分页数据区来容纳报文的剩余部分（线性数据=1页，IP剩余部分则存储在sk_buff的分页数据区中）。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP架构、设计及应用" scheme="http://yoursite.com/categories/TCP-IP%E6%9E%B6%E6%9E%84%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TCP拥塞控制之CUBIC</title>
    <link href="http://yoursite.com/2017/12/21/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8BCUBIC/"/>
    <id>http://yoursite.com/2017/12/21/TCP拥塞控制之CUBIC/</id>
    <published>2017-12-21T12:00:34.000Z</published>
    <updated>2017-12-30T01:06:25.615Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;CUBIC是当前Linux系统上默认的拥塞控制算法。它的拥塞控制窗口增长函数是一个三次函数，这样设计的目的是为了在当前的快速和长距离网络环境中有更好的扩展性。CUBIC的拥塞窗口增长独立于RTT，因此能更好的保证流与流之间的公平性。<br><a id="more"></a></p>
<h3 id="问题是什么"><a href="#问题是什么" class="headerlink" title="问题是什么"></a>问题是什么</h3><p>&emspp;&emsp;当今的因特网朝着速度更快，距离更长的趋势发展，致使针对传统网络设计的TCP算法性能受到了挑战。上面的网络特性用一个专业名词描述叫做高BDP（bandwidth and delay product），它代表了带宽被完全利用时网络中能容纳的数据包总量。<br>&emsp;&emsp;传统的TCP算法，例如TCP-Reno，TCP-NewReno，TCP-SACK等之所以在新环境下不能充分利用网络带宽，主要是因为在进入拥塞避免阶段后，它们的拥塞窗口每经过一个RTT才加1，拥塞窗口的增长速度太慢，当碰上高带宽环境时，可能需要经历很多个RTT，拥塞窗口才能接近于一个BDP。如果数据流很短，可能拥塞窗口还没增长到一个BDP，数据流就已经结束了，这种情况的带宽利用率就会非常低。</p>
<h3 id="已存在的方法"><a href="#已存在的方法" class="headerlink" title="已存在的方法"></a>已存在的方法</h3><p>&emsp;&emsp;为了解决上面提到的TCP低利用率问题，有很新的TCP变体被提出来，例如FAST，HSTCP，STCP，HTCP，SQRT，West-wood和BIC-TCP。这些算法都号称能在很短的时间内提高网络传输速率。在Linux内核2.6.8版本里，BIC-TCP被选为默认算法，其他算法也实施在Linux内核里作为可选项。BIC-TCP相比其他算法的优点是其稳定性。下面就花点篇幅介绍下BIC-TCP算法。</p>
<h4 id="BIC-TCP"><a href="#BIC-TCP" class="headerlink" title="BIC-TCP"></a>BIC-TCP</h4><p>&emsp;&emsp;BIC-TCP采用二分搜索的方式来决定拥塞窗口的增长尺度，首先它会记录拥塞窗口的一个最大值点，这个最大值就是TCP最近一次出现丢包时拥塞窗口的值；还会记录一个最小值点，即在一个RTT周期内没有出现丢包事件时窗口的大小。二分搜索就是取最小值和最大值的中间点，当拥塞窗口增长到这个中间值且没有出现丢包的话，就说明网络还可以容纳更多的数据包。那么将这个中值设为新的最小值，在新的最小值和最大值间搜索中间值。当当前拥塞窗口的值还远没有达到通道的容量时，其增长速度很快；相反，当拥塞窗口的值接近于通道的容量时，其拥塞窗口增长函数是一个简化的对数凹函数。这个凹函数使拥塞窗口在饱和点或平衡点比凸函数或线性函数保持更长的时间，在饱和点处，凹函数和线性函数它们具有最大的窗口增量，因此在丢包发生时会出现大量的数据包被丢失。<br><img src="../../../../pictures/paper read/20171223094737.png" alt=""><br>&emsp;&emsp;BIC-TCP的主要特征是在前面说过的其独特的窗口增长函数，图1给出了BIC-TCP的窗口增长函数。当出现丢包事件时，BIC-TCP通过乘以因子$\beta$来缩小窗口，缩小之前的窗口大小被设置为最大$W_max$，并且缩小之后的窗口大小被设置为最小值$W_min$。 然后，BIC-TCP使用这两个参数执行二分搜索，拥塞窗口的下一个取值会是$W_max$和$W_min$之间的“中点”$W_mid$。<br>&emsp;&emsp;为了防止拥塞窗口从$W_min$增长到$W_mid$的步长$step$太大，BIC-TCP还设置了一个常数$S_max$，当$step$&gt;$S_max$时，BIC-TCP会取下一个增长点为$W_min$+$S_max$而不是$W_mid$，如果没有出现丢包的话，再更新$W_min$，直到$step$&lt;$S_max$为止。与此同时BIC-TCP还设置一个另一个控制参数$S_min$，当窗口增量小于$S_min$时，BIC-TCP会将当前拥塞窗口值设为最大值。<br>&emsp;&emsp;如果窗口增长超过最大值，则说明当前窗口最大值还不是一个饱和点，网络还可以容纳更多的数据包，窗口还有增长的空间，一个新的窗口最大值需要被探索。于是BIC-TCP会进入一个新的阶段，叫做最大值探索阶段。最大探测使用一个与在加法增长和二分搜索阶段（这是对数;其倒数将是指数）完全对称的窗口增长函数。图1中给出了在最大探索阶段期间的窗口增长函数。在最大探测期间，窗口最初缓慢地增长以发现附近新的最大值，经过一段时间的缓慢增长，如果没有找到新的最大值（即，没出现包丢失），则它猜测新的最大值离得很远，所以它给窗口大小增加一个大的固定增量，使用加法增加切换到更快的增加速度。BIC-TCP的良好性能来自$W_max$附近的缓慢增加和在加法增加和最大探测期间的线性增加。</p>
<h3 id="什么是CUBIC"><a href="#什么是CUBIC" class="headerlink" title="什么是CUBIC"></a>什么是CUBIC</h3><p>&emsp;&emsp;CUBIC是BIC-TCP的下一代版本。 它通过用三次函数（包含凹和凸部分）代替BIC-TCP的凹凸窗口生长部分，大大简化了BIC-TCP的窗口调整算法。实际上，任何奇数阶多项式函数都具有这种形状。三次函数的选择是偶然的，并且不方便。CUBIC的关键特征是其窗口增长仅取决于两个连续拥塞事件之间的时间。一个拥塞事件是指出现TCP快速恢复的时间。因此，窗口增长与RTT无关。 这个特性允许CUBIC流在同一个瓶颈中竞争，有相同的窗口大小，而不依赖于它们的RTT，从而获得良好的RTT公平性。而且，当RTT较短时，由于窗口增长率是固定的，其增长速度可能比TCP标准慢。 由于TCP标准（例如，TCP-SACK）在短RTT下工作良好，因此该特征增强了协议的TCP友好性。</p>
<h4 id="CUBIC的窗口增长函数"><a href="#CUBIC的窗口增长函数" class="headerlink" title="CUBIC的窗口增长函数"></a>CUBIC的窗口增长函数</h4><p>&emsp;&emsp;BIC-TCP在高速网络中实现了良好的可扩展性，在自身的竞争流之间是公平的，并且具有低窗口振荡的稳定性。但BIC-TCP的窗口增长函数对于TCP来说还是过于激进，特别是在短RTT或低速网络中。于是有了CUBIC，CUBIC保留了BIC-TCP的稳定性和可扩展性的优点，同时简化了窗口控制和加强了TCP友好性。<br><img src="../../../../pictures/paper read/20171223095005.png" alt=""><br>&emsp;&emsp;CUBIC的窗口增长函数是一个三次函数，非常类似于BIC-TCP的窗口增长函数，CUBIC的函数图像如图2所示。CUBIC的详细运行过程如下，当出现丢包事件时，CUBIC同BIC-TCP一样，会记录这时的拥塞窗口大小作为$W_max$，接着通过因子$\beta$执行拥塞窗口的乘法减小，这里$\beta$是一个窗口降低常数，并进行正常的TCP快速恢复和重传。从快速恢复阶段进入拥塞避免后，使用三次函数的凹轮廓增加窗口。三次函数被设置在$W_max$处达到稳定点，然后使用三次函数的凸轮廓开始探索新的最大窗口，如果新的最大窗口存在的话。<br>&emsp;&emsp;CUBIC的窗口增长函数公式如下所示：<br>$$W(t)=C(t-K)^3+W_max \quad (1)$$<br>这里，C是一个CUBIC的参数，t是从窗口上次降低开始到现在的时间，是一个弹性值，而K是上述函数在没有进一步丢包的情况下将$W$增加到$W_max$经历的时间，其计算公式如下：<br>$$K=\sqrt[3]{\frac{W_max*\beta}{C}} \quad (2)$$<br>在拥塞避免阶段每收到一个ACK，CUBIC都会使用方程（1）计算在下个RTT的窗口增长速率。CUBIC使用$W(t+RTT)$作为拥塞窗口的候选值，假设当前拥塞窗口大小为$cwnd$。根据$cwnd$的值，CUBIC有三种运行模式。首先，如果cwnd小于（标准）TCP在上次丢包事件之后t时刻到达的窗口大小，那么CUBIC处于TCP模式（我们将在下面描述如何根据时间确定标准TCP的窗口大小）。否则，如果$cwnd$小于$W_max$，那么CUBIC在三次函数的凹轮廓区域，如果$cwnd$大于$W_max$，那么，CUBIC处于三次函数的凸轮廓区域。</p>
<h4 id="TCP友好型区域"><a href="#TCP友好型区域" class="headerlink" title="TCP友好型区域"></a>TCP友好型区域</h4><p>&emsp;&emsp;这小节主要说了怎么判断在发生丢包事件后，标准TCP在$t$时刻的窗口大小。</p>
<h4 id="凹区域"><a href="#凹区域" class="headerlink" title="凹区域"></a>凹区域</h4><p>&emsp;&emsp;当在拥塞避免阶段收到一个ACK，如果协议不处于TCP模式，且$cwnd$小于$W_max$，那么，协议就处于凹区域，在这个区域，$cwnd$的增量为<br>$$\frac{W(t+RTT)-cwnd}{cwnd}$$</p>
<h4 id="凸区域"><a href="#凸区域" class="headerlink" title="凸区域"></a>凸区域</h4><p>&emsp;&emsp;如果协议不处于TCP模式，且$cwnd$大于饱和点$W_max$，那么协议处于凸区域，$cwnd$的增量为<br>$$\frac{W(t+RTT)-cwnd}{cwnd}$$<br>其实凸区域的增长函数和凹区域的增长函数一样，只不过凸区域越过了饱和点，而其区域没有越过饱和点。</p>
<h4 id="乘法降低"><a href="#乘法降低" class="headerlink" title="乘法降低"></a>乘法降低</h4><p>&emsp;&emsp;当出现数据包丢失时，CUBIC会通过乘以因子$\beta$来降低拥塞窗口，这里取$\beta=0.2$，设置$\beta$小于0.5的副作用是收敛较慢。虽然更适应性的设置会导致更快的收敛，但是会使协议的分析变得更加困难，并影响协议的稳定性。</p>
<h4 id="快速收敛"><a href="#快速收敛" class="headerlink" title="快速收敛"></a>快速收敛</h4><p>&emsp;&emsp;为了提高CUBIC的收敛速度，在协议中加入了启发式。当新的流量加入网络时，网络中的现有流量需要放弃其带宽份额，以使新流量有一定的增长空间。下面详细描述一下快速收敛的过程。在发生丢包前，CUBIC会记录一个最大窗口值$W_max$，当发生丢包后，在降低窗口前，CUBIC又会记录当前的窗口值作为新的$W_max$，为了不至于混淆，可以将之前记录的$W_max$标记位$W_lastmax$。当发生丢包时，CUBIC会比较$W_lastmax$的$W_max$大小，如果$W_max$小于$W_lastmax$，这表明由于可用带宽的变化，该流所经历的饱和点正在降低。这种情况下，CUBIC的做法是通过进一步的减小$W_max$来释放更多的可用带宽。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;CUBIC是当前Linux系统上默认的拥塞控制算法。它的拥塞控制窗口增长函数是一个三次函数，这样设计的目的是为了在当前的快速和长距离网络环境中有更好的扩展性。CUBIC的拥塞窗口增长独立于RTT，因此能更好的保证流与流之间的公平性。&lt;br&gt;
    
    </summary>
    
      <category term="私人文献阅读" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>I/O复用</title>
    <link href="http://yoursite.com/2017/11/20/I-O%E5%A4%8D%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/20/I-O复用/</id>
    <published>2017-11-20T14:04:08.000Z</published>
    <updated>2017-12-30T01:08:16.786Z</updated>
    
    <content type="html"><![CDATA[<p>在Unix下5种可用的I/O模型：<br>阻塞式I/O；<br>非阻塞式I/O；<br>I/O复用；<br>信号驱动式I/O；<br>异步I/O；<br><a id="more"></a></p>
<h4 id="阻塞式I-O模型"><a href="#阻塞式I-O模型" class="headerlink" title="阻塞式I/O模型"></a>阻塞式I/O模型</h4><p>&emsp;&emsp;阻塞式I/O模型的基本思想是当应用进程调用recvfrom系统调用时，如果内核到用户空间的数据没有准备好，那么进程一直阻塞于recvfrom调用，直到数据从内核复制到用户空间，这时recvfrom返回。<br><img src="../../../../pictures/阻塞式I-O模型.png" alt=""></p>
<h4 id="非阻塞式I-O模型"><a href="#非阻塞式I-O模型" class="headerlink" title="非阻塞式I/O模型"></a>非阻塞式I/O模型</h4><p>&emsp;&emsp;当应用进程调用recvfrom系统调用时，如果内核到用户空间的数据没有准备好，那么recvfrom返回一个EWOULDBLOCK错误。应用进程会不断的调用recvfrom，然后recvfrom不断的返回EWOULDBLOCK，直到内核到用户空间的数据准备好为止，然后recvfrom成功返回。<br>&emsp;&emsp;当一个应用进程对一个非阻塞描述符循环调用recvfrom时，这个过程称之为轮询（polling）。应用进程持续轮询内核，以查看某个操作是否就绪，这么做往往消耗大量CPU时间。<br><img src="../../../../pictures/非阻塞式I-O模型.png" alt=""></p>
<h4 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h4><p>&emsp;&emsp;应用进程阻塞于select调用，等待数据报套接字变为可读，当select返回套接字可读这一条件时，调用recvfrom把所读数据报复制到应用进程缓冲区。<br><img src="../../../../pictures/I-O复用模型.png" alt=""></p>
<h4 id="信号驱动式I-O模型"><a href="#信号驱动式I-O模型" class="headerlink" title="信号驱动式I/O模型"></a>信号驱动式I/O模型</h4><p>&emsp;&emsp;让内核在描述符就绪时发送SIGIO信号通知应用进程，然后调用recvfrom将数据报复制到应用进程缓冲区，这种模型称为信号驱动式I/O模型。无论如何处理SIGIO信号，这种模型的优势在于等待数据包到达期间进程不被阻塞。<br><img src="../../../../pictures/信号驱动式I-O模型.png" alt=""></p>
<h4 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h4><p>&emsp;&emsp;应用进程调用aio<em>read函数(POSIX异步I/O函数以aio</em>或lio_开头)，给内核传递描述符、缓冲区指针、缓冲区大小（与read相同的三个参数）和文件偏移（与lseek类似），并告诉内核当整个操作完成时如何通知应用进程。<br><img src="../../../../pictures/异步I-O模型.png" alt=""></p>
<p>注：该篇博客参考自《UNIX网络编程》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Unix下5种可用的I/O模型：&lt;br&gt;阻塞式I/O；&lt;br&gt;非阻塞式I/O；&lt;br&gt;I/O复用；&lt;br&gt;信号驱动式I/O；&lt;br&gt;异步I/O；&lt;br&gt;
    
    </summary>
    
      <category term="UNIX网络编程" scheme="http://yoursite.com/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>套接字编程简介</title>
    <link href="http://yoursite.com/2017/09/18/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/09/18/套接字编程简介/</id>
    <published>2017-09-18T04:41:16.716Z</published>
    <updated>2017-12-30T01:15:02.607Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文对套接字地址结构，什么是值-结果参数，还有字节排序函数和字节操作函数做了简单的介绍。<br><a id="more"></a></p>
<h4 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h4><p>IPv4套接字地址结构通常也称为“网际套接字地址结构”，下面是其POSIX定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct in_addr &#123;</div><div class="line">    in_addr_t s_addr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct sockaddr_in &#123;</div><div class="line">    uint8_t         sin_len;</div><div class="line">    sa_family_t     sin_family;</div><div class="line">    in_port_t       sin_port;</div><div class="line"></div><div class="line">    struct in_addr  sin_addr;</div><div class="line"></div><div class="line">    char            sin_zero[8];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>1.IPv4地址和TCP或UDP端口号在套接字地址结构中总是以网络字节序来存储；<br>2.sin_zero字段未曾使用，不过在填写这中套接字地址结构时，总是把该字段置为0；<br>3.套接字地址结构仅在给定主机上使用；</p>
<h4 id="值-结果参数"><a href="#值-结果参数" class="headerlink" title="值-结果参数"></a>值-结果参数</h4><p>当往一个套接字函数传递一个套接字地址结构时，该结构总是以引用形式来传递，也就是说传递的是指向该结构的一个指针。<br>（1）从进程到内核传递套接字地址结构的函数有三个：bind、connect、sendto。这些函数的一个参数是指向某个套接字地址结构的指针，另一个参数是该结构的整数大小，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct sockaddr_in serv;</div><div class="line"></div><div class="line">connect(sockfd, (SA *) &amp;serv, sizeof(serv));</div></pre></td></tr></table></figure></p>
<p>（2）从内核到进程传递套接字地址结构的函数有4个：accept、recvfrom、getsockname和getpeername。这4个函数的其中两个参数是指向某个套接字地址结构的指针和指向表示该结构大小的整数变量的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct sockaddr_un cli;</div><div class="line">socklen_t len;</div><div class="line">len = sizeof(cli);</div><div class="line">getpeername(unixfd, (SA *) &amp;cli, &amp;len);</div></pre></td></tr></table></figure></p>
<h4 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h4><p>小端字节序（little-endlian）：将低序字节存储在起始地址；<br>大端字节序（big-endian）：将高序字节存储在起始地址；<br>主机字节序：整数在内存中保存的顺序；<br>网络字节序：是TCP/IP中规定好的一种数据表示格式，他与具体的CPU类型、操作系统等无关，从而保证数据在不同主机之间传输时能够被正确解释。网络字节序采用big-endian。<br><img src="../../../../pictures/UNIX/20170919153411.png" alt=""></p>
<h4 id="字节操纵函数"><a href="#字节操纵函数" class="headerlink" title="字节操纵函数"></a>字节操纵函数</h4><p>操纵多字节字段的函数有两组，一组是名字以b开头的函数起源于4.2BSD几乎所有现今支持套接字函数的系统仍然提供它们；另一组是以mem开头的第二组函数起源于ANSI C标准，支持ANSI C函数库的所有系统都提供它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;strings.h&gt;</div><div class="line">//将目标字节串指定书目的字节置为0</div><div class="line">void bzero(void *dest, size_t nbytes); </div><div class="line"> //将指针syc指向的大小为nbytes的字节赋给指针dest</div><div class="line">void bcopy(const void *syc, void *dest, size_t nbytes);</div><div class="line">//比较大小，若相同返回0，否则返回非0</div><div class="line">int bmcp(const void *ptr1, const void *ptr2, size_t nbytes);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;strings.h&gt;</div><div class="line">//将目标地址大小为len的字节置为值c</div><div class="line">void *memset(void *dest, int c, size_t len);</div><div class="line">//将指针syc指向的大小为nbytes的字节赋给指针dest</div><div class="line">void *memcpy(void *dest, const void *syc, size_t nbytes);</div><div class="line">//比较两个任意的字节串大小，若相同返回0，否则返回非0 </div><div class="line">int memcmp(const void *ptr1, const void *ptr2, size_t nbytes);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本文对套接字地址结构，什么是值-结果参数，还有字节排序函数和字节操作函数做了简单的介绍。&lt;br&gt;
    
    </summary>
    
      <category term="UNIX网络编程" scheme="http://yoursite.com/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>程序的机器级表示</title>
    <link href="http://yoursite.com/2017/09/14/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <id>http://yoursite.com/2017/09/14/程序的机器级表示/</id>
    <published>2017-09-14T01:03:38.000Z</published>
    <updated>2017-09-14T14:27:55.710Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近正在看《深入理解计算机系统》这本书，这本书虽然不是很好懂，但还是想硬着头皮给它看完，顺便做做笔记。<br><a id="more"></a></p>
<h4 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h4><p>&emsp;&emsp;源代码通过编译器编译后生成汇编码（以.s结尾），接下来，汇编器将汇编码转化成二进制目标码（以.o结尾），最后链接器将目标代码文件与实现库函数（如printf）的代码合并，并生成最终的可执行代码文件（没有后缀）。<br><img src="../../../../pictures/Computer System/20170914083600.png" alt=""><br>&emsp;&emsp;计算机系统使用了多种不同形式的抽象，对于机器级编程来说，有两种抽象尤为重要。第一种是机器级程序的格式和行为，定义为指令集体系结构（Instruction set architecture, ISA），它定义了处理器状态、指令的格式，以及每条指令对状态的影响。第二种抽象是，机器级程序的使用的地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。</p>
<h4 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h4><p>&emsp;&emsp;一个IA32中央处理单元（CPU）包含一组8个存储32位值的寄存器。这些寄存器用来存储整数数据和指针。如图2所示<br><img src="../../../../pictures/Computer System/20170914101843.png" alt=""><br>&emsp;&emsp;三种不同的操作数类型，第一种是立即数（immediate），也就是常数值，任何一个能放进一个32位的字里的数值都可以用作立即数。第二种类型是寄存器（register），它表示某个寄存器的内容。第三类操作数是存储器（memory）引用，它会根据计算出来的地址访问某个存储器位置。如图3所示，给出了多种不同的寻址模式。<br><img src="../../../../pictures/Computer System/20140505164651890.png" alt=""></p>
<h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><p>&emsp;&emsp;机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近正在看《深入理解计算机系统》这本书，这本书虽然不是很好懂，但还是想硬着头皮给它看完，顺便做做笔记。&lt;br&gt;
    
    </summary>
    
      <category term="计算机系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Token Flow Control in Data Center Networks解读</title>
    <link href="http://yoursite.com/2017/08/31/TFC/"/>
    <id>http://yoursite.com/2017/08/31/TFC/</id>
    <published>2017-08-31T00:45:22.000Z</published>
    <updated>2017-08-31T13:21:37.656Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Token Flow Control (TFC)是为在数据中心网络中获得高带宽利用率，极低延迟，快速收敛，基本不丢包而提出的一种传输控制机制。<br><a id="more"></a></p>
<h3 id="问题是什么"><a href="#问题是什么" class="headerlink" title="问题是什么"></a>问题是什么</h3><h4 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a>应用需求</h4><p>&emsp;&emsp;现代数据中心网络对服务性能要求一直在增加。比如支持online数据处理的流计算对平均和尾延迟比一些像MapReduce这类的offline处理模式更加敏感；在memcachedsystems中，零包丢失是一个重要的性能刻画尺度，因为丢包后的重传会严重影响网络传输性能。</p>
<h4 id="数据流自身特性"><a href="#数据流自身特性" class="headerlink" title="数据流自身特性"></a>数据流自身特性</h4><p>&emsp;&emsp;某些流的自身特性也导致了网络的低性能，比如short traffic bursts易导致网络拥塞和包丢失，致使flow completion time延长；highly concurrent flow也会带来网络拥塞，当并发高到一定程度，甚至会出现每条流的cwnd小到只有一个数据包这种情况； on-off pattern of flow transmission<br>&emsp;&emsp;不管是新的应用需求还是数据流自身特性对数据中心网路的性能要求都在日益增加。总的来说，就是要做到，fast convergence, zero packet loss, low latency。</p>
<h3 id="为什么这个问题很重要和已有工作"><a href="#为什么这个问题很重要和已有工作" class="headerlink" title="为什么这个问题很重要和已有工作"></a>为什么这个问题很重要和已有工作</h3><h4 id="Fast-Convergence"><a href="#Fast-Convergence" class="headerlink" title="Fast Convergence"></a>Fast Convergence</h4><p>&emsp;&emsp;在数据中心网络中，大约90%的流都是短流，短流一般只有几个数据包，所以为了减少flow completion time，传输协议使流快速的收敛到一个合适的共享带宽就很重要。现有的<strong>TCP及其TCP变体</strong>都是先经过慢启动，然后到达threshold，进入拥塞避免，对这种短流响应太慢，可能这些流还没收敛到公平共享带宽就已经结束了。<br>&emsp;&emsp;还有一个问题是有些流（silent flow）是间歇性的传输数据，在他们不传输数据的这个时间段内，但它们占据着带宽，致使带宽利用不充分。传输协议<strong>$D^{3}$</strong>虽然可以快速的收敛到一个合适的速率，但无法解决这种silent flow问题。</p>
<h4 id="Zero-Packet-Loss"><a href="#Zero-Packet-Loss" class="headerlink" title="Zero Packet Loss"></a>Zero Packet Loss</h4><p>&emsp;&emsp;在大规模数据中心网络中，TCP遭受的问题有TCP Incast, TCP outcast, long query completion time, out-of-order等。Long query completion time and out-of-order就不介绍了，这里解释一下什么是TCP Incast and TCP outcast:<br>&emsp;&emsp;<strong>TCP Incast:</strong> TCP Incast是指多个机器的大量TCP连接集中连接到一个机器，导致压力集中到某一个交换机，交换机的buffer很快用光，然后出现大规模的丢包事件，如图1所示。有兴趣的可以看看专门研究TCP Incast问题的paper。在blog后面会列出相关的paper。<br><img src="../../../../pictures/DCN/20170831103945.png" alt=""><br>&emsp;&emsp;<strong>TCP outcast:</strong> TCP outcast</p>
<h4 id="Low-Latency"><a href="#Low-Latency" class="headerlink" title="Low Latency"></a>Low Latency</h4><p>&emsp;&emsp;高延迟直接对一些云服务提供商的利润造成负面影响，许多云服务商采用分布式实时计算系统，例如Storm，网络时延是计算框架中整个时延的大头。还有一些web services，例如facebook，都要求极低延迟。而在数据中心网络中，round trip delay一般很小，通常在hundred microseonds级别，而queueing delay很大，要比round trip delay高出几个数量级，可以达到hundred milliseconds级别。</p>
<h3 id="TFC的设计"><a href="#TFC的设计" class="headerlink" title="TFC的设计"></a>TFC的设计</h3><p>&emsp;&emsp;在TFC的设计模型中，有两个量很重要，分别是<strong>Token</strong>和<strong>the Number of Effective Flows</strong>：</p>
<blockquote>
<p>Token T[n]. T[n] represents how many data can be transmited by a link in time slot n(n = 0, 1, …). T[n] can be computed as $c*t$, where c is the link bandwidth and t is the duration of a time slot.<br>Number of effective flows E[n]. E[n] stands for the number of full windows of data packets injected by all the passing flows in time slot n.</p>
</blockquote>
<p>之所以要计算有效流数，是因为有些流是间歇性的传输数据，所以间歇期时间要被剔除。还有一点要说明的是，这里的有效流，根据原文的解释，应该是在时间段$t$内，满发送窗口的个数。下面给出了$E[n]$的计算公式；<br>$$E[n] = \sum_{f} \frac{t}{rtt_f} \quad (1)$$<br>表达式（1）中的$t$是指持续时间长度，$rtt_f$表示流f的$rtt$，这样算是因为，一个$rtt$可以发送一个满窗口的数据包。<br>$$W[n+1] = \frac{T[n]}{E[n]} \quad (2)$$<br>知道了满窗口的个数和总共发送了多少数据包，当然就知道了拥塞窗口的大小。<br>下图是一个计算例子：<br><img src="../../../../pictures/DCN/20170831125800.png" alt=""></p>
<h4 id="Measuring-the-Number-of-Effective-Flows"><a href="#Measuring-the-Number-of-Effective-Flows" class="headerlink" title="Measuring the Number of Effective Flows"></a>Measuring the Number of Effective Flows</h4><p>&emsp;&emsp;精确的知道有效流数有以下几个方法。方法一每条流可以在每个回合发送一个额外特殊的数据包，switches只需要测量在时间段$n$内收到的特殊数据包数就可以知道有效流的个数，但这种方法引入的开销太大。方法二在时间段$n$内的有效流数$E[n]$可以通过等式$\frac{A[n]}{W[n-1]}$得到，但是这个$W[n-1]$是上一个时间段得到的，除非bottleneck switch在上一个时间段记录的拥塞窗口值一直到当前都保持不变。<br>&emsp;&emsp;TFC在这里通过在每个回合标记一个数据包来告诉switch有效流数，而不是发送一个额外的数据包。这样，switch只需要数被标记过的数据包就可以知道有效流数了。</p>
<h4 id="Duration-of-a-Time-Slot"><a href="#Duration-of-a-Time-Slot" class="headerlink" title="Duration of a Time Slot"></a>Duration of a Time Slot</h4><p>&emsp;&emsp;理论上这个时间长度可以是任意值但是，在实际环境中，考虑到收敛速度，计算有效流的精确性，还是需要确定一个合适的值。一方面呢，这个值不能太大，如果太大，switchs就不能即时的通过得到的有效流数更新拥塞窗口，以至于无法做到快速收敛。也不能太小，如果太小，这样计数的有效流数就会太小，就会得到一很大的拥塞窗口值，导致不准确。一般选择某条流的$rtt$作为基准，根据经验，在数据中心网络中,流与流之间的$rtt$相差不超过3倍。</p>
<h4 id="Achieving-Rare-Packets-Loss"><a href="#Achieving-Rare-Packets-Loss" class="headerlink" title="Achieving Rare Packets Loss"></a>Achieving Rare Packets Loss</h4><p>&emsp;&emsp;当并发流的数量足够大，即时每条流只发一个数据包，也会出现拥塞，然而这种情形在数据中心网络中还比较普遍。一个比较常见的方法就是改变MSS的大小，这样一来，每个数据包中，包头占的比重就会增加，带宽利用率因此会下降。另外一个方法就是延迟发送时间，每$\frac{MSS}{W}$个$RTT$发送一个数据包。这样的话就需要精确的测量$RTT$，以及一个高分辨率的计时器来计数$\frac{RTT}{W}$,然而采用高分辨率定时器会引入大量的中断，产生额外的负载，如频繁地打乱处理器高速缓存并增加耗电。<br>&emsp;&emsp;每一个switch都有了一个counter来记录还可以发送多少数据包，这个计数器会随着时间而增加。当一个ACK到达时switch时，如果它携带的拥塞窗口小于一个包大小，但是switch的counter记录的可发送的值大于一个数据包，那么，switch会将ACK头部的拥塞窗口值修改为一个数据包大小，然后，counter减1；如果counter小于1，那么这个ACK会被放入到一个delay queue中，等到counter大于1了，再做处理。还有如果ACK通报给sender的拥塞窗口值本身就大于一个数据包，那么ACK会直接被转发，counter减1。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&emsp;&emsp;实施TFC算法呢需要修改数据包头和拥塞控制机制，包头呢，主要是动用了TCP头的保留位中的两位，分别叫做RM(Round MArk)和RMA(Round MArk Acknowledgment)，用来打标记方便switch计算有效流数；对拥塞控制机制的修改已经在前面说过了。<br>&emsp;&emsp;关于RM和RMA的使用，需要提出一点疑问，原文中是这样描述的：</p>
<blockquote>
<p>During the establishment phase, the sender and receiver negotiate<br>whether to use TFC or not. Then at the data transmission<br>phase, the sender sets the RM bit in the TFC header<br>of the first data packet to 1. After receiving a RMA marked<br>packet, the sender sets the RM bit in the TFC header of the<br>next sending data packet to 1.</p>
</blockquote>
<p>想法是挺好的，但是，万一这个带有标记的数据包丢了怎么办，paper没有给出说明。如果丢了，paper中对有效流的计数将无法实现。<br>&emsp;&emsp;要实现TFC的功能，switch需要做三件事，computing tokens, measuring the number of effective flows and updating congestion windows。这些功能都在上面介绍过了，这里就不多说了。实现结构图如下图示：<br><img src="../../../../pictures/DCN/20170831192042.png" alt=""></p>
<p><strong>参考文献：</strong><br><a href="https://nns.cs.tsinghua.edu.cn/paper/eurosys16_jz.pdf" target="_blank" rel="external">TFC: Token Flow Control in Data Center Networks</a><br><a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6203387" target="_blank" rel="external">ICTCP: Incast Congestion Control for TCP in Data-Center Networks</a><br><a href="https://www.usenix.org/system/files/conference/nsdi12/nsdi12-final126.pdf" target="_blank" rel="external">The TCP Outcast Problem: Exposing Unfairness in Data Center Networks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Token Flow Control (TFC)是为在数据中心网络中获得高带宽利用率，极低延迟，快速收敛，基本不丢包而提出的一种传输控制机制。&lt;br&gt;
    
    </summary>
    
      <category term="私人文献阅读" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="DCN" scheme="http://yoursite.com/tags/DCN/"/>
    
  </entry>
  
  <entry>
    <title>iperf和iperf3的问题</title>
    <link href="http://yoursite.com/2017/08/28/iperf%E5%92%8Ciperf3%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/08/28/iperf和iperf3的问题/</id>
    <published>2017-08-28T00:13:08.000Z</published>
    <updated>2017-08-31T00:44:37.712Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近因为实验需要重现在data center networks中的TCP Incast问题，就是many client to one server发包，导致每条流分得的带宽很小，即sender window很小，当出现burst现象时，可能致使某条流整个的window都丢掉，引发timeout问题。<br><a id="more"></a></p>
<h4 id="iperf的问题"><a href="#iperf的问题" class="headerlink" title="iperf的问题"></a>iperf的问题</h4><p>由于服务器数量不够，只能通过测试工具iperf多开一些流，发现iperf开的流数量小于20条时还很正常，但到达30条及以上就会出现一些异常问题，如下图示：<br><img src="../../../../pictures/iperf/webwxgetmsgimg.png" alt=""><br>经分析，这个问题是iperf工具本身的设计bug，所以想到使用iperf3来试一试。</p>
<h4 id="iperf3的问题"><a href="#iperf3的问题" class="headerlink" title="iperf3的问题"></a>iperf3的问题</h4><p>iperf3从下载到安装倒是非常顺利，这里先给出源码下载及安装过程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$wget http://downloads.es.net/pub/iperf/iperf-3.1.3.tar.gz</div><div class="line">$tar zxvf iperf-3.1.3.tar.gz</div><div class="line">$cd iperf-3.1.3</div><div class="line">$./configure --prefix=/usr/local/bin/</div><div class="line">$make</div><div class="line">$make install</div></pre></td></tr></table></figure></p>
<p>但是当我通过iperf3 –version查看是否安装成功时，却出现了问题：<br><strong>问题一</strong><br>由于当时忘记了截图，只好手动复原一下问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iperf3: error while loading shared libraries: libiperf.so.0: cannot open shared object file: No such file or directory</div></pre></td></tr></table></figure></p>
<p>提示当载入共享库Libiperf.so.0时，不能打开共享目标文件，估计是共享库不存在，于是我根据提示进行了调试，解决办法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$echo $LD_LIBRARY_PATH </div><div class="line"></div><div class="line">//如果上面的命令得到的是空，那就进行下面的操作</div><div class="line">$LD_LIBRATY_PATH=/usr/local/lib</div><div class="line">//进行下面这条操作的前提是你的/usr/local/bin/中有libiperf.so.0这个file</div><div class="line">$LD_LIBRARY_PATH=$LD_LIBRATY_PATH:/usr/local/bin/libiperf.so.0</div></pre></td></tr></table></figure></p>
<p>然后再试一试，效果如下：<br><img src="../../../../pictures/iperf/20170828084439.png" alt=""></p>
<p><strong>问题二</strong><br>经过上面的一番折腾，在一个client一个server的情况下，测试了同时开40条流和同时开80条流都很好。我满心欢喜的以为可以大干一场了，于是改为3个client，同时向一个server发包，but，but，Iperf3居然不支持many client to one server的情况，截图如下：<br><img src="../../../../pictures/iperf/20170828085457.png" alt=""><br>iperf都支持many client to one server，why，why，为什么升级版iperf3却不支持，那我的TCP Incast还重现个锤子，哎，只好自己写一个了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近因为实验需要重现在data center networks中的TCP Incast问题，就是many client to one server发包，导致每条流分得的带宽很小，即sender window很小，当出现burst现象时，可能致使某条流整个的window都丢掉，引发timeout问题。&lt;br&gt;
    
    </summary>
    
      <category term="UNIX/LINUX" scheme="http://yoursite.com/categories/UNIX-LINUX/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP重点系列之ACK处理</title>
    <link href="http://yoursite.com/2017/07/19/TCP%E9%87%8D%E7%82%B9%E7%B3%BB%E5%88%97%E4%B9%8BACK%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2017/07/19/TCP重点系列之ACK处理/</id>
    <published>2017-07-19T13:15:25.000Z</published>
    <updated>2017-07-19T02:02:10.886Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇博客介绍sender收到receiver发送过来的ACK后会怎么处理，这里主要介绍收到每一个ACK后的处理流程，后面的博客会具体介绍关于收到SACK后怎么处理，丢包后怎么处理等一系列过程。收到ACK包后都会进入到tcp_ack()函数，所以主要是介绍tcp_ack()函数。<br><a id="more"></a></p>
<h4 id="主要处理函数tcp-ack"><a href="#主要处理函数tcp-ack" class="headerlink" title="主要处理函数tcp_ack()"></a>主要处理函数tcp_ack()</h4><p>&emsp;&emsp;sender收到ACK后，主要是两种情况：一是按序ACK数据包，表明网络正常，这种情况下会走快速路径；另外一种情况是数据包没有被按序ACK，有可能是发生乱序或者丢包了，这种情况下会走慢速路径。下面就来看看源码吧！<br>@kernel version 4.10.13 /net/ipv4/tcp_input.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div></pre></td><td class="code"><pre><div class="line">* This routine deals with incoming acks, but not outgoing ones. */</div><div class="line">static int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)</div><div class="line">&#123;</div><div class="line">    struct inet_connection_sock *icsk = inet_csk(sk);</div><div class="line">    struct tcp_sock *tp = tcp_sk(sk);</div><div class="line">    struct tcp_sacktag_state sack_state;</div><div class="line">    struct rate_sample rs = &#123;.prior_delivered = 0&#125;;</div><div class="line">    u32 prior_snd_una = tp-&gt;snd_una;</div><div class="line">    u32 ack_seq = TCP_SKB_CB(skb)-&gt;seq;</div><div class="line">    u32 ack = TCP_SKB_CB(skb)-&gt;ack_seq;</div><div class="line">    bool is_dupack = false;/* 定义布尔变量，判断是否是dupack */</div><div class="line">    u32 prior_fackets;</div><div class="line">    /* 保存上一次的packets_out值，packets_out表示发送还未确认的包个数 */</div><div class="line">    int prior_packets = tp-&gt;packets_out;</div><div class="line">    u32 delivered = tp-&gt;delivered;</div><div class="line">    u32 lost = tp-&gt;lost; /* 记录丢了多少个数据包 */</div><div class="line">    int acked = 0;  /* 记录ack多少个数据包 */</div><div class="line">    int rexmit = REXMIT_NONE;</div><div class="line">    struct skb_mstamp now;</div><div class="line"></div><div class="line">    sack_state.first_sackt.v64 = 0;</div><div class="line">    sack_state.rate = &amp;rs;</div><div class="line"></div><div class="line">    /* 用于访问写队列的队头 */</div><div class="line">    prefetch(sk-&gt;sk_write_queue.next);</div><div class="line"></div><div class="line">    /* If the ack is older than previous acks</div><div class="line">     * then we can probably ignore it.</div><div class="line">     * 如果ACK的数据包已经被ACK过，表明这是一个旧ACK，忽略即可</div><div class="line">     */</div><div class="line">    if (before(ack, prior_snd_una)) &#123;</div><div class="line">        /* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */</div><div class="line">        if (before(ack, prior_snd_una - tp-&gt;max_window)) &#123;</div><div class="line">            tcp_send_challenge_ack(sk);</div><div class="line">            return -1;</div><div class="line">        &#125;    </div><div class="line">        goto old_ack;</div><div class="line">    &#125;    </div><div class="line"></div><div class="line">    /* If the ack includes data we haven&apos;t sent yet, discard</div><div class="line">     * this segment (RFC793 Section 3.9).</div><div class="line">     * 如果ACK了尚未发送的包，这是一个无效的ACK</div><div class="line">     */</div><div class="line">    if (after(ack, tp-&gt;snd_nxt))</div><div class="line">        goto invalid_ack;</div><div class="line"></div><div class="line">    /* 获取当前时间戳，老版本中没见过，应该是后来打补丁加的 */</div><div class="line">    skb_mstamp_get(&amp;now); </div><div class="line"></div><div class="line">    /* icsk_pending在函数inet_connection_sock.h内的结构体inet_connection_sock&#123;&#125;</div><div class="line">     * 中定义，调度定时器事件（scheduled timer event）。下面列出定时器的标志：</div><div class="line">     * #define ICSK_TIME_RETRANS 1 /* 重传定时器 */</div><div class="line">     * #define ICSK_TIME_DACK 2 /* ack延迟定时器 */</div><div class="line">     * #define ICSK_TIME_PROBEO 3 /* 零窗口探测定时器 */</div><div class="line">     * #define ICSK_TIME_EARLY_RETRANS 4 /* ER延迟定时器 */</div><div class="line">     * #define ICSK_TIME_LOSS_PROBE 5 /* 尾丢失探测（PTO）定时器 */ </div><div class="line">     */</div><div class="line">    if (icsk-&gt;icsk_pending == ICSK_TIME_EARLY_RETRANS ||</div><div class="line">        icsk-&gt;icsk_pending == ICSK_TIME_LOSS_PROBE)</div><div class="line">        tcp_rearm_rto(sk); /* 删除或重启重传定时器 */</div><div class="line"></div><div class="line">    /* ACK了新的数据，打上FLAG_SND_UNA_ADVANCED标记，表明snd_una将向前移动。 */</div><div class="line">    if (after(ack, prior_snd_una)) &#123;</div><div class="line">        flag |= FLAG_SND_UNA_ADVANCED;</div><div class="line">        icsk-&gt;icsk_retransmits = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    prior_fackets = tp-&gt;fackets_out;</div><div class="line">    /* in_flight = packets_out - left_out + retrans_out</div><div class="line">     * left_out = sacked_out + lost_out. </div><div class="line">     * in_fligth表示当前发出还没被ack的包的个数</div><div class="line">     */</div><div class="line">    rs.prior_in_flight = tcp_packets_in_flight(tp); </div><div class="line"></div><div class="line">    /* ts_recent update must be made after we are sure that the packet</div><div class="line">     * is in window.</div><div class="line">     */</div><div class="line">    if (flag &amp; FLAG_UPDATE_TS_RECENT)</div><div class="line">        tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)-&gt;seq);</div><div class="line"></div><div class="line">    /* ACK了新包，不处于SLOWPATH，即处于快速路径， */</div><div class="line">    if (!(flag &amp; FLAG_SLOWPATH) &amp;&amp; after(ack, prior_snd_una)) &#123;</div><div class="line">        /* Window is constant, pure forward advance.</div><div class="line">         * No more checks are required.</div><div class="line">         * Note, we use the fact that SND.UNA&gt;=SND.WL2.</div><div class="line">         */</div><div class="line">        tcp_update_wl(tp, ack_seq);/* 函数内容是tp-&gt;snd_wl1 = ack_seq */</div><div class="line">        tp-&gt;snd_una = ack;/* 更新snd_una */</div><div class="line">        flag |= FLAG_WIN_UPDATE;/* 打上更新标志 */</div><div class="line"></div><div class="line">        tcp_in_ack_event(sk, CA_ACK_WIN_UPDATE);/* 接收窗口被更新了 */</div><div class="line">        /* 这是一个在include/net/ip.h里定义的宏，具体我也不清楚 */</div><div class="line">        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPHPACKS);</div><div class="line">    &#125; else &#123;/* 如果处于SLOWPATH */</div><div class="line">        u32 ack_ev_flags = CA_ACK_SLOWSPATH;//表明有丢包，需要进入慢速处理过程</div><div class="line">        if (ack_seq != TCP_SKB_CB(skb)-&gt;end_seq)/* 此ACK携带了数据 */</div><div class="line">            flag |= FLAG_DATA; /* 打上FLAG_DATA标记 */</div><div class="line">        else</div><div class="line">            NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPPUREACKS);</div><div class="line"></div><div class="line">        /* 一个更新send window的函数，详细更新算法参见RFC793/RFC1122</div><div class="line">         * 如果满足更新条件，会给flag打上FLAG_WIN_UPDATE标记。</div><div class="line">         */</div><div class="line">        flag |= tcp_ack_update_window(sk, skb, ack, ack_seq);</div><div class="line"></div><div class="line">        if (TCP_SKB_CB(skb)-&gt;sacked)/* 如果是一个sack */</div><div class="line">            /* 处理SACK的函数，此函数较复杂，将在blog[]()中详细介绍 */</div><div class="line">            flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una， &amp;sack_state);    </div><div class="line"></div><div class="line">        /* 判断是否拥塞，由路由器在IP头中标记  */</div><div class="line">        if (tcp_enc_rcv_ecn_echo(tp, tcp_hdr(skb))) </div><div class="line">            flag |= FLAG_ECE;/* 显示拥塞标志 */</div><div class="line"></div><div class="line">        tcp_in_ca_event(sk, ack_ev_flags); /* 慢速路径事件钩子 */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* We passed data and got it acked, remove any soft error</div><div class="line">     * log. Something worked...</div><div class="line">     */</div><div class="line">    sk-&gt;sk_err_soft = 0;</div><div class="line">    icsk-&gt;icsk_probes_out = 0;</div><div class="line">    tp-&gt;rcv_tstamp = tcp_time_stamp;</div><div class="line">    if (!prior_packets)</div><div class="line">        goto no_queue;</div><div class="line"></div><div class="line">    /* See if we can take anything off of the retransmit queue. */</div><div class="line">    previous_packets_out = tp-&gt;packets_out;/* 保存清理前的值 */</div><div class="line"></div><div class="line">    /* 清理重传队列中已被确认接收的包，并返回flag标记，此函数会在后面的blog中做详细介绍 */</div><div class="line">    flag |= tcp_clean_rtx_queue(sk, prior_fackets, prior_snd_una， &amp;acked, &amp;sack_state, &amp;now);</div><div class="line"></div><div class="line">     /* 判断此ACK是否可疑，可疑的条件会在下面说明 */</div><div class="line">    if (tcp_ack_is_dubious(sk, flag)) &#123;</div><div class="line">        /* 根据flag判断是否dupack，整个条件是说snd_una没有更新，</div><div class="line">         * 且是一个duplicate ack 。</div><div class="line">         */</div><div class="line">        is_dupack = !(flag &amp; (FLAG_SND_UNA_ADVANCED | FLAG_NOT_DUP));</div><div class="line">        /* 如果判断有丢包，就进行快速重传 */</div><div class="line">        tcp_fastretrans_alerk(sk, acked, is_dupack, &amp;flag, &amp;rexmit);</div><div class="line">    &#125;</div><div class="line">    if (tp-&gt;tlp_high_seq)</div><div class="line">        tcp_process_tlp_ack(sk, ack, flag);</div><div class="line"></div><div class="line">    if (flag &amp; FLAG_FORWARD_PROGRCESS || !(flag &amp; FLAG_NOT_DUP)) &#123;</div><div class="line">        struct dst_entry *dst = __sk_dst_get(sk);</div><div class="line">        if (dst)</div><div class="line">            dst_confirm(dst);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (icsk-&gt;icsk_pending == ICSK_TIME_RETRANS)</div><div class="line">        tcp_schedule_loss_prode(sk);</div><div class="line">    delivered = tp-&gt;delivered - delivered;</div><div class="line">    lost = tp-&gt;lost - lost;</div><div class="line">    tcp_rate_gen(sk, delivered, lost, &amp;now, &amp;rs);</div><div class="line">    tcp_cong_control(sk, ack, delivered, flag, &amp;rs);</div><div class="line">    tcp_xmit_recorery(sk, rexmit);</div><div class="line">    return 1;</div><div class="line"></div><div class="line">no_queue:</div><div class="line">    /* If data was DSACKed, see if we can undo a cwnd reduction. */</div><div class="line">    if (flag &amp; FLAG_DSACKING_ACK)</div><div class="line">        tcp_fastretrans_alert(sk, acked, is_dupack, &amp;flag, &amp;rexmit);</div><div class="line">    /* If this ack opens up a zero window, clear backoff.  It was</div><div class="line">     * being used to time the probes, and is probably far higher than</div><div class="line">     * it needs to be for normal retransmission.</div><div class="line">     */</div><div class="line">    if (tcp_send_head(sk))</div><div class="line">        tcp_ack_probe(sk);</div><div class="line"></div><div class="line">    if (tp-&gt;tlp_high_seq)</div><div class="line">        tcp_process_tlp_ack(sk, ack, flag);</div><div class="line">    return 1;</div><div class="line">/* 下面分别是对无效ACK和旧ACK的处理，就不做过多介绍。 */</div><div class="line">invalid_ack:</div><div class="line">    SOCK_DEBUG(sk, &quot;Ack %u after %u:%u\n&quot;, ack, tp-&gt;snd_una, tp-&gt;snd_nxt);</div><div class="line">    return -1;</div><div class="line"></div><div class="line">old_ack:</div><div class="line">    /* If data was SACKed, tag it and see if we should send more data.</div><div class="line">     * If data was DSACKed, see if we can undo a cwnd reduction.</div><div class="line">     */</div><div class="line">    if (TCP_SKB_CB(skb)-&gt;sacked) &#123;</div><div class="line">        flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una);</div><div class="line">        tcp_fastretrans_alert(sk, acked, is_dupack, &amp;flag, &amp;rexmit);</div><div class="line">        tcp_xmit_recovery(sk, rexmit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SOCK_DEBUG(sk, &quot;Ack %u before %u:%u\n&quot;, ack, tp-&gt;snd_una, tp-&gt;snd_nxt);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="部分相关函数"><a href="#部分相关函数" class="headerlink" title="部分相关函数"></a>部分相关函数</h4><p>&emsp;&emsp;这里给出部分在tcp_ack()调用到的比较重要的函数，还有一些会在以后的博客中介绍。<br>获取当前时间戳<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static inline void skb_mstamp_get(struct skb_mstamp *cl)</div><div class="line">&#123;</div><div class="line">    u64 val = local_clock();</div><div class="line"></div><div class="line">    do_div(val, NSEC_PER_USEC); /* 单位换算 */</div><div class="line">    cl-&gt;stamp_us = (u32)val;</div><div class="line">    cl-&gt;stamp_jiffies = (u32)jiffies;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>枚举变量<br>/<em> Information about inbound ACK, passed to cong_ops-&gt;in_ack_event() </em>/<br>enum tcp_ca_ack_event_flags {<br>    CA_ACK_SLOWSPATH  = (1&lt;&lt;0),    /<em> In slow path processing </em>/<br>    CA_ACK_WIN_UPDATE = (1&lt;&lt;0),    /<em> ACK updated window </em>/<br>    CA_ACK_ECE        = (1&lt;&lt;2),    /<em> ECE bit is set on ack </em>/<br>};</p>
<p>封装调用函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static inline void tcp_in_ack_event(struct sock *sk, u32 flags)</div><div class="line">&#123;</div><div class="line">    const struct inet_connection_sock *icsk = inet_csk(sk);</div><div class="line"></div><div class="line">    if (icsk-&gt;icsk_ca_ops-&gt;in_ack_event)</div><div class="line">        /* in_ack_event()函数的声明在include/net/tcp.h文件内的结构体tcp_congestion_ops &#123;&#125;中 */</div><div class="line">        icsk-&gt;icsk_ca_ops-&gt;in_ack_event(sk, flags); </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇博客介绍sender收到receiver发送过来的ACK后会怎么处理，这里主要介绍收到每一个ACK后的处理流程，后面的博客会具体介绍关于收到SACK后怎么处理，丢包后怎么处理等一系列过程。收到ACK包后都会进入到tcp_ack()函数，所以主要是介绍tcp_ack()函数。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP拥塞控制之：BBR</title>
    <link href="http://yoursite.com/2017/05/25/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8BBBR/"/>
    <id>http://yoursite.com/2017/05/25/TCP拥塞控制之BBR/</id>
    <published>2017-05-25T06:49:05.000Z</published>
    <updated>2017-07-19T12:32:06.008Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;BBR是Google在2016年提出的一种拥塞控制算法，在Linux kernel@4.9及以后的版本中已添加该算法。在Google通过paper将BBR公布前，BBR算法应该在Google自家World Area Network中早已投入使用。Google后来提出基于SDN的B4网络（paper叫做B4，很有名的一篇paper），其拥塞控制算法也是使用的BBR。<br><a id="more"></a><br>&emsp;&emsp;丢包即拥塞的思想已经沿用了很多年，很多拥塞控制算法也是基于此的，比如当前Linux kernel的默认拥塞控制算法CUBIC，还有Reno和FAST TCP等，都是基于这一思想进行的拥塞控制。在技术受限的年代，这一思想（丢包即拥塞）没有错，但是，现在，当NIC（network interface controllers）的处理能力从Mbps升级到Gpbs，memory chips从KB升级到GB，拥塞和丢包的关系就没那么紧密了。<br>&emsp;&emsp;在现在high BDP网络环境下，丢包即拥塞思想带来的问题包括：当因为bottelneck buffers满而出现丢包时，会引起bufferbloat现象，网络延迟高；但是，当bottleneck buffers很小时，这时出现丢包，网络会误认为是发生了拥塞，从而降低发送窗口，这样就会造成low throughput。想要解决上面的问题，那么就需要抛弃基于丢包的拥塞控制思想，换个新的。</p>
<p><img src="../../../../pictures/paper read/20170525154759.png" alt=""><br>&emsp;&emsp;上图其实是两个图，只不过有共同的横坐标，想当初弱智的我看了半天，才明白这是两个图。图中的一些符号解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RTprop = round-trip propagation</div><div class="line">BtlBw = bottleneck bandwidth</div><div class="line">blue lines show the RTprop constraint;</div><div class="line">green lines show the BtlBw constraint;</div><div class="line">red lines show the bottleneck buffer;</div></pre></td></tr></table></figure></p>
<p>基于丢包的拥塞控制如图中指出的那样，其作用域在bandwidth limited，这时bottleneck buffers慢慢被填满，最后导致buffer溢出，出现丢包。在早前，memory价格较贵时，buffer sizes约等于一个link BDP，现在由于技术的进步，memory价格一直下降，buffer sizes越来越大，都快高出link BDP一个数量级。这样，delay也由以前的milliseconds升到了seconds，自然也带来了bufferbloat（缓冲区爆满，排队延迟影响网络整体性能）。其实之前有paper专门针对bottelneck buffer设置为多大给出了其研究结果，等于一个link BDP是最好的。</p>
<h3 id="Characterizing-the-bottleneck"><a href="#Characterizing-the-bottleneck" class="headerlink" title="Characterizing the bottleneck"></a>Characterizing the bottleneck</h3><p>&emsp;&emsp;要达到highest throughput和lowest delay，connection必须同时满足两个条件：</p>
<blockquote>
<ol>
<li>the bottleneck packet arrival rate equals BtlBw;</li>
<li>the total data in flight is equal to the BDP(BtlBw*Rtprop);</li>
</ol>
</blockquote>
<p>第一个条件保证bottelneck被100%的利用，第二个条件防止bottleneck出现饥饿，但又不会溢出。<br>&emsp;&emsp;因为$BtlBw$和$PTprop$在整个过程中一直是变动的，所以需要一直不断的测量。在任何时刻$t$，<br>$$RTT_t = RTprop_t + \eta_t$$<br>这里$\eta&gt;=0$表示‘noise’，比如接收端的延迟ack策略，ack aggregation策略等。因此$RTprop$是不可能准确测量的，只能估算，像大多数算法测量最小$RTT$做的那样：<br>$$\hat{RT}prop = RTprop + min(\eta_t) = min(RTT_t)$$<br>&emsp;&emsp;根据从receiver返回的ack，我们可以知道当前ack确认数据包的$RTT$和离开sender留存在网络中的确切数据包数。因为我们可以准确知道当前的发送序号snd_nxt，以及其确认序号snd_una，如果开启了SACK也可以准确知道，只不过需要walk一遍SACK段。这样我们便可以测量平均delivery rate:$deliveryRate = \Delta delivered/\Delta t$。在这个过程中delivered是可以准确知道的，而$\Delta t$则会大于真实interval，因为受网络噪声的影响，所以$delivery rate &lt;= bottleneck rate$，那么我们可以这样评估BtlBw:<br>$$\hat{BtlBw} = max(deliveryRate_t)$$</p>
<h3 id="MATCHING-THE-PACKET-FLOW-TO-THE-DELIVERY-PATH"><a href="#MATCHING-THE-PACKET-FLOW-TO-THE-DELIVERY-PATH" class="headerlink" title="MATCHING THE PACKET FLOW TO THE DELIVERY PATH"></a>MATCHING THE PACKET FLOW TO THE DELIVERY PATH</h3><p>The core BBR algorithm has two parts:</p>
<h4 id="When-an-ack-is-received"><a href="#When-an-ack-is-received" class="headerlink" title="When an ack is received"></a>When an ack is received</h4><p>&emsp;&emsp;每一个ack都会提供一个新的RTT和delivery rate值，用来更新$RTprop$和$BtlBw$，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function onAck(packet)</div><div class="line">    rtt = now - packet.sendtime</div><div class="line">    update_min_filter(RTpropFilter, rtt)</div><div class="line">    delivery_time = now</div><div class="line">    deliveryRate = (delivered - packet.delivered)/(now - packet.delivered_time)</div><div class="line">    if (deliveryRate &gt; BtlBwFilter.curentMax || !packet.app_limited)</div><div class="line">        update_max_filter(BtlBwFilter, deliveryRate)</div><div class="line">    if (app_limited_until &gt; 0)</div><div class="line">        app_limited_until -= packet.size</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在数据传输过程中，senders可能成为application limited，也就是application有机会发送更多的数据，但是没有数据可以发送，这是一个很普遍的现象。</p>
<h4 id="When-data-is-sent"><a href="#When-data-is-sent" class="headerlink" title="When data is sent"></a>When data is sent</h4><p>&emsp;&emsp;为了使packet-arrival rate和bottleneck link’s departure rate相匹配，BBR必须paces每一个数据包。pacing_rate是BBR的主要控制参数，另外一个参数是cwnd_gain，用来限定inflight为小倍数的BDP，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function send(packet)</div><div class="line">    bdp = BtlBwFilter.currentMax*RTpropFilter.currentMin</div><div class="line">    if (inflight &gt;= cwnd_gain*bdp)</div><div class="line">        //wait for ack or timeout</div><div class="line">        return</div><div class="line">    if (now &gt;= nextSendTime)</div><div class="line">        packet = nextPacketToSend()</div><div class="line">        if (!packet)</div><div class="line">            app_limited_until = inflight</div><div class="line">            return</div><div class="line">        packet.app_limited = (app_limited_until &gt; 0)</div><div class="line">        packet.sendtime = now</div><div class="line">        packet.delivered = delivered</div><div class="line">        packet.delivered_time = delivered_time</div><div class="line">        ship(packet)</div><div class="line">        nextSendTime = now + packet.size/(pacing_gain * BtlBwFilter.currentMax)</div><div class="line">    timerCallbackAt(send, nextSendTime)</div></pre></td></tr></table></figure></p>
<h4 id="Steady-state-behavior"><a href="#Steady-state-behavior" class="headerlink" title="Steady-state behavior"></a>Steady-state behavior</h4><p>&emsp;&emsp;由上面可知，测量$BtlBw$和$RTprop$都有独立的函数去完成，在bottleneck的约束下会形成一个控制循环，那么带来的效果如下图所示：<br><img src="../../../../pictures/paper read/20170620164658.png" alt=""><br>图中蓝线是RTT， 绿线是inflight，红线代表delivery rate，delivery rate上方的粗灰线表示BtlBw max filter的状态。<br>&emsp;&emsp;BBR通过保证inflight大多数时候为一个BDP来最小化delay。这样bottleneck就被转移到了sender，因为sender看不到BtlBw的变化，因此BBR需要周期性的通过pacing_gain &gt; 1来测量BtlBw是否变化，当发现形成queueing delay时， 将pacing_gain设为小于1便可消除queueing delay。<br>&emsp;&emsp;BBR除了探测网络带宽是否变化外，还会周期性的探测往返传播延迟（RTProp），因为要考虑到传输路径等一些其他能影响到传播延迟的因素。每收到一个ack都会更新RTProp，但当RTProp有一段时间（比如10s）没更新了，BBR便会进入探测RTT模式，其探测方式主要是通过将inflight减少为4个数据包（比如设置cwnd=4），这种状态维持至少一个往返延迟，然后回到探测前的状态。需要注意的是并不是只对一条数据流这样设置来探测，而是所有的数据流一起进入探测模式。</p>
<h3 id="BBR自己的状态机"><a href="#BBR自己的状态机" class="headerlink" title="BBR自己的状态机"></a>BBR自己的状态机</h3><p>首先给出其状态切换图<br><img src="../../../../pictures/state/20170719170709.png" alt=""><br>&emsp;&emsp;google的BBR是一种对丢包不敏感的拥塞控制算法，理论上它是不care外部的TCP拥塞状态（loss, recovery）的，它只根据自己测量的即时rate来调整cwnd的大小，即BBR只负责发送多少数据包，至于发哪些数据包它不管。而传统的拥塞控制算法，当碰到丢包时，网络便交给了快速恢复算法（比如PRR）接管，拥塞控制算法是不能插足的，直到重传结束返回到open状态。所以当网络丢包率比较大的时候，网络可能一直处于重传阶段，而CUBIC可能就短暂的接管过网络，之后一直是PRR接管，造成带宽利用率低下。<br>&emsp;&emsp;BBR自己的状态机的PROBE_RTT保证即时探测min rtt，从而保证网络的低延迟；而PROBE_BW保证即时探测网络带宽变化，从而保证充分利用带宽；DRAIN保证STARTUP结束时带来的queueing delay即时被排空。<br>&emsp;&emsp;还有一点需要注意的是BBR没有ssthresh，因为根据计算的delivery rate就可以大致推断sender的发送速率是否达到网络带宽上限。</p>
<p><strong>总结</strong><br>&emsp;&emsp;其实BBR的思想和CUBIC相比很简单，其最终的效果据google自己说很好。本人在自己搭建的环境中，在同样的参数下，对比过CUBIC和BBR，快速恢复算法都使用的PRR，BBR明显的比CUBIC要好。但没有实际跑过和vegas、westwood等传统的拥塞控制算法做对比。不过各类拥塞控制算法都有其适用环境，具体看需求。</p>
<p><strong>参考文献：</strong><br><a href="http://delivery.acm.org/10.1145/3030000/3022184/p50-vanjacobson.pdf?ip=159.226.43.30&amp;id=3022184&amp;acc=OPEN&amp;key=33E289E220520BFB%2ED25FD1BB8C28ADF7%2E4D4702B0C3E38B35%2E6D218144511F3437&amp;CFID=950630525&amp;CFTOKEN=77242094&amp;__acm__=1497963804_1df76caeda50f66015a40a5651745817" target="_blank" rel="external">BBR Congestion-Based Congestion Control</a><br><a href="http://an.kaist.ac.kr/courses/2009/cs540/papers/Nick.pdf" target="_blank" rel="external">Sizing Router Buffers</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;BBR是Google在2016年提出的一种拥塞控制算法，在Linux kernel@4.9及以后的版本中已添加该算法。在Google通过paper将BBR公布前，BBR算法应该在Google自家World Area Network中早已投入使用。Google后来提出基于SDN的B4网络（paper叫做B4，很有名的一篇paper），其拥塞控制算法也是使用的BBR。&lt;br&gt;
    
    </summary>
    
      <category term="私人文献阅读" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP拥塞控制之：FAST TCP</title>
    <link href="http://yoursite.com/2017/05/18/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8BFASTTCP/"/>
    <id>http://yoursite.com/2017/05/18/TCP拥塞控制之FASTTCP/</id>
    <published>2017-05-18T11:11:52.000Z</published>
    <updated>2017-05-22T01:46:18.005Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;经典的TCP拥塞控制算法TCP Reno从被提出后很长一段时间一直作为Linux kernel的默认算法，但随着Internet在规模、传输速度、负载、连接数上的增长，TCP Reno迟早会成为性能瓶颈。<br><a id="more"></a></p>
<h3 id="问题与背景"><a href="#问题与背景" class="headerlink" title="问题与背景"></a>问题与背景</h3><p>&emsp;&emsp;当前的Linux kernel的默认拥塞控制算法是于2008年提出的CUBIC，本文介绍的FAST TCP算法于2004年被提出，主要针对高速和长延迟网络，虽然有点老，但还是可以了解了解的。原文主要是和TCP Reno作比较，所以提出的问题也是针对TCP Reno的（时代所限制，如果是现在提出的算法多半是要和CUBIC作比较的）。</p>
<h4 id="TCP-Reno的问题"><a href="#TCP-Reno的问题" class="headerlink" title="TCP Reno的问题"></a>TCP Reno的问题</h4><p>&emsp;&emsp;TCP Reno在large bandwidth-delay products网络上表现差主要体现在以下四个方面（摘自原文）：</p>
<blockquote>
<ol>
<li>At the packet level, linear increase by one packet per Pound-Trip Time(RTT) is too slow, and multiplicative decrease per loss event is too drastic.</li>
<li>At teh flow level, maintaining large average congestion windows requires an extremely small equilibrium loss probability.</li>
<li>At the packet level, oscillation is unavoidable because TCP uses a binary congestion sigmal(packet loss).</li>
<li>At the flow level, the dynamics is unstable leading to severe oscillations that can only be reduced by the accurate estimation of packet loss probability and a stable design of the flow dynamics.</li>
</ol>
</blockquote>
<p>&emsp;&emsp;在前人的工作中有很多算法是基于丢包检测提出的，比如HSTCP和STCP，而FAST TCP是通过测量queueing delay来作为网络拥塞程度的参考。</p>
<h4 id="flow-level和packet-level的区别"><a href="#flow-level和packet-level的区别" class="headerlink" title="flow level和packet level的区别"></a>flow level和packet level的区别</h4><p>&emsp;&emsp;一个拥塞控制算法可以从两个level(flow level and packet level)去设计。flow level相比于packet level是一个宏观上的概念，其设计目标是达到高带宽利用率、低排队延迟和丢包、公平和稳定。而packet level是通过端到端控制的约束来设计实施那些flow level的目标。</p>
<h3 id="FAST-TCP的设计"><a href="#FAST-TCP的设计" class="headerlink" title="FAST TCP的设计"></a>FAST TCP的设计</h3><p>&emsp;&emsp;在说FAST TCP的设计之前先来看一个方程；<br>$$\check{w}_i(t) = \kappa_i(t)(1 - \frac{p_i(t)}{u_i(t)})\label{eq.Sample}$$<br>方程（1）可以用来描述各种已知的TCP拥塞控制算法，不同的拥塞控制算法的区别在于它们对gain function$\kappa_i$和marginal utility function$u_i$以及congestion measures $p_i$是丢失率还是排队延迟。<br>&emsp;&emsp;当然啦，FAST TCP与其他的拥塞控制算法的区别也是在那三个函数的选择上。下面对这三个函数的作用简单介绍下（还是摘自原文，翻译真的很麻烦）。</p>
<blockquote>
<p><strong>$\kappa_i$:</strong> the choice of the gain function $\kappa_i$ determines the dynamic properties sush as stability and responsiveness, but does not affect the equilibrium properties.<br><strong>$u_i$:</strong> the choice of the marginal utility function $u_i$ mainly determines equilibrium properties such as the equilibrium rate allocation and its fairness.<br><strong>$p_i$:</strong> in the absence of explicit feedback, the choice of congestion measure $p_i$ is limited to loss probability or queueing delay. The dynamics of $p_i(t)$ is determined at links.</p>
</blockquote>
<h4 id="implementation-strategy"><a href="#implementation-strategy" class="headerlink" title="implementation strategy"></a>implementation strategy</h4><p>&emsp;&emsp;FAST TCP 通过适当的flow and packet level 设计来解决上文提到的TCP Reno 在large windows环境下所遇到的四个问题。<br>&emsp;&emsp;首先，评估当前状态$\frac{p_i(t)}{u_i(t)}$距equilibrium（值为1）有多远，如果当前状态接近于equilibrium，那么就缓慢调整window，反之，则激进一点调整。而在TCP Reno中，其窗口调整取决于当前窗口大小。基于delay的方法避免了在TCP Reno中window缓慢增长，迅速下降的问题。<br>&emsp;&emsp;其次，选择一个multi-bit 的拥塞测试，消除由于binary feedback造成的packet level oscillation。这里binary feedback表示window要么增，要么降，没有其他选择。<br>&emsp;&emsp;最后，拥塞测量函数$p_i(t)$采用测量queueing delay而不是测量loss probability，通过调整window从而控制queueing delay可以使网络稳定在overflowing point的下方区域，如下图（b）中的F点。这样既消除了高queueing<br>delay，又避免了不必要的数据包丢失。更重要的是，这样还保留了root for buffering “mice” traffic。<br><img src="../../../../pictures/TCP/20170519171625.png" alt=""></p>
<h3 id="FAST-TCP的架构和算法"><a href="#FAST-TCP的架构和算法" class="headerlink" title="FAST TCP的架构和算法"></a>FAST TCP的架构和算法</h3><p>&emsp;&emsp;在FAST TCP这篇paper中， 将TCP拥塞控制机制分割成了四部分，这四部分功能相互独立，以便能够设计分离和异步升级。如下图所示，FAST TCP的架构。<br><img src="../../../../pictures/TCP/20170520104134.png" alt=""><br>&emsp;&emsp;其中，data control 部分决定发送那些数据包，window contorl部分决定可以发多少数据包，burstiness control决定什么时候发送这些数据包，上述决定都是在estimation部分提供的信息的基础上做出的。这里只说一下estimation和window control。</p>
<h4 id="Estimation"><a href="#Estimation" class="headerlink" title="Estimation"></a>Estimation</h4><p>&emsp;&emsp;对于每一个被发送的数据包，estimation部分计算两类反馈信息。当收到一个正常的ACK，计算出相应数据包的RTT，更新平均queueing delay和最小RTT。当收到一个乱序ACK（三个dupack或者timeout），estimation会将数据包的丢失信息报告给其他部分。estimation既可以进行multi-bit的queueing delay采样，也可以进行ont-bit的loss-or-no-loss采样。<br>最后得到的RTT一般都会采用加权移动平均处理，FAST TCP也不例外，$T_i(k)$表示第k个RTT的样本值，$\overline{T}_i(k)$，平均RTT的更新公式如下：<br>$$\overline{T}_i(k+1) = (1 - \eta)\overline{T}_i(k) + \etaT_i(k)$$<br>这里，$t_k$表示收到第k个RTT样本值的时间，$\eta$为加权值。记$d_i(k)$为到目前为止的最小RTT，那么平均queueing delay的计算公式如下：<br>$$\hat{q}_i(k) = \overline{T}_i(k) - d_i(k)$$</p>
<h4 id="Window-control"><a href="#Window-control" class="headerlink" title="Window control"></a>Window control</h4><p>&emsp;&emsp;window control会根据estimation提供的拥塞信息（queueing delay and packet loss）来决定拥塞窗口的调整。FAST TCP不同于传统TCP的关键在于其对拥塞窗口的计算与sender state是独立的。<br>&emsp;&emsp;在正常情况下，根据estimation提供的平均RTT和平均queueing delay，FAST TCP会周期性的更新其拥塞窗口$CWnd$。 更新公式如下：<br>$$w &lt;— min\lbrace2w, (1-\gamma)w + \gamma(\frac{baseRTT}{RTT}w + \alpha(w, qdelay))\rbrace$$<br>这里，$\gamma\in(0, ]$，qdelay是端到端的平均queueing delay。</p>
<p>&emsp;&emsp;这篇博客只是对原文基本思想的表述，还有许多细节问题没有提到，有兴趣的朋友可以考虑看看原文，原文地址在博客的参考文献中给出。</p>
<p><strong>参考文献</strong><br><a href="http://infocom2004.ieee-infocom.org/Papers/52_2.PDF" target="_blank" rel="external">FAST TCP: Motivation, Architecture, Algorithms, Performance</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;经典的TCP拥塞控制算法TCP Reno从被提出后很长一段时间一直作为Linux kernel的默认算法，但随着Internet在规模、传输速度、负载、连接数上的增长，TCP Reno迟早会成为性能瓶颈。&lt;br&gt;
    
    </summary>
    
      <category term="私人文献阅读" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
</feed>
