<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凡是过去 皆为序曲</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-16T02:04:33.678Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git基本操作</title>
    <link href="http://yoursite.com/2018/07/08/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/07/08/git基本操作/</id>
    <published>2018-07-08T01:29:41.000Z</published>
    <updated>2018-07-16T02:04:33.678Z</updated>
    
    <content type="html"><![CDATA[<p>这里主要介绍一些基本的git用法，关于git的使用网上有很多教程。<br><a id="more"></a></p>
<h3 id="创建本地git版本库"><a href="#创建本地git版本库" class="headerlink" title="创建本地git版本库"></a>创建本地git版本库</h3><p>建立本地git仓库有两种方法，一种方法是init一个新仓库，另外一种方法从远程仓库clone。<br><strong>git init</strong>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir learngit</div><div class="line">cd learngit</div><div class="line">git init</div></pre></td></tr></table></figure></p>
<p>经过git init后就得到了一个新仓库。<br><strong>git clone</strong>方法<br>使用git clone的前提是得有一个远程git库，可以是github或者其他服务器上的git仓库。下面是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/Allen-kevin/kernel-backup.git</div></pre></td></tr></table></figure></p>
<h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p><strong>git status:</strong><br>当修改了某些文件或文件夹时，可以使用git status查看仓库当前的状态，下面是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git status</div><div class="line"># On branch master</div><div class="line">#</div><div class="line"># Initial commit</div><div class="line">#</div><div class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</div></pre></td></tr></table></figure></p>
<p>因为在上一步中clone下来的是一个空的git库，而且还没有任何操作，所以git status命令查看不到任何修改信息，下面向这个仓库中添加两个文件夹和一个文件后，然后再使用git status命令查看当前状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">git status</div><div class="line"># On branch master</div><div class="line">#</div><div class="line"># Initial commit</div><div class="line">#</div><div class="line"># Untracked files:</div><div class="line">#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</div><div class="line">#</div><div class="line">#   3.10.25.5/</div><div class="line">#   3.10.25/</div><div class="line">#   READ</div></pre></td></tr></table></figure></p>
<p>然后使用再做一点改变，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">git add READ</div><div class="line">git status</div><div class="line"># On branch master</div><div class="line">#</div><div class="line"># Initial commit</div><div class="line">#</div><div class="line"># Changes to be committed:</div><div class="line">#   (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</div><div class="line">#</div><div class="line">#   new file:   READ</div><div class="line">#</div><div class="line"># Untracked files:</div><div class="line">#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</div><div class="line">#</div><div class="line">#   3.10.25.5/</div><div class="line">#   3.10.25/</div></pre></td></tr></table></figure></p>
<p><strong>git diff:</strong><br>当想要查看具体的修改内容时，可以使用git diff，下面通过echo向READ文件中写了一个字符串，然后使用git diff，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">echo &quot;kernel version&quot; &gt; READ </div><div class="line">git diff</div><div class="line">diff --git a/READ b/READ</div><div class="line">index 2158f09..f589bfd 100644</div><div class="line">--- a/READ</div><div class="line">+++ b/READ</div><div class="line">@@ -1 +1 @@</div><div class="line">-kerne version control</div><div class="line">+kernel version</div></pre></td></tr></table></figure></p>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>如果提交了多个版本，可以使用git log查看每次提交都做了些什么修改，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">git add READ</div><div class="line">git commit -m &quot;kernel version&quot;</div><div class="line">...</div><div class="line">git add READ</div><div class="line">git commit -m &quot;append wwk&quot;</div><div class="line">git log</div><div class="line">commit 583e1bf0164cec1f7be11d1135489613f0ee0df0</div><div class="line">Author: username &lt;username@xxx&gt;</div><div class="line">Date:   Sun Jul 8 12:14:53 2018 +0800</div><div class="line"></div><div class="line">    append wwk</div><div class="line"></div><div class="line">commit 8c9b3a04eade50e4322cbf603ff291560372b3fa</div><div class="line">Author: username &lt;username@xxx&gt;</div><div class="line">Date:   Sun Jul 8 12:11:59 2018 +0800</div><div class="line"></div><div class="line">    kernel version</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> commit后面的字符串583e1bf0164cec1f7be11d1135489613f0ee0df0是commit_id，在后面的版本回退和撤销操作中会用到。<br>在Git中，用HEAD表示当前版本，也就是最新的提交，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。<br>现在，我们要把当前版本append wwk回退到上一个版本kernel version，就可以使用git reset命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git reset --hard HEAD^</div><div class="line">HEAD is now at 8c9b3a0 kernel version</div><div class="line">git log</div><div class="line">commit 8c9b3a04eade50e4322cbf603ff291560372b3fa</div><div class="line">Author: username &lt;username@xxx&gt;</div><div class="line">Date:   Sun Jul 8 12:11:59 2018 +0800</div><div class="line"></div><div class="line">    kernel version</div></pre></td></tr></table></figure></p>
<h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p>在本地的仓库叫做工作区，也就是kernel-backup文件夹，在kernel-backup里面有一个影藏目录.git，这个.git就是版本库。<br><img src="../../../../pictures/UNIX/20180708154229.png" alt=""></p>
<h4 id="撤销git操作"><a href="#撤销git操作" class="headerlink" title="撤销git操作"></a>撤销git操作</h4><p>如果修改了文件READ，但是还没有使用git add READ将文件添加到暂存区，这时如果想撤销对文件READ的修改，可以使用git checkout – READ命令。假如已经使用了git add将READ添加到了暂存区，这时要撤销修改的话，可以先使用git reset HEAD READ，将READ从暂存区重新放回工作区，然后再使用git checkout – READ来进行撤销修改。</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="创建和切换分支"><a href="#创建和切换分支" class="headerlink" title="创建和切换分支"></a>创建和切换分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git branch dev</div><div class="line">git checkout dev</div><div class="line">Switched to branch &apos;dev&apos;</div><div class="line">git branch  //查看所有分支</div><div class="line">* dev  //*表示当前所在分支</div><div class="line">  master</div></pre></td></tr></table></figure>
<p>也可以将上面两天命令合并，git checkout -b dev命令表示创建并切换到分支dev，下面的图1表示只有master的情形，图2表示创建了dev分支并切换到dev分支，图3表示在分支dev上开发的情形，图4表示合并dev分支到master的情形。<br><img src="../../../../pictures/git/20180709083204.png" alt=""></p>
<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>合并分支使用命令git merge，假如要将dev分支合并到当前master分支，然后删除dev分支，代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout master //切换回master分支，让HEAD指向master</div><div class="line">git merge dev //合并到HEAD指向的分支</div><div class="line">git branch -d dev //删除dev分支</div></pre></td></tr></table></figure></p>
<h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><p>在clone远程仓库后，本地仓库相当于是远程仓库的镜像，git会自动把本地的master和远程的master分支对应起来，多人协作时，最好都在自己的分支上开发，所以这里要创建远程origin的dev分支到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout -b dev origin/dev //创建远程origin的dev分支到本地</div><div class="line">...</div><div class="line">git push origin dev //把dev分支push到远程</div></pre></td></tr></table></figure></p>
<p>这时当有另外一个人也在向远程的dev分支push时，可能会报错，因为远程库因为上一个人的push已经更新了，示例如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git push origin dev //把dev分支push到远程</div><div class="line">...</div><div class="line">error: failed to push some refs to &apos;git@github.com:XXX/XXX.git&apos;</div><div class="line">hint: Updates were rejected because the tip of your current branch is behind</div><div class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</div><div class="line">hint: &apos;git pull ...&apos;) before pushing again.</div><div class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</div></pre></td></tr></table></figure></p>
<p>如果出现了上面这种情况，就需要git pull命令救场了，git pull会把最新的提交从origin/dev抓下来，然后在本地合并。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git pull</div><div class="line">git push origin dev</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里主要介绍一些基本的git用法，关于git的使用网上有很多教程。&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>网络协议栈的初始化（三）</title>
    <link href="http://yoursite.com/2018/04/10/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/10/网络协议栈的初始化（三）/</id>
    <published>2018-04-10T10:29:10.000Z</published>
    <updated>2018-04-11T07:47:18.631Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在上一篇博客介绍了do_initcall_level()函数依次取出函数指针数组initcall_levels[]中所有的函数指针，并对这些函数指针所指向的函数进行初始化。但还没说初始化的是什么函数，下面就说说初始化函数本身。<br><a id="more"></a><br>&emsp;&emsp;网络协议栈的初始化是有先后顺序的，数组initcall_levels[]中元素的先后顺序代表了初始化函数的优先级。下面通过图明确给出初始化的先后顺序，优先级1表示会最先被调用，图中标有红框的是本次要介绍的内容。<br><img src="../../../../pictures/UNIX/20180411152429.png" alt=""></p>
<h4 id="sock-init"><a href="#sock-init" class="headerlink" title="sock_init()"></a>sock_init()</h4><p>&emsp;&emsp;最先要说的是sock_init(void)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /net/socket.c</div><div class="line">static int __init sock_init(void)</div><div class="line">&#123;</div><div class="line">    int err;</div><div class="line"></div><div class="line">    /* 对网络内核参数和命名空间子系统进行初始化 */</div><div class="line">    err = net_sysctl_init();</div><div class="line">    if (err)</div><div class="line">        goto out;</div><div class="line"></div><div class="line">    /* Initialize skbuff SLAB cache. */</div><div class="line">    skb_init();</div><div class="line"></div><div class="line">    /* Initialize the protocols module. */</div><div class="line">    init_inodecache();</div><div class="line"></div><div class="line">    /* 将socket类型的文件系统注册到内核中，sock_fs_type是一个文件类型指针 */</div><div class="line">    err = register_filesystem(&amp;sock_fs_type);</div><div class="line">    if (err)</div><div class="line">        goto out_fs;</div><div class="line">    /* 将socket类型的文件系统挂载到sock_mnt上 */</div><div class="line">    sock_mnt = kern_mount(&amp;sock_fs_type);</div><div class="line">    if (IS_ERR(sock_mnt)) &#123;</div><div class="line">        err = PTR_ERR(sock_mnt);</div><div class="line">        goto out_mount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* The real protocol initialization is perform in later initcalls. */</div><div class="line">#ifdef CONFIG_NETFILTER</div><div class="line">    err = netfilter_init();</div><div class="line">    if (err)</div><div class="line">        goto out;</div><div class="line">#endif</div><div class="line"></div><div class="line">#ifdef CONFIG_NETWORK_PHY_TIMESTAMPING</div><div class="line">    skb_timestamping_init();</div><div class="line">#endif</div><div class="line"></div><div class="line">out:   </div><div class="line">    return err;</div><div class="line"></div><div class="line">out_mount:</div><div class="line">    unregister_filesystem(&amp;sock_fs_type);</div><div class="line">out_fs:</div><div class="line">    goto out;</div><div class="line">&#125;</div><div class="line">core_initcall(sock_init); //该函数在初始化时被调用</div></pre></td></tr></table></figure></p>
<h4 id="net-sysclt-init"><a href="#net-sysclt-init" class="headerlink" title="net_sysclt_init()"></a>net_sysclt_init()</h4><p>&emsp;&emsp;为方便后面的理解，这里先给出一个ctl_table结构体介绍，这个结构体是用于注册内核参数的，内核参数的具体注册方法参考博客<a href="https://allen-kevin.github.io/2017/01/15/Linux%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/" target="_blank" rel="external">Linux系统内核参数的添加方法</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /net/sysctl.h</div><div class="line">struct ctl_table &#123;</div><div class="line">    const char *procname;</div><div class="line">    void *data; //表示对应于内核中的变量名称</div><div class="line">    int maxlen; //表示允许的最大长度</div><div class="line">    umode_t mode; //访问权限</div><div class="line">    struct ctl_table *child; //一般为NULL</div><div class="line">    proc_headler *proc_header; //回调函数</div><div class="line">    struct ctl_table_poll *poll;</div><div class="line">    void *extra1;</div><div class="line">    void *extra2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@kernel version 4.10.13 /net/sysctl_net.c</div><div class="line">__init int net_sysclt_init(void)</div><div class="line">&#123;</div><div class="line">    //empty是只有一个元素的结构体数组</div><div class="line">    static struct ctl_table empyt[1];</div><div class="line">    int ret = -ENOMEM;</div><div class="line"></div><div class="line">    /* register_sysctl表示向内核注册一个内核参数表，&quot;net&quot;表示内核参数表所在目录</div><div class="line">     * 的路径，其实真正路径为&quot;/proc/sys/net&quot;。</div><div class="line">     */</div><div class="line">    net_header = register_sysctl(&quot;net&quot;, empty);</div><div class="line">    /* 注册成功返回表头指针，注册失败返回NULL。*/</div><div class="line">    if (!net_header)</div><div class="line">        goto out;</div><div class="line">    /* 注册一个网络命名空间子系统 */</div><div class="line">    ret = register_pernet_subsys(&amp;sysctl_pernet_ops);</div><div class="line">    if (ret)</div><div class="line">        goto out;</div><div class="line">    /* 是一个空函数 */</div><div class="line">    register_sysctl_root(&amp;net_sysctl_root);</div><div class="line">out:</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="skb-init"><a href="#skb-init" class="headerlink" title="skb_init()"></a>skb_init()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /include/linux/skbuff.h</div><div class="line">struct sk_buff_fclone &#123;</div><div class="line">    struct sk_buff skb1;</div><div class="line">    struct sk_buff skb2;</div><div class="line"></div><div class="line">    stomic_t       fclone_ref;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@kernel version 4.10.13 /net/core/skubff.c</div><div class="line">void __init skb_init(void)</div><div class="line">&#123;</div><div class="line">    /* 创建skbuff_head_cache高速缓存，大小为一个sk_buff，一般情况下，SKB都从该</div><div class="line">     * 高速缓存中分配。</div><div class="line">     */</div><div class="line">    skbuff_head_cache = kmem_cache_create(&quot;skbuff_head_cache&quot;,</div><div class="line">                                          sizeof(struct sk_buff),</div><div class="line">                                          0,</div><div class="line">                                          SLAB_HWCACHE_ALIGN|SLAN_PANIC,</div><div class="line">                                          NULL);</div><div class="line">    /* 创建sk_buff_fclone高速缓存，大小为2*sizeof(sk_buff)+sizeof(atomic_t) */</div><div class="line">    skbuff_fclone_cache = kmem_cache_create(&quot;skbuff_fclone_cache&quot;,</div><div class="line">                                          sizeof(struct sk_buff_fclone),</div><div class="line">                                          0,</div><div class="line">                                          SLAB_HWCACHE_ALIGN|SLAN_PANIC,</div><div class="line">                                          NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="init-inodecache"><a href="#init-inodecache" class="headerlink" title="init_inodecache()"></a>init_inodecache()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /include/net/sock.h</div><div class="line">struct socket_alloc &#123;</div><div class="line">    struct socket socket;</div><div class="line">    struct inode vfs_inode;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@kernel version 4.10.13 /net/socket.c</div><div class="line">static int init_inodecache(void)</div><div class="line">&#123;</div><div class="line">    /* sock_inode_cache是一个缓冲池，节点socket_alloc把socket和inode节点绑定在</div><div class="line">     * 一起。</div><div class="line">     */</div><div class="line">    sock_inode_cache = kmem_cache_create(&quot;sock_inode_cache&quot;,</div><div class="line">                                         sizeof(struct socket_alloc),</div><div class="line">                                         0,</div><div class="line">                                         (SLAB_HWCACHE_ALIGN |</div><div class="line">                                          SLAB_RECLAIM_ACCOUNT |</div><div class="line">                                          SLAB_MEM_SPREAD | SLAB_ACCOUNT),</div><div class="line">                                         init_once);</div><div class="line"></div><div class="line">    if (sock_inode_cachep == NULL)</div><div class="line">        return -INOMEM;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="register-filesystem"><a href="#register-filesystem" class="headerlink" title="register_filesystem()"></a>register_filesystem()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /fs/filesystems.c </div><div class="line">/* 查找名字为name，长度为len，类型为file_system_type的文件 */</div><div class="line">static struct file_system_type **find_filesystem(const char *name, unsigned len)</div><div class="line">&#123;</div><div class="line">    struct file_system_type **p;</div><div class="line">    for (p = &amp;file_systems; *p; p = &amp;(*p)-&gt;next)</div><div class="line">        if (strncmp((*p)-&gt;name, name, len) == 0 &amp;&amp; !(*p)-&gt;name[len])</div><div class="line">            break;</div><div class="line">    return p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@kernel version 4.10.13 /fs/filesystems.c</div><div class="line">int register_filesystem(struct file_system_type *fs)</div><div class="line">&#123;</div><div class="line">    int res = 0;</div><div class="line">    //p为指向file_system_type类型指针的指针</div><div class="line">    struct file_system_type **p;</div><div class="line"></div><div class="line">    BUG_ON(strchr(fs-&gt;name, &apos;.&apos;));</div><div class="line">    if (fs-&gt;next)</div><div class="line">        return -EBUSY;</div><div class="line">    /* 加上文件系统锁 */</div><div class="line">    write_lock(&amp;file_system_lock);</div><div class="line">    /* 在内核寻找名字为name的文件系统，如果不存在相同名字的文件系统，就把fs加入</div><div class="line">     * 到系统的文件系统链表里，如果已经存在，则返回忙。</div><div class="line">     */</div><div class="line">    p = find_filesystem(fs-&gt;name, strlen(fs-&gt;name));</div><div class="line">    if (*p)</div><div class="line">        res = -EBUSY;</div><div class="line">    else</div><div class="line">        *p = fs;</div><div class="line"></div><div class="line">    write_unlock(&amp;file_system_lock); //释放锁</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>总结</strong><br>&emsp;&emsp;主要介绍了套接字初始化函数sock_init()的实现细节，比如注册内核参数、创建高速缓存、注册socket类型的文件和挂载文件系统。还有些细节没有介绍到，一是知识有限，二是限于篇幅。下一篇博客会介绍<a href="https://allen-kevin.github.io/2018/04/08/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89/" target="_blank" rel="external">套接字的注册</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在上一篇博客介绍了do_initcall_level()函数依次取出函数指针数组initcall_levels[]中所有的函数指针，并对这些函数指针所指向的函数进行初始化。但还没说初始化的是什么函数，下面就说说初始化函数本身。&lt;br&gt;
    
    </summary>
    
      <category term="UNIX网络编程" scheme="http://yoursite.com/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="协议栈" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>网络协议栈的初始化（二）</title>
    <link href="http://yoursite.com/2018/04/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/09/网络协议栈的初始化（二）/</id>
    <published>2018-04-09T11:43:18.000Z</published>
    <updated>2018-04-11T00:56:36.705Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在上一篇博客中对Linux kernel的初始化流程做了一个基本的介绍，没涉及到细节。从这篇博客开始说网络协议栈初始化的细节。在每段源码的链接会在最后给出。<br><a id="more"></a><br>&emsp;&emsp;do_basic_setup()函数是网络协议栈初始化的入口函数，在函数do_basic_setup()里面有七个初始化函数，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /init/main.c</div><div class="line">/* Ok, the machine is now initialized, None of the devices have been touched </div><div class="line"> * yet, but the CPU subsystem is up and running, and memory and process </div><div class="line"> * management works.</div><div class="line"> */</div><div class="line">static void __init do_basic_setup(void)</div><div class="line">&#123;</div><div class="line">    /* 针对SMP系统，初始化内核control group的cpuset子系统，如果不是smp系统，</div><div class="line">     * 此函数为空。</div><div class="line">     */</div><div class="line">    cpuset_init_smp();</div><div class="line">    shmem_init();//目前还不知道</div><div class="line">    /* 初始化驱动模型中的各个子系统，driver_init()调用后，可以发现</div><div class="line">     * /sys目录下会生成一些目录和文件。</div><div class="line">     */</div><div class="line">    driver_init();</div><div class="line">    /* 在/proc目录下创建irq目录，并在其中初始化系统中所有中断对应的目录 */</div><div class="line">    init_irq_proc();</div><div class="line">    /* 调用链接到内核中的所有构造函数，也就是链接在.ctors段中的所有函数 */</div><div class="line">    do_ctors();</div><div class="line">    usermodehelper_enable();</div><div class="line">    /* 调用所有编译内核的驱动模块中的初始化函数*/</div><div class="line">    do_initcalls();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /init/main.c</div><div class="line">static void __init do_initcalls(void)</div><div class="line">&#123;</div><div class="line">    int level;</div><div class="line"></div><div class="line">    /* ARRAY_SIZE是一个宏，initcall_levels是一个initcall_t类型的数组，这里ARRAY</div><div class="line">     * _SIZE(initcall_levels)就是计算数组initcall_levels中元素的个数。level代表</div><div class="line">     * 数组initcall_levels中元素的下标，同时也代表了初始化的优先级。ARRAY_SIZE</div><div class="line">     * 和initcall_levels[]会在下面介绍。</div><div class="line">     */</div><div class="line">    for (level = 0; level &lt; ARRAY_SIZE(initcall_levels)-1; level++)</div><div class="line">        do_initcall_level(level);// 根据优先级初始化</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __init do_initcall_level(int level)</div><div class="line">&#123;</div><div class="line">    initcall_t *fn;</div><div class="line"></div><div class="line">    /* saved_command_line用于存放解析前的完整内核参数 */</div><div class="line">    strcpy(initcall_command_line, saved_command_line);</div><div class="line">    /* parse_args遍历initcall_command_line，按照空格切割获取参数 */</div><div class="line">    parse_args(initcall_level_names[level],</div><div class="line">            initcall_comand_line, __start__parm,</div><div class="line">            __stop__parm - __start__parm,</div><div class="line">            level, level,</div><div class="line">            NULL, &amp;repair_env_string);</div><div class="line"></div><div class="line">    /* 依次取出所有函数指针，并调用这些函数指针所指向的函数进行初始化，具体过程</div><div class="line">     * 看完后面的宏定义说明就会明白。</div><div class="line">     */</div><div class="line">    for (fn = initcall_levels[level]; fn &lt; initcall_levels[level+1]; fn++)</div><div class="line">        do_one_initcall(*fn);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int __init_or_module do_one_initcall(initcall_t fn)</div><div class="line">&#123;</div><div class="line">    int count = preempt_count();</div><div class="line">    int ret;</div><div class="line">    char msgbuf[64];</div><div class="line"></div><div class="line">    if (initcall_blacklisted(fn))</div><div class="line">        return -EPERM;</div><div class="line"></div><div class="line">    if (initcall_debug)</div><div class="line">        ret = do_one_initcall_debug(fn);</div><div class="line">    else</div><div class="line">        ret = fn();</div><div class="line"></div><div class="line">    msgbuf[0] = 0;</div><div class="line"></div><div class="line">    if (preempt_count() != count) &#123;</div><div class="line">        sprintf(msgbuf, &quot;preemption imbalance &quot;);</div><div class="line">        preempt_count_set(count);</div><div class="line">    &#125;</div><div class="line">    if (irqs_disabled()) &#123;</div><div class="line">        strlcat(msgbuf, &quot;disabled interrupts &quot;, sizeof(msgbuf));</div><div class="line">        local_irq_enable();</div><div class="line">    &#125;</div><div class="line">    WARN(msgbuf[0], &quot;initcall %pF returned with %s\n&quot;, fn, msgbuf);</div><div class="line"></div><div class="line">    add_latent_entropy();</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /include/linux/init.h</div><div class="line">/* 这个宏定义的作用在很多博客中都有介绍，这里还是重复一下。</div><div class="line"> * 假设fn = sock_init，id = 1（编译时会将##替换成后面的字符），那么可以理解为</div><div class="line"> * 将函数指针__initcall_sock_init_1初始化为fn，并放置到名称为.initcall1.init</div><div class="line"> * 的section中。</div><div class="line"> */</div><div class="line">#define __define_initcall(fn, id)                                 \</div><div class="line">        static initcall_t __initcall_##fn##id __used              \</div><div class="line">        __attribute__((__section__(&quot;.initcall&quot;#id&quot;.init&quot;))) = fn;</div><div class="line"></div><div class="line">#define core_initcall(fn)                __define_initcall(fn,1)</div><div class="line">#define core_initcall_sync(fn)           __define_initcall(fn,1s)</div><div class="line">#define postcore_initcall(fn)            __define_initcall(fn, 2)</div><div class="line">#define postcore_initcall_sync(fn)       __define_initcall(fn, 2s)</div><div class="line">#define arch_initcall(fn)                __define_initcall(fn, 3)</div><div class="line">#define arch_initcall_sync(fn)           __define_initcall(fn, 3s)</div><div class="line">#define subsys_initcall(fn)              __define_initcall(fn, 4)</div><div class="line">#define subsys_initcall_sync(fn)         __define_initcall(fn, 4s)</div><div class="line">#define fs_initcall(fn)                  __define_initcall(fn, 5)</div><div class="line">#define fs_initcall_sync(fn)             __define_initcall(fn, 5s)</div><div class="line">#define rootfs_initcall(fn)              __define_initcall(fn, rootfs)</div><div class="line">#define device_initcall(fn)              __define_initcall(fn, 6)</div><div class="line">#define device_initcall_sync(fn)         __define_initcall(fn, 6s)</div><div class="line">#define late_initcall(fn)                __define_initcall(fn, 7)</div><div class="line">#define late_initcall_sync(fn)           __define_initcall(fn, 7s)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /arch/mips/boot/tools/relocs.h</div><div class="line">#define ARRAY_SIZE (sizeof(x)/sizeof((x)[0]))</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /init/main.c</div><div class="line">/* 函数指针__initcall&quot;##id&quot;_start和__initcall&quot;##id&quot;.init的对应关系在后面的宏</div><div class="line"> * INIT_CALLS_LEVEL(level)中说明。</div><div class="line"> */</div><div class="line">static initcall_t *initcall_levels[] __initdata = &#123;</div><div class="line">    __initcall0_start,</div><div class="line">    __initcall1_start,</div><div class="line">    __initcall2_start,</div><div class="line">    __initcall3_start,</div><div class="line">    __initcall4_start,</div><div class="line">    __initcall5_start,</div><div class="line">    __initcall6_start,</div><div class="line">    __initcall7_start,</div><div class="line">    __initcall_end,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static char *initcall_level_names[] __initdata = &#123;</div><div class="line">    &quot;early&quot;,</div><div class="line">    &quot;core&quot;,</div><div class="line">    &quot;postcore&quot;,</div><div class="line">    &quot;arch&quot;,</div><div class="line">    &quot;subsys&quot;,</div><div class="line">    &quot;fs&quot;,</div><div class="line">    &quot;device&quot;,</div><div class="line">    &quot;late&quot;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /include/asm-generic/vmlinux.lds.h</div><div class="line">/* 一直到这里之前，函数指针数组initcall_levels[]中的元素都没有赋值，宏</div><div class="line"> * INIT_CALLS_LEVEL(level)的作用就是将函数指针__initcall##level##_start指向</div><div class="line"> * section中的.initcall##level##.init。这样在do_initcall_level()</div><div class="line"> * 中遍历函数指针数组initcall_levels[]时就可以调用函数指针指向的函数了。</div><div class="line"> */</div><div class="line">#define INIT_CALLS_LEVEL(level)                         \           </div><div class="line">        VMLINUX_SYMBOL(__initcall##level##_start) = .;  \  </div><div class="line">        KEEP(*(.initcall##level##.init))                \</div><div class="line">        KEEP(*(.initcall##level##s.init))</div><div class="line"></div><div class="line">#define INIT_CALLS                                      \</div><div class="line">        VMLINUX_SYMBOL(__initcall_start) = .;           \</div><div class="line">        KEEP(*(.initcallearly.init))                    \</div><div class="line">        INIT_CALLS_LEVEL(0)                             \</div><div class="line">        INIT_CALLS_LEVEL(1)                             \</div><div class="line">        INIT_CALLS_LEVEL(2)                             \</div><div class="line">        INIT_CALLS_LEVEL(3)                             \</div><div class="line">        INIT_CALLS_LEVEL(4)                             \</div><div class="line">        INIT_CALLS_LEVEL(5)                             \</div><div class="line">        INIT_CALLS_LEVEL(rootfs)                        \</div><div class="line">        INIT_CALLS_LEVEL(6)                             \</div><div class="line">        INIT_CALLS_LEVEL(7)                             \</div><div class="line">        VMLINUX_SYMBOL(__initcall_end) = .;</div></pre></td></tr></table></figure>
<p><strong>总结</strong><br>&emsp;&emsp;do_basic_setup()作为网络协议栈初始化的入口，在函数体内调用了7个初始化函数，本文主要关注了最后一个函数do_initcalls()，在函数do_initcalls()内又调用了函数do_initcall_level()，真正的初始化是在do_initcall_level()内完成的。在最后还介绍了一系列的宏，这些宏定义在初始化过程中扮演了重要角色。</p>
<p><strong>参考文献</strong><br>（1）<a href="https://elixir.bootlin.com/linux/v4.10.13/source/init/main.c#L873" target="_blank" rel="external">源码main.c链接</a><br>（2）<a href="https://elixir.bootlin.com/linux/v4.10.13/source/arch/mips/boot/tools/relocs.h#L31" target="_blank" rel="external">源码relocs.h链接</a><br>（3）<a href="https://elixir.bootlin.com/linux/v4.10.13/source/include/linux/init.h#L182" target="_blank" rel="external">源码vmlinux.lds.h链接</a><br>（4）<a href="https://elixir.bootlin.com/linux/v4.10.13/source/include/linux/init.h#L182" target="_blank" rel="external">源码init.h链接</a><br>（5）<a href="https://blog.csdn.net/scotthuang1989/article/details/44157741" target="_blank" rel="external">各种initcall的执行顺序： module_init subsys_initcall ….</a><br>（6）<a href="https://danielmaker.github.io/blog/linux/start_kernel.html" target="_blank" rel="external">核心的進入點: start_kernel()</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在上一篇博客中对Linux kernel的初始化流程做了一个基本的介绍，没涉及到细节。从这篇博客开始说网络协议栈初始化的细节。在每段源码的链接会在最后给出。&lt;br&gt;
    
    </summary>
    
      <category term="UNIX网络编程" scheme="http://yoursite.com/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="协议栈" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>网络协议栈的初始化（一）</title>
    <link href="http://yoursite.com/2018/04/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/09/网络协议栈的初始化（一）/</id>
    <published>2018-04-09T02:48:54.000Z</published>
    <updated>2018-04-10T10:17:22.047Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;一直说自己是搞网络的，但突然发现自己在这一块有好多空白区，以前一直将关注点放在TCP上。但对于一名合格的网络编程人员来说，这似乎太局限了，所以想从整体上去认识一下网络协议栈的工作过程。想了一下，打算先从网络协议栈的初始化过程开始，打开源码一看，阿西吧，代码量有点大啊。<br><a id="more"></a><br>&emsp;&emsp;网络协议栈的初始化要从/init/main.c文件里的start_kernel()函数开始说起，在这个函数里初始化了很多东西，基本上OS最核心的基础设施都在这里面进行了初始化，在函数的最后调用了函数rest_init()。在rest_init()又调用了kernel_init()函数。kernel_init()主要进行系统层级的初始化工作，这个函数主要是将一些系统周边及软件中间层挂进OS及初始化，它的大部分工作都由do_basic_setup()完成。下面的图1是调用流程图。<br><img src="../../../../pictures/UNIX/20180409180128.png" alt=""><br>&emsp;&emsp;经过上面一系列的初始化，还有网络设备没有涉及到，但CPU子系统已启动并运行，并且内存和进程管理都正常工作。由于我们的关注点是网络协议栈的初始化，而不是整个内核的初始化，所以上面都只是简要的介绍了下。下面就要开始表演真正的技术了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;一直说自己是搞网络的，但突然发现自己在这一块有好多空白区，以前一直将关注点放在TCP上。但对于一名合格的网络编程人员来说，这似乎太局限了，所以想从整体上去认识一下网络协议栈的工作过程。想了一下，打算先从网络协议栈的初始化过程开始，打开源码一看，阿西吧，代码量有点大啊。&lt;br&gt;
    
    </summary>
    
      <category term="UNIX网络编程" scheme="http://yoursite.com/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="协议栈" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>网络协议的初始化（四）</title>
    <link href="http://yoursite.com/2018/04/08/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/08/网络协议栈的初始化（四）/</id>
    <published>2018-04-08T06:31:03.000Z</published>
    <updated>2018-04-11T07:31:44.883Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;应用程序在使用套接字（socket）的时候，其实这个套接字已经进行了注册和初始化，那到底是怎么一个过程呢。可能从事应用开发的人员并不关心这些，只需要会用就行。而像我这种搞网络的，还是得要了解的。<br><a id="more"></a><br>&emsp;&emsp;在这里先对几个相关的头文件做个简单介绍， 然后在细说各相关函数。<br>&emsp;&emsp;在/inlcude/linux/net.h文件的开头一段话。简单来说就是和网络层相关的东西基本都会在这个头文件里声明。</p>
<blockquote>
<p>An implementation of the SOCKET network access protocol. This is the master<br>header file for the Linux NET layer, or, in plain English: the networking<br>handing part of the kernel.</p>
</blockquote>
<p>&emsp;&emsp;摘自/net/socket.c文件的开头，基本上和套接字的实现相关的函数都在这个.c文件里。</p>
<blockquote>
<p>An implementation of the SOCKET network access protocol.</p>
</blockquote>
<p>&emsp;&emsp;摘自/net/ipv4/af_inet.c文件的开头，翻译成英文的意思是说这个头文件是LINUX操作系统的TCP/IP协议套件的实现。 INET是使用BSD套接字接口作为与用户级通信的手段实现的。</p>
<blockquote>
<p>An implementation of the TCP/IP protocol suite for the LINUX operating<br>system. INET is implemented using the BSD Socket interface as the means of<br>communication with the user level.</p>
</blockquote>
<h4 id="相关结构体的介绍"><a href="#相关结构体的介绍" class="headerlink" title="相关结构体的介绍"></a>相关结构体的介绍</h4><p>&emsp;&emsp;先介绍几个结构体，后面会用到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /include/linux/net.h</div><div class="line">struct net_proto_family &#123;</div><div class="line">    int family;//用于指明使用的协议族</div><div class="line">    //create域是一个函数指针，指向特定协议的套接字创建函数。</div><div class="line">    int (*creat)(struct net *net, struct socket *sock, int protocol, int kern);</div><div class="line"></div><div class="line">    struct module *owner;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /net/ipv4/af_inet.c</div><div class="line">static const struct net_proto_family inet_family_ops = &#123;</div><div class="line">    /* UNIX网络编程卷1第79页有对AF_XXX和PF_XXX做过介绍，AF_前缀表示地址族，PF_</div><div class="line">     * 前缀表示协议族。</div><div class="line">     */</div><div class="line">    family = PF_INET,//表示使用协议为Ipv4</div><div class="line">    create = inet_create,//inet_create是套接字创建函数</div><div class="line">    owner = THIS_MODULE,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="inet-init"><a href="#inet-init" class="headerlink" title="inet_init()"></a>inet_init()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /net/ipv4/af_inet.c</div><div class="line">static int __init inet_init(void)</div><div class="line">&#123;</div><div class="line">    struct inet_protosw *q;</div><div class="line">    struct list_head *r;</div><div class="line">    int rc = -EINVAL;</div><div class="line"></div><div class="line">    sock_skb_cb_check_size(sizeof(struct inet_skb_parm));</div><div class="line"></div><div class="line">    rc = proto_register(&amp;tcp_prot, 1);//注册tcp协议</div><div class="line">    if (rc)</div><div class="line">        goto out;</div><div class="line"></div><div class="line"></div><div class="line">    rc = proto_register(&amp;udp_prot, 1);//注册udp协议</div><div class="line">    if (rc)</div><div class="line">        goto out_unregister_tcp_proto;</div><div class="line"></div><div class="line">    rc = proto_register(&amp;raw_prot, 1);//注册raw协议</div><div class="line">    if (rc)</div><div class="line">        gotot out_unregister_udp_proto;</div><div class="line"></div><div class="line">    rc = proto_register(&amp;ping_prot, 1);//注册ping协议</div><div class="line">    if (rc)</div><div class="line">        goto out_unregister_raw_proto;</div><div class="line"></div><div class="line">    /* </div><div class="line">     * Tell SOCKET that we are alive...</div><div class="line">     */</div><div class="line"></div><div class="line">    //调用注册套接字函数</div><div class="line">    (void)sock_register(&amp;inet_family_ops);</div><div class="line"></div><div class="line">    /*</div><div class="line">     * Add all the base protocols.</div><div class="line">     */</div><div class="line"></div><div class="line">    /* 下面4个if为添加icmp、udp、tcp、igmp协议 */</div><div class="line">    if (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; 0)</div><div class="line">        pr_crit(&quot;%d: Cannot add ICMP protocol\n&quot;, __func__);</div><div class="line">    if (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; 0)</div><div class="line">        pr_crit(&quot;%d: Cannot add UDP protocol\n&quot;, __func__);</div><div class="line">    if (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; 0)</div><div class="line">        pr_crit(&quot;%d: Cannot add TCP protocol\n&quot;, __func__);</div><div class="line">#ifdef CONIFG_IP_MULTICAST</div><div class="line">    if (inet_add_protocol(&amp;igmp_protocol, IPPROTO_IGMP) &lt; 0)</div><div class="line">        pr_crit(&quot;%d: Cannot add IGMP protocol\n&quot;, __func__);</div><div class="line">#endif</div><div class="line"></div><div class="line">    ......</div><div class="line">    //inetsw表包含inet_create构建新套接字所需的所有内容</div><div class="line">    for (r = &amp;inetsw[0]; r &lt; &amp;inetsw[SOCK_MAX]; ++r)</div><div class="line">        INIT_LIST_HEAD(r);</div><div class="line"></div><div class="line">    //将inetsw_array中的元素按套接字类型注册到inetsw链表中</div><div class="line">    for (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</div><div class="line">        inet_register_protosw(q);</div><div class="line">    ......</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="套接字注册"><a href="#套接字注册" class="headerlink" title="套接字注册"></a>套接字注册</h4><p>&emsp;&emsp;注册套接字和注销套接字函数的声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /include/linux/net.h</div><div class="line">int sock_register(const struct net_proto_family *fam);</div><div class="line">void sock_unregister(int family);</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;sock_register()的实现起始很简单，就是将要注册的协议套接字添加到结构体数组net_families[]里，net_families[]是net_proto_family类型的结构体数组。有一个小细节就是注意旋转锁和rcu同步机制，不过这两个知识点不是这次介绍的重点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /net/socket.c</div><div class="line">static const struct net_proto_family __rcu *net_families[NPROTO] __read_family;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /net/socket.c</div><div class="line">int sock_register(const struct net_proto_family *ops)</div><div class="line">&#123;</div><div class="line">    int err;</div><div class="line"></div><div class="line">    /* #define NPROTO   AF_MAX</div><div class="line">     * #define AF_MAX   43</div><div class="line">     * 也就是ops-&gt;family的协议值是不能超出43的</div><div class="line">     */</div><div class="line">    if (ops-&gt;family &gt;= NPROTO) &#123; </div><div class="line">        pr_crit(&quot;protocol %d &gt;= NAROTO(%d)\n&quot;, ops-&gt;family, NPROTO);</div><div class="line">        return -ENOBUFS;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //加旋转锁</div><div class="line">    spln_lock(&amp;net_family_lock);</div><div class="line"></div><div class="line">    /* net_families[]是一个协议族数组，每一个被注册的协议都对应一个struct </div><div class="line">     * net_proto_family结构体，该结构体都被存储到这个数组里。</div><div class="line">     * rcu（read-copy update）是Linux中比较重要的一种同步机制，这里就不做</div><div class="line">     * 过多介绍了。</div><div class="line">     */</div><div class="line">    if (rcu_dereference_protected(net_families[ops-&gt;family],</div><div class="line">                lockedp_is_held(&amp;net_family_lock)))</div><div class="line">        err = -EEXIST;</div><div class="line">    else &#123;</div><div class="line">        rcu_assign_pointer(net_families[ops-&gt;family], ops);</div><div class="line">        err = 0;</div><div class="line">    &#125;</div><div class="line">    //释放锁</div><div class="line">    spin_unlock(&amp;net_family_lock);</div><div class="line"></div><div class="line">    pr_info(&quot;NET: Registered protocol family %d\n&quot;, ops-&gt;family);</div><div class="line">    return err;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL(sock_register);</div></pre></td></tr></table></figure>
<p><strong>参考文献</strong><br>（1）TCP/IP架构、应用及设计<br>（2）TCP/IP详解卷2<br>（3）UNIX网络编程卷2</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;应用程序在使用套接字（socket）的时候，其实这个套接字已经进行了注册和初始化，那到底是怎么一个过程呢。可能从事应用开发的人员并不关心这些，只需要会用就行。而像我这种搞网络的，还是得要了解的。&lt;br&gt;
    
    </summary>
    
      <category term="UNIX网络编程" scheme="http://yoursite.com/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="协议栈" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>内核级线程、用户级线程和轻量级进程</title>
    <link href="http://yoursite.com/2018/04/06/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%E3%80%81%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/04/06/内核级线程、用户级线程和轻量级进程的区别/</id>
    <published>2018-04-06T07:47:14.000Z</published>
    <updated>2018-04-06T14:56:15.736Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近看《TCP/IP架构、设计及应用》中对于线程的介绍，看得我一脸懵，其实之前看过一遍，但没有特别注意线程的介绍。于是专门花了点时间在网上认真查了一下资料，算是大致明白了内核级线程、用户级线程和轻量级进程之间的区别。<br><a id="more"></a><br>&emsp;&emsp;线程是程序执行流的最小单元，是进程中的实际运作单位，是被系统独立调度和分派的基本单位。而进程是作为资源分配的基本单位。<br>&emsp;&emsp;从线程的运行空间来说，分为用户级线程（user-level thread, ULT）和内核级线程（kernel-level, KLT）。分类标准主要是线程的调度者是在核内还核外。还有一种线程叫做<strong>轻量级进程</strong>（lightweight process, LWP）。阿西吧，线程不就是轻量级进程吗，难道我以前看的是盗版书？在介绍这三种线程的区别之前先说说单线程和多线程。</p>
<h4 id="单线程和多线程"><a href="#单线程和多线程" class="headerlink" title="单线程和多线程"></a>单线程和多线程</h4><p>&emsp;&emsp;每个进程中只有一个线程在执行称为单线程，多线程是指操作系统在单个进程内多个并发执行路径的能力。下图给出的是单线程和多线程模型。<br><img src="../../../../pictures/Computer System/20180406192814.png" alt=""><br>&emsp;&emsp;进程中的所有线程共享该进程的状态和资源，它们驻留在同一块地址空间中，当一个线程改变了内存中的一个数据项时，其他线程在访问这一数据项时能够看到变化后的结果。多线程就好比多个人在一张桌子吃饭，有一盘猪蹄，某人动筷子吃了一个，那其他人就要少吃一个。单线程如同一个人在一张桌子上吃饭，桌子上所有东西都是你的。多线程相比单线程的优点是可并发、效率高；而缺点是资源竞争带来的不稳定，比如死锁问题，因此对有多个线程要访问的数据需要一些同步技术。</p>
<h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>&emsp;&emsp;用户级线程是指有关线程的管理工作都是由应用程序完成，内核意识不到用户级线程的存在，也不会对这些用户级线程进行调度。记住如果某个进程创建了多个用户级线程，那么所有这些用户级线程仅有一个对应的内核线程，看到这里是不是有点懵逼。要知道在用户级线程策略中，内核是以进程为单位进行调度的，不管进程内有多少线程，内核一次只把一个进程分配给一个处理器，因此一个进程中只有一个线程可以执行，所以只有一个对应的内核线程。</p>
<h5 id="用户级线程的优点"><a href="#用户级线程的优点" class="headerlink" title="用户级线程的优点"></a>用户级线程的优点</h5><p>&emsp;&emsp;（1）用户级线程切换不需要内核态特权，因此，进程不需要为了线程管理而切换到内核态，节省了两次状态转换（从用户态到内核态，从内核态返回到用户态）的开销。<br>&emsp;&emsp;（2）用户级线程可以在任何操作系统上运行，不需要对底层内核进行修改以支持用户级线程。</p>
<h5 id="用户级线程的缺点"><a href="#用户级线程的缺点" class="headerlink" title="用户级线程的缺点"></a>用户级线程的缺点</h5><p>&emsp;&emsp;（1）当用户级线程执行一个系统调用时，不进这个线程会被阻塞，进程中的所有线程都会被阻塞。<br>&emsp;&emsp;（2）在一个纯粹的用户级线程中，一个多线程应用程序不能利用多处理技术。这一点在前面已经说过。而在现实中多处理系统变得越来越普遍，所以提供纯用户级线程的操作系统几乎没有了。</p>
<h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>&emsp;&emsp;内核级线程是指由内核管理、只运行在内核态、不受用户态上下文拖累的线程。其依赖于操作系统核心，由内核的内部需求进行创建和撤销。内核线程的线程表位于内核中，包括了线程控制块，一旦线程阻塞，内核会从当前或者其他进程中重现选择一个线程保证程序的执行。用户应用程序通过API和系统调用（system call）来访问内核级线程。</p>
<h5 id="内核级线程的优点"><a href="#内核级线程的优点" class="headerlink" title="内核级线程的优点"></a>内核级线程的优点</h5><p>&emsp;&emsp;（1）如果进程中的一个线程被阻塞，内核可以调度同一个进程的另一个线程。<br>&emsp;&emsp;（2）内核可以同时把同一个进程中的多个线程调度到多个处理器。是不是又有一点阿西吧了，在说用户级线程时说一个进程只会被分配一个处理器。而在这里又说可以同时给一个进程中的多个线程调度到多个处理器。先给一个模型图然后再解释原因。<br><img src="../../../../pictures/Computer System/20180406210450.png" alt=""><br>&emsp;&emsp;首先要明确一点，用户级线程是运行在用户态，内核无法感知到用户空间发生了什么，所以只会给进程分配一个处理器。而内核级线程是运行在内核态，内核级线程没有自己地址空间，在内核地址空间执行。</p>
<h5 id="内核级线程的缺点"><a href="#内核级线程的缺点" class="headerlink" title="内核级线程的缺点"></a>内核级线程的缺点</h5><p>&emsp;&emsp;（1）把控制从一个线程传送到同一个进程的另一个线程时，需要到内核的状态切换，这样会造成系统开销。</p>
<h4 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h4><p>&emsp;&emsp;术语轻量级进程有几个不同的说法：1）等同于线程；2）等同于内核级线程；3）一种把用户级线程映射到内核级线程的实体。<br>&emsp;&emsp;在这里取第三层意思。轻量级进程的创建完全在用户空间完成，进程的调度和同步也在应用程序中进行。每一个轻量级进程都与一个特定的内核线程建立映射关系，即每个轻量级进程由一个内核支持。当某个轻量级进程阻塞时，不会导致整个进程的阻塞。轻量级进程结合了用户级线程和内核级线程的优点，同时减少了他们的缺点。但是轻量级进程还是有局限性，因为每个轻量级进程都需要一个内核级线程支持，而内核级线程会消耗内核资源，因此一个系统不能支持大量的轻量级进程。</p>
<h4 id="用户级线程、内核级线程和轻量级进程的比较"><a href="#用户级线程、内核级线程和轻量级进程的比较" class="headerlink" title="用户级线程、内核级线程和轻量级进程的比较"></a>用户级线程、内核级线程和轻量级进程的比较</h4><p>&emsp;&emsp;（1）用户级线程和轻量级进程的创建和销毁都在用户空间完成，而内核级线程在内核内部创建。<br>&emsp;&emsp;（2）用户级线程由线程库创建，轻量级进程由系统调用pthread_creat()来创建，内核级线程通过调用kernel_thread()来创建。但是轻量级进程和内核级线程的创建都使用内核接口clone()。</p>
<p><strong>参考文献</strong><br> 1、《操作系统精髓与设计原理》<br> 2、《TCP/IP架构、设计及应用》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近看《TCP/IP架构、设计及应用》中对于线程的介绍，看得我一脸懵，其实之前看过一遍，但没有特别注意线程的介绍。于是专门花了点时间在网上认真查了一下资料，算是大致明白了内核级线程、用户级线程和轻量级进程之间的区别。&lt;br&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程和线程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>虚函数与纯虚函数</title>
    <link href="http://yoursite.com/2018/04/01/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/04/01/虚函数/</id>
    <published>2018-04-01T11:32:28.000Z</published>
    <updated>2018-04-02T07:01:59.639Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;有两种机制可以用于实现多态公有继承：<br>&emsp;&emsp;（1）在派生类中重新定义基类的方法；<br>&emsp;&emsp;（2）使用虚函数；<br><a id="more"></a></p>
<h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>&emsp;&emsp;如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，程序将根据对象类型而不是引用或指针的类型来选择调用那个方法。为基类声明一个虚析构函数也是一种惯例。虚函数使用关键字virtual声明。下面举个简单的例子，假如类Brass是BrassPlus的基类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Brass &#123;</div><div class="line">private:</div><div class="line">public:</div><div class="line">    Brass();</div><div class="line">    double Balance();//忽略</div><div class="line">    virtual void Withdraw(double);//基类虚函数</div><div class="line">    virtual void ViewAcct();//基类虚函数</div><div class="line">    virtual ~Brass();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class BrassPlus: public Brass &#123;</div><div class="line">private:</div><div class="line">public:</div><div class="line">    BrassPlus();</div><div class="line">    virtual void Withdraw(double);//派生类虚函数</div><div class="line">    virtual ViewAcct();//派生类虚函数</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    Brass dom;//基类对象</div><div class="line">    BrassPlus dot;//派生类对象</div><div class="line"></div><div class="line">    Brass &amp; b1_ref = dom;//b1_ref的引用类型为Brass，指向的对象类型也为Brass</div><div class="line">    Brass &amp; b2_ref = dot//b2_ref的引用类型为Brass，指向的对象类型为BrassPlus</div><div class="line">    b1_ref.ViewAcct();//Brass::ViewAcct()</div><div class="line">    b2_ref.ViewAcct();//BrassPlus::ViewAcct()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>如果没有使用virtual</strong>声明为虚函数，那么程序将根据引用类型或指针类型选择方法，因为引用变量的类型为Brass，那么调用b1_ref.ViewAcct()和b2_ref.ViewAcct()都会选择Brass::ViewAcct()。<br>&emsp;&emsp;<strong>如果使用了virtual</strong>声明为虚函数，那么程序将根据引用类或指针指向的对象的类型选择方法，即调用b1_ref会选择Brass::ViewAcct()，而调用b2_ref会选择BrassPlus::ViewAcct()。<br>&emsp;&emsp;函数在基类中被声明为虚的后，它在派生类中将自动成为虚函数。但是在派生类中使用关键字virtual来指明那些函数在基类中被声明成了虚函数也是一种常见的做法。还需要注意的是关键字virtual只用于类声明的原型中，而不会用于方法定义中。</p>
<h5 id="虚函数和非虚函数在编译时的差别"><a href="#虚函数和非虚函数在编译时的差别" class="headerlink" title="虚函数和非虚函数在编译时的差别"></a>虚函数和非虚函数在编译时的差别</h5><p>&emsp;&emsp;通过一个简单的例子来说明他们之间的差别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BrassPlus ophelia;</div><div class="line">Brass *bp;</div><div class="line">bp = &amp;ophelia;</div><div class="line">bp-&gt;ViewAcct();</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果在BrassPlus中没有将ViewAcct()声明为虚函数，那么将根据指针类型来调用bp-&gt;ViewAcct()。而指针类型在编译时已知，那么编译器对非虚函数将使用静态编译。<br>&emsp;&emsp;如果在BrassPlus中将ViewAcct声明为虚函数，那么将根据指针指向的对象类型来调用bp-&gt;ViewAcct()。但通常只有在运行程序时才能确定对象的类型，那么编译器对虚函数将使用动态编译。<br><strong>动态编译</strong>：要在运行时判断对象的类型，就必须采取一些方法来跟踪基类指针或引用指向的对象类型，这会增加额外的处理开销。<br><strong>静态编译</strong>：在编译阶段就可以知道指针或引用的类型，而不需要额外的开销来跟踪基类指针或引用指向的对象，这样效率更高。C++的指导原则是不要为不使用的特性付出代价（内存或则处理时间），仅当程序设计确实需要虚函数时，才使用。</p>
<h5 id="虚函数的工作原理"><a href="#虚函数的工作原理" class="headerlink" title="虚函数的工作原理"></a>虚函数的工作原理</h5><p>&emsp;&emsp;编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员找那个保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table, vtbl)。虚函数表中存储了为类对象进行声明的虚函数的地址。<br>&emsp;&emsp;派生类对象会包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址，如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该虚函数的地址将被添加到vtal表中。</p>
<h5 id="有关虚函数的注意事项"><a href="#有关虚函数的注意事项" class="headerlink" title="有关虚函数的注意事项"></a>有关虚函数的注意事项</h5><p>&emsp;&emsp;（1）构造函数不能是虚函数，因为派生类不能继承基类的构造函数，所以将类构造函数声明为虚的没什么意义。<br>&emsp;&emsp;（2）基类的析构函数应该是虚函数，除非不用做基类。即使不用做基类，给类定义一个虚析构函数并非错误，只会带来效率方面的问题。<br>&emsp;&emsp;（3）友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。<br>&emsp;&emsp;（4）如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。</p>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>&emsp;&emsp;纯虚函数是在基类中声明的一种特殊的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。纯虚函数的一般格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class temp &#123;</div><div class="line">public:</div><div class="line">    virtual function()=0</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;含有纯虚函数的类叫做抽象类。这种类不能声明对象，只能作为基类为派生类服务。除非在派生类中完全实现基类中所有的纯虚函数，否则，派生类也会变成抽象类，不能实例化对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;有两种机制可以用于实现多态公有继承：&lt;br&gt;&amp;emsp;&amp;emsp;（1）在派生类中重新定义基类的方法；&lt;br&gt;&amp;emsp;&amp;emsp;（2）使用虚函数；&lt;br&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>排序问题（二）</title>
    <link href="http://yoursite.com/2018/03/26/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/26/排序问题（二）/</id>
    <published>2018-03-26T11:16:10.000Z</published>
    <updated>2018-03-27T09:07:21.068Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前面介绍了插入排序、归并排序和堆排序，下面接着介绍排序算法中的快速排序、计数排序和桶排序。最后还会给出各个排序算法的时间复杂度。<br><a id="more"></a></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>&emsp;&emsp;快速排序是一种最坏情况时间复杂度为$\Theta（n^2）$的排序算法，但是快速排序通常是实际排序应用中最好的选择，因为它的平均性能非常好：它的期望时间复杂度是$\Theta（nlgn）$，而且$\Theta（nlgn）$中隐含的常数因子非常小。另外一个特点是，快速排序是原址排序的，甚至在虚存环境中也能很好的工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void QuickSort(int* array, int begin, int end)</div><div class="line">&#123;</div><div class="line">    if (begin &lt; end) &#123;</div><div class="line">        //每次调用Partition()函数，都会有一个数被排序到正确的位置</div><div class="line">        int temp = Partition(array, begin, end);</div><div class="line">        //采用分治策略递归调用QuickSort()，快速排序的重点是Partition()函数</div><div class="line">        QuickSort(array, begin, temp-1);</div><div class="line">        QuickSort(array, temp+1, end);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Partition(int* array, int begin, int end)</div><div class="line">&#123;</div><div class="line">    //保存数组的最后一位</div><div class="line">    int key = array[end];</div><div class="line">    int i = begin - 1;</div><div class="line"></div><div class="line">    //将小于key的数放到key的左边，大于key的数放到key的右边</div><div class="line">    for (int j = begin; j &lt;= end-1; j++) &#123;</div><div class="line">        if (array[j] &lt;= key) &#123;</div><div class="line">            i = i+1;</div><div class="line">            swap(array[i], array[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //将key放到其在数组中应在的位置</div><div class="line">    swap(array[i+1], array[end]);</div><div class="line"></div><div class="line">    return i+1;//返回key的下标</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>&emsp;&emsp;计数排序是一种线性时间复杂度的排序算法，假设$n$个输入元素中的每一个都是在$0$到$k$区间内的一个整数。当$k=O（n）$时，排序的运行时间为$\Theta（n）$。<br>&emsp;&emsp;计数排序的基本思想是：对每一个输入元素x，确定小于x的元素个数，那么便可以确定x在输出数组中的位置了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void CountingSort(int* array, int* Output, int length, int k)</div><div class="line">&#123;</div><div class="line">    //用于临时存放待排序数组元素的统计信息</div><div class="line">    int temp[k+1];</div><div class="line">    for (int i = 0; i &lt;= k; i++)</div><div class="line">        temp[i] = 0;//初始化临时数组</div><div class="line"></div><div class="line">    for (int j = 0; j &lt; length; j++)</div><div class="line">        //统计array数组中每个元素出现的次数</div><div class="line">        temp[array[j]] = temp[array[j]] + 1;</div><div class="line"></div><div class="line">    for (int i = 1; i &lt;= k; i++)</div><div class="line">        //通过累加计算确定对每一个i=0,1,...,k，有多少输入元素是小于或等于i的。</div><div class="line">        temp[i] = temp[i] +temp[i-1];</div><div class="line"></div><div class="line">    for (int j = 0; j &lt; length; j++) &#123;</div><div class="line">        //把array数组中的每个元素放到它在输出数组Output的正确位置上。</div><div class="line">        Output[temp[array[j]]-1] = array[j];</div><div class="line">        temp[array[j]] = temp[array[j]] - 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;计数排序的一个重要性质就是它是稳定的，具有相同值的元素在输出数组中的相对次序与它们在输入数组中的次序相同。</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>&emsp;&emsp;桶排序的时间复杂度为$O（n）$，工作原理是将数组分到有限数量的桶子里，每个桶再个别排序，虽然桶排序有好的时间复杂度，但却是以牺牲空间为代价。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//定义链表节点</div><div class="line">struct Node &#123;</div><div class="line">    int data;</div><div class="line">    Node* next;</div><div class="line">    Node(int _data) &#123;</div><div class="line">        data = _data;</div><div class="line">        next = NULL;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void BucketSort(int* array, int arraySize, int bucketSize)</div><div class="line">&#123;</div><div class="line">    Node **bucketTable = (Node**)malloc(bucketSize*sizeof(Node*));</div><div class="line">    for (int i = 0; i &lt; bucketSize; i++) &#123;//初始化桶</div><div class="line">        bucketTable[i] = (Node*)malloc(sizeof(Node));//分配一个节点空间</div><div class="line">        bucketTable[i]-&gt;data = 0;//0表示桶中还没有数据</div><div class="line">        bucketTable[i]-&gt;next = NULL;//给next指针初始值赋值NULL</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int j = 0; j &lt; arraySize; j++) &#123;</div><div class="line">        Node* node = (Node*)malloc(sizeof(Node));//申请一个节点大小空间</div><div class="line">        node-&gt;data = array[j];//将待排序数组的元素依次赋给新节点</div><div class="line">        node-&gt;next = NULL;//新节点的next赋空</div><div class="line"></div><div class="line">        int index = array[j]/10;//假设数据满足0 &lt;= array[j] &lt;= 99</div><div class="line">        node *p = bucketTable[index];//p指向桶中数据链表的头</div><div class="line"></div><div class="line">        if (p-&gt;data == 0) &#123;//桶为空时</div><div class="line">            bucketTable[index]-&gt;next = node;//将第一个节点挂载链表头指针后面</div><div class="line">            (bucketTable[index]-&gt;data)++;//头指针的data域记录桶中元素的个数</div><div class="line">        &#125; esle &#123;//桶不为空时，将相应节点插入到链表中</div><div class="line">            while (p-&gt;next != NULL &amp;&amp; p-&gt;next-&gt;data &lt; node-&gt;data)</div><div class="line">                p = p-&gt;next;</div><div class="line">            //添加新节点</div><div class="line">            node-&gt;next = p-&gt;next;</div><div class="line">            (bucketTable[index]-&gt;data)++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;下面盗用算法导论中的一个图，以便更好地理解桶排序。<br><img src="../../../../pictures/algorithm/00000.png" alt=""></p>
<h4 id="时间和空间复杂度"><a href="#时间和空间复杂度" class="headerlink" title="时间和空间复杂度"></a>时间和空间复杂度</h4><p>&emsp;&emsp;下面给出了博客中介绍到的算法的时间复杂度和空间复杂度，有些排序算法还没介绍到，还请多多谅解。如果下面的结果有不对的请指出。<br><img src="../../../../pictures/algorithm/20180327165908.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前面介绍了插入排序、归并排序和堆排序，下面接着介绍排序算法中的快速排序、计数排序和桶排序。最后还会给出各个排序算法的时间复杂度。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序问题（一）</title>
    <link href="http://yoursite.com/2018/03/25/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/25/排序问题（一）/</id>
    <published>2018-03-25T15:24:55.000Z</published>
    <updated>2018-03-30T01:13:32.829Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;目前正在看《算法导论》，之前看了一部分，没坚持看完，而今迈步重头越，顺便写个博客记录一下，避免下次出现类似情况。这篇博客主要是记录《算法导论》第一部分的排序问题，排序问题是算法中的基本问题，也是一个重要问题。<br><a id="more"></a><br>&emsp;&emsp;在正式介绍排序排序算法之前，先声明一下什么是原址排序：如果输入数组中仅有常数个元素需要在排序过程中存储在数组之外，则称排序是原址的。</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>&emsp;&emsp;插入排序的主要思想是假设array[0] to array[j-1]是已排好序的，array[j]是当前待插入的数，array[j+1] to array[n]是无序的。那么先使用变量key保存array[j]的值，使用i记录array[j]前一个值的下标，然后将array[j-1] to array[0]依次与key比较，直到i &lt; 0 or array[i] &lt; key，此时便找到了key要插入的位置。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">InsertionSort(int* array, int length)</div><div class="line">&#123;</div><div class="line">    int key, i;//key表示待插入的数</div><div class="line"></div><div class="line">    for (int j = 1; j &lt; length; j++) &#123;</div><div class="line">        key = array[j];</div><div class="line">        i = j - 1;</div><div class="line">        while (i &gt;= 0 &amp;&amp; array[i] &gt; key) &#123;//循环结束条件</div><div class="line">            array[i+1] = array[i];//将大于key的数依次向后移</div><div class="line">            i = i - 1;</div><div class="line">        &#125;</div><div class="line">        array[i+1] = key;//i+1为key要插入的位置</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;对于小规模输入，插入排序是一种非常快的原址排序算法。插入排序的时间复杂度为$O(n^2)$</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>&emsp;&emsp;归并排序是时间复杂度相比于插入排序更低的方法，但缺点是需要更多的额外空间开销。这是一个很普遍的问题，要么用时间换取空间，要么用空间换取时间，就看问题具体的要求了。<br>&emsp;&emsp;归并排序的主要思想是先将一个大问题分解成若干子问题，如果子问题不能直接解决，就继续递归分解，知道能够被直接解决为止，最后再合并这些子问题的解成原问题的解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">void MergeSort(int* array, int begin, int end)</div><div class="line">&#123;</div><div class="line">    if (begin &lt; end) &#123;//停止分解条件</div><div class="line">        int mid = (begin + end)/2;</div><div class="line">        MergeSort(array, begin, mid);//继续分解左子问题</div><div class="line">        MergeSort(array, mid+1, end);//继续分解右子问题</div><div class="line">        Merge(array, begin, mid, end)//合并子问题</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Merge(int* array, int begin, int mid, int end)</div><div class="line">&#123;</div><div class="line">    int n1 = mid - begin + 1;//计算左子数组的长度</div><div class="line">    int n1 = end - mid;//计算右子数组的长度</div><div class="line">    /* 分配一个数组用于临时存放子树组，可以发现LArray.length()</div><div class="line">     * 要比n1大1，RArray.length()也要比n2大1，这么做的原因是每</div><div class="line">     * 个临时数组都需要用一位来存放哨兵。*/</div><div class="line">    int LArray[n1+1];</div><div class="line">    int RArray[n2+1];</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; n1; i++)//将已排好序的左数组放到临时数组</div><div class="line">        LArray[i] = array[begin+i];</div><div class="line">    for (int j = 0; j &lt; n2; j++)//将已排好序的有数组放到临时数组</div><div class="line">        RArray[j] = array[mid+j+1];</div><div class="line"></div><div class="line">    LArray[n1] = INT_MAX;//设置哨兵</div><div class="line">    RArray[n2] = INT_MAX;//设置哨兵</div><div class="line"></div><div class="line">    int i = 0;</div><div class="line">    int j = 0;</div><div class="line">    //合并左右子数组</div><div class="line">    for (int k = 0; k &lt;= end; k++) &#123;</div><div class="line">        if (LArray[i] &gt; RArray[j]) &#123;</div><div class="line">            array[k] = RArray[j];//复制回原数组</div><div class="line">            j++;</div><div class="line">        &#125; else &#123;</div><div class="line">            array[k] = LArray[i];//复制回原数组</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以发现归并排序在排序过程中每次合并都需要借助额外数组，假设借用的额外数组规模为$f(n)$，那么有<br>$$f(n) = 1+2+…+n = \frac{n(n+1)}{2}$$<br>所以归并排序不是原址的。归并排序的时间复杂度为$O(nlgn)$</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>&emsp;&emsp;如果是非递减排序，冒泡排序的思想就是每次找到未排序数组中的最小值；如果是非递增排序，那么冒泡排序就是每次找到未排序数组中的最大值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void BubbleSort(int* array, int length)</div><div class="line">&#123;</div><div class="line">    for (int i = 0; i &lt; length-1; i++)</div><div class="line">        for (int j = i+1; j &lt; length; j++)</div><div class="line">            //array[i]永远记录未排序数组中的最小值</div><div class="line">            if (array[i] &gt; array[j])</div><div class="line">                swap(array[i], array[j]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;冒泡排序就不需要多做解释了吧！每一个写程序的人应该都能随手一挥就搞定的最基础的排序算法。冒泡排序的时间复杂度为$O(n^2)$</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>&emsp;&emsp;堆排序结合了插入排序和归并排序的优点，时间复杂度为$O(nlgn)$，且只有常数量的额外空间开销，属于原址排序。<br>&emsp;&emsp;这里的堆排序主要通过三个函数完成：<br>    （1） void MaxHeapify(int<em> array, int i)该函数主要用于维护大顶堆的性质，MaxHeapify()保证以i为根的子树是一个大顶堆；<br>    （2） void BuildHeap(int</em> array)保证整个堆是一个大顶堆；<br>    （3） void HeapSort(int* array)通过利用堆的性质对数组进行排序；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"> #define PARENTS(i-1)/2   //计算父节点的下标</div><div class="line"> #define LEFT(i) 2*i + 1  //计算左孩子的下标</div><div class="line"> #define RIGHT(i) 2*i + 2 //计算右孩子的下标</div><div class="line"></div><div class="line">/* MaxHeapify()假设节点i的左右子树已经是大顶堆，现在只需要比较节点i和其左右孩子</div><div class="line"> * 如果节点i满足比其左右孩子都大，那么以节点i为根的堆就已经是一个大顶堆了。如果</div><div class="line"> * 不满足，那就需要调整。*/</div><div class="line"> void MaxHeapify(int* array, i)</div><div class="line"> &#123;</div><div class="line">    int l = LEFT(i);</div><div class="line">    int r = RIGHT(i);</div><div class="line">    int largest = i; </div><div class="line"></div><div class="line">    if ( (l &gt; heapSize) &amp;&amp; (array[l] &gt; array[i]) )</div><div class="line">        largest = l; //如果该节点小于其左孩子，那么就用largest记录左孩子的下标</div><div class="line">    else</div><div class="line">        largest = i;</div><div class="line"></div><div class="line">    if ( (r &gt; heapSize) &amp;&amp; (array[r] &gt; array[largest]) )</div><div class="line">        largest = r; //如果该节点小于其右孩子，那么就用largest记录右孩子的下标</div><div class="line"></div><div class="line">    //如果largest记录的值不等于i，说明array[i]与其左孩子或右孩子进行了交换，需</div><div class="line">      要递归继续比较</div><div class="line">    if (largest != i)</div><div class="line">        MaxHeapify(array, largest);</div><div class="line"> &#125; </div><div class="line"></div><div class="line">/* 依次对每一个非叶子结点调用MaxHeapify()，这样便可保证建一个大顶堆 */</div><div class="line"> void BuildHeap(int* array)</div><div class="line"> &#123;</div><div class="line">    for (int i = heapSize/2; i &gt;= 0; i--)</div><div class="line">    &#123;</div><div class="line">        MaxHeapify(array, i);</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">/* 因为数组中的最大元素总在根节点，所以只需将根节点与array[heapSize-1]交换，然</div><div class="line"> * 后从堆中去掉节点heapSize-1，再调用MaxHeapify()更新大顶堆。*/</div><div class="line"> void HeapSort(int* array)</div><div class="line"> &#123;</div><div class="line">    BuildHeap(array);//建立大顶堆</div><div class="line">    for (int i = heapSize-1; i &gt; 0; i--) &#123;</div><div class="line">        swap(array[0], array[i]);//将数组的最大元素放到数组的最后</div><div class="line">        heapSize = heapSize - 1;//去掉堆中的节点heapSize-1</div><div class="line">        MaxHeapify(array, 0);//更新大顶堆</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这部分先介绍这四种排序算法，在下一篇博客中会介绍快速排序、计数排序和桶排序算法。然后还会对它们的时间复杂度做一个总结。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;目前正在看《算法导论》，之前看了一部分，没坚持看完，而今迈步重头越，顺便写个博客记录一下，避免下次出现类似情况。这篇博客主要是记录《算法导论》第一部分的排序问题，排序问题是算法中的基本问题，也是一个重要问题。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>I/O通信技术</title>
    <link href="http://yoursite.com/2018/03/03/I-O%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/03/03/I-O通信技术/</id>
    <published>2018-03-03T01:17:59.000Z</published>
    <updated>2018-04-08T06:40:49.281Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;对I/O操作有三种可能的技术：可编程I/O、中断驱动I/O、直接内存存取（DMA）。<br><a id="more"></a></p>
<h4 id="可编程I-O"><a href="#可编程I-O" class="headerlink" title="可编程I/O"></a>可编程I/O</h4><p>&emsp;&emsp;当处理器正在执行程序并遇到一个与I/O相关的指令时，它通过给相应的I/O模块发命令来执行这个指令。<br>&emsp;&emsp;可编程I/O的问题是处理器通常必须等待很长的时间，以确定I/O模块是否做好了接收或发送更多数据的准备。处理器在等待期间必须不断的询问I/O木块的状态，其结果是严重地降低了整个系统的性能。</p>
<h4 id="中断驱动I-O"><a href="#中断驱动I-O" class="headerlink" title="中断驱动I/O"></a>中断驱动I/O</h4><p>&emsp;&emsp;从I/O模块的角度看，输入操作的过程如下：I/O模块从处理器中接收一个READ命令，然后开始从相关的外围设备读数据。一旦数据被读入该模块的数据寄存器，模块通过控制线给处理器发送一个中断信号，然后等待直到处理器请求该数据。当处理器发出这个请求后，模块把数据放到数据总线上，然后准备下一次的I/O操作。<br>&emsp;&emsp;中断驱动I/O比可编程I/O更有效，因为消除了不必要的等待。但是，由于数据中的每个字无论是从存储器到I/O模块，还是从I/O模块到存储器都必须通过处理器处理，这导致中断驱动I/O仍然会花费很多处理器时间。</p>
<h4 id="直接内存存取"><a href="#直接内存存取" class="headerlink" title="直接内存存取"></a>直接内存存取</h4><p>&emsp;&emsp;当需要移动大量的数据时，一种更有效的技术是采用直接内存存取（DMA）。DMA模块直接与存储器交互，传送整个数据块，每次传送一个字。这个过程不需要处理器参与，当传送完成后，DMA模块给处理器发一个中断信号。因此只有在开始传送和传送结束时处理器才会参与。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;对I/O操作有三种可能的技术：可编程I/O、中断驱动I/O、直接内存存取（DMA）。&lt;br&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>tc用户程序设计及其内核实现</title>
    <link href="http://yoursite.com/2018/01/11/tc%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/01/11/tc用户程序设计及其内核实现/</id>
    <published>2018-01-11T01:02:00.000Z</published>
    <updated>2018-04-02T07:05:06.329Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;tc是一个用户程序，重写并且更新Linux中的默认排队规则。它使用netlink作为用户空间与内核空间进行交互的通信信道。它添加新的排队规则、流量类别、过滤器等。<br><a id="more"></a></p>
<h4 id="函数tc-modify-qdisc"><a href="#函数tc-modify-qdisc" class="headerlink" title="函数tc_modify_qdisc()"></a>函数tc_modify_qdisc()</h4><p>&emsp;&emsp;在添加qdisc到排队规则时，doit函数指针指向tc_modify_qdisc()。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line">linux-4.13.11@net/sched/sch_api.c</div><div class="line"></div><div class="line">static int tc_modify_qdisc(struct sk_buff *sk, struct nlmsghdr *n, void *arg)</div><div class="line">&#123;</div><div class="line">    struct net *net = sock_net(skb-&gt;sk);</div><div class="line">    //tcmsg结构体定义了跟流量控制相关的消息内容</div><div class="line">    struct tcmsg *tcm; //tc消息指针</div><div class="line">    struct nlattr *tca[TCA_MAX + 1];</div><div class="line">    struct net_device *dev; //网络设备指针</div><div class="line">    u32 clid; //class id</div><div class="line">    //发送队列策略结构体</div><div class="line">    struct Qdisc *q, *p;</div><div class="line">    int err;</div><div class="line"></div><div class="line">    if (!netlink_ns_capable(skb, net-&gt;user_ns, CAP_NET_ADMIN)</div><div class="line">        return -ERROR;</div><div class="line"></div><div class="line">replay:</div><div class="line">    err = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL, extack);</div><div class="line">    if (err &lt; 0)</div><div class="line">        return err;</div><div class="line"></div><div class="line">    tcm = nlmsg_data(n);</div><div class="line">    /* 将tcm_parent的值赋给clid */</div><div class="line">    clid = tcm-&gt;tcm_parent;</div><div class="line">    q = p = NULL;</div><div class="line"></div><div class="line">    /* 根据参数ifindex搜索一个接口并返回设备的指针。 */</div><div class="line">    dev = __dev_get_by_index(net, tcm-&gt;tcm_ifindex);</div><div class="line">    /* 指向设备的指针为空，则返回一个错误 */</div><div class="line">    if (!dev)</div><div class="line">        return -ENODEV;</div><div class="line"></div><div class="line">    /* tcm_parent的值为真 */</div><div class="line">    if (clid) &#123;</div><div class="line">        /* 这里chid != TC_H_ROOT表示排队规则不是根，有父类。 */</div><div class="line">        if (clid != TC_H_ROOT) &#123;</div><div class="line">            /* 非ingress节点时，根据类别ID的高16位查找Qdisc节点 */</div><div class="line">            if (chid != TC_H_INGRESS) &#123;</div><div class="line">                //查找父类排队规则</div><div class="line">                if ((p = qdisc_lookup(dev, TC_H_MAJ(chid))) == NULL)</div><div class="line">                    return -ENOENT;</div><div class="line">                //获取p节点的叶子节点</div><div class="line">                q = qdisc_leaf(p, clid);</div><div class="line">            &#125; else &#123;</div><div class="line">                //使用设备ingress流控</div><div class="line">                q = dev-&gt;qdisc_ingress;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            /* 根节点情况下流控用的是设备的qdisc_sleeping，qdisc_sleeping指向配</div><div class="line">             * 置的当前配置队列规则。</div><div class="line">             */</div><div class="line">            q = dev-&gt;qdisc_sleeping;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* it may be default qdisc, ignore it */</div><div class="line">        if (q &amp;&amp; q-&gt;handle == 0)</div><div class="line">            q = NULL;</div><div class="line"></div><div class="line">        /* 没找到Qdisc节点，或者没在tc消息中指定句柄，或者找到的Qdisc句柄和tc消</div><div class="line">         * 息中的句柄不同。</div><div class="line">         */</div><div class="line">        if (!q || !tcm-&gt;tcm_handle || q-&gt;handle != tcm-&gt;tcm_handle) &#123;</div><div class="line">            //tc制定了句柄</div><div class="line">            if (tcm-&gt;tcm_handle) &#123;</div><div class="line">                //如果Qdisc存在但不是更新命令，返回对象存在错误</div><div class="line">                if (q &amp;&amp; !(n-&gt;nlmsg_flags &amp; NLM_F_REPLACE))</div><div class="line">                    return -EEXIST;</div><div class="line">                //tc句柄低16位不能为0</div><div class="line">                if (TC_H_MIN(tcm-&gt;tcm_handle))</div><div class="line">                    return -EINVAL;</div><div class="line">                /* 根据tc句柄查找该设备上的Qdisc，找不到的话跳转到创建新节点操</div><div class="line">                 * 作。</div><div class="line">                 */</div><div class="line">                q = qdisc_lookup(dev, tcm-&gt;tcm_handle);</div><div class="line">                if (!q)</div><div class="line">                    goto create_n_graft;</div><div class="line">                ......</div><div class="line">                goto graft;</div><div class="line">            //没指定TC句柄</div><div class="line">            &#125; else &#123;</div><div class="line">                //如果没找到Qdisc，跳转到创建新节点</div><div class="line">                if (q == NULL)</div><div class="line">                    goto create_n_graft;</div><div class="line">                //检查各种标志是否冲突，Qdisc名称是否正确</div><div class="line">                if ((n-&gt;nlmsg_flags&amp;NLM_F_CREATE) &amp;&amp;</div><div class="line">                    (n-&gt;nlmsg_flags&amp;NLM_F_REPLACE) &amp;&amp;</div><div class="line">                    ((n-&gt;nlmsg_flags&amp;NLM_F_EXCL) ||</div><div class="line">                    (tca[TCA_KIND-1] &amp;&amp;</div><div class="line">                    rtattr_strcmp(tca[TCA_KIND-1], q-&gt;ops-&gt;id))))</div><div class="line">                    goto create_n_graft;</div><div class="line">            &#125; //else</div><div class="line">        &#125; //if</div><div class="line">    //没有指定类别ID</div><div class="line">    &#125; else &#123;</div><div class="line">        //从tc消息的句柄来查找Qdisc</div><div class="line">        if (!tcm-&gt;tcm_handle)</div><div class="line">            return -EINVAL;</div><div class="line">        q = qdisc_lookup(dev, tcm-&gt;tcm_handle);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Change qdisc parameter */</div><div class="line">    //没找到Qdisc节点，返回错误</div><div class="line">    if (q == NULL)</div><div class="line">        return -ENOENT;</div><div class="line">    //找到Qdisc节点，但设置了NLM_F_EXCL(排斥)标志，返回对象存在错误</div><div class="line">    if (n-&gt;nlmsg_flags &amp; NLM_F_EXCL)</div><div class="line">        return -EEXIST;</div><div class="line">    //检查找到的Qdisc节点的名称和tc中指定的是否匹配</div><div class="line">    if (tca[TCA_KIND] &amp;&amp; nla_strcmp(tca[TCA_KIND], q-&gt;ops-&gt;id))</div><div class="line">        return -EINVAL;</div><div class="line">    //修改Qdisc参数</div><div class="line">    err = qdisc_change(q, tca);</div><div class="line">    if (err == 0)</div><div class="line">        qdisc_notify(net, skb, n, clid, NULL, q);</div><div class="line">    return err;</div><div class="line"></div><div class="line">create_n_graft:</div><div class="line">    //检查nlmsg_flags是否设置了NLM_F_CREATE，没有就返回错误</div><div class="line">    if (!(n-&gt;nlmsg_flags &amp; NLM_F_CREATE))</div><div class="line">        return -ENOENT;</div><div class="line">    //class id = TC_H_INGRESS就创建新Qdisc节点</div><div class="line">    if (clid == TC_H_INGRESS) &#123;</div><div class="line">        if (dev_ingress_queue(dev))</div><div class="line">            //分配并初始化新的qdisc</div><div class="line">            q = qdisc_create(dev, dev_ingress_queue(dev), p, </div><div class="line">            tcm-&gt;tcm_parent, tcm-&gt;tcm_parent, tca, &amp;err);</div><div class="line">        else    </div><div class="line">            err = -ENOENT;</div><div class="line">    &#125; else &#123;</div><div class="line">        struct netdev_queue *dev_queue;</div><div class="line">        if (p &amp;&amp; p-&gt;ops-&gt;cl_ops &amp;&amp; p-&gt;ops-&gt;cl_ops-&gt;select_queue)</div><div class="line">            dev_queue = p-&gt;ops_cl_ops-&gt;select_queue(p, tcm);</div><div class="line">        else if (p)</div><div class="line">            dev_queue = p-&gt;dev_queue;</div><div class="line">        else</div><div class="line">            dev_queue = netdev_get_tx_queue(dev, 0);</div><div class="line"></div><div class="line">        q = qdisc_create(dev, dev_queue, p, tcm_parent,</div><div class="line">            tcm-&gt;tcm_handle, tca, &amp;err);</div><div class="line">    &#125;</div><div class="line">    if (q == NULL) &#123;</div><div class="line">        if (err == -EAGAIN)</div><div class="line">            goto replay;</div><div class="line">        return err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">graft:</div><div class="line">    err = qdisc_graft(dev, p, skb, n, clid, q, NULL);</div><div class="line">    if (err) &#123;</div><div class="line">        if (q)</div><div class="line">            qdisc_destroy(q);</div><div class="line">        return err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="相关结构体的定义"><a href="#相关结构体的定义" class="headerlink" title="相关结构体的定义"></a>相关结构体的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">linux-4.13.11@include/uapi/linux/netlink.h</div><div class="line"></div><div class="line">struct nlattr &#123;</div><div class="line">    __u16   nla_len;</div><div class="line">    __u16   nla_type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">linux-4.13.11@include/uapi/linux/rtnetlink.h</div><div class="line"></div><div class="line">struct tcmsg &#123;</div><div class="line">    unsigned char   tcm_family;</div><div class="line">    unsigned char   tcm__pad1;</div><div class="line">    unsigned short  tcm__pad2;</div><div class="line">    int             tcm_ifindex;</div><div class="line">    __u32           tcm_handle;</div><div class="line">    __u32           tcm_parent;</div><div class="line">    __u32           tcm_info;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">linux-4.13.11@include/linux/netdevice.h</div><div class="line">/* 该结构体描述每一个网络设备 */</div><div class="line">struct net_device &#123;</div><div class="line">    </div><div class="line">    char                name[IFNAMSIZ]; //用于存放网络设备的设备名称</div><div class="line">    /* 这个字段用于构建网络设备名的哈希散列表，name_list指</div><div class="line">     * 向每个哈希散列表的链表头。</div><div class="line">     */</div><div class="line">    struct hlist_node   name_hlist;</div><div class="line">    char                *ifalias;  //网络设备的别名</div><div class="line"></div><div class="line">    //网络设备的接口索引值，独一无二的网络设备标识符</div><div class="line">    int                 ifindex;</div><div class="line">    //网络设备接口的最大传输单元</div><div class="line">    unsigned            mtu;</div><div class="line"></div><div class="line">    //网络设备接口的数据包接收队列</div><div class="line">    struct netdev_queue rx_queue;</div><div class="line">    //网络设备接口的数据包发送队列</div><div class="line">    struct netdev_queue *tx;</div><div class="line">    ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;本文主要对tc_modify_qdisc()做了注解，有错误之处请指出，还有函数tc_modify_qdisc()的最后一部分没有做注解，因为还未弄懂。</p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;tc是一个用户程序，重写并且更新Linux中的默认排队规则。它使用netlink作为用户空间与内核空间进行交互的通信信道。它添加新的排队规则、流量类别、过滤器等。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
      <category term="tc" scheme="http://yoursite.com/tags/tc/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的IP服务质量</title>
    <link href="http://yoursite.com/2018/01/09/Linux%E4%B8%AD%E7%9A%84IP%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/"/>
    <id>http://yoursite.com/2018/01/09/Linux中的IP服务质量/</id>
    <published>2018-01-09T10:43:43.000Z</published>
    <updated>2018-04-02T07:05:06.645Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Linux中的服务质量（排队规则）的基本功能是决定如何按顺序接受输入的网络报文，以及使用什么带宽速率接收，并且决定何时以及如何将报文安排进队列中并按照分配的带宽速率进行传输。它主要是根据应用程序需求管理带宽。<br><a id="more"></a><br>&emsp;&emsp;下面是Linux支持的排队规则类型：<br>&emsp;&emsp;（1）先进先出（First In First Out, FIFO）<br>&emsp;&emsp;（2）带优先级的先进先出（Priority FIFO, PFIFO）<br>&emsp;&emsp;（3）令牌通流（Token Bucket Flow, TBF）<br>&emsp;&emsp;（4）异步传输模式（Asynchronous Transfer Mode, ATM）<br>&emsp;&emsp;（5）随机早检测（Random Early Detection, RED）<br>&emsp;&emsp;（6）随机公平队列（Stochastic Fair Queueing, SFQ）<br>&emsp;&emsp;（7）可分类排队规则（Class-Bassed Queueing Discipline, CBQ）<br>&emsp;&emsp;（8）通用随机早检测（Generalized GED）</p>
<h4 id="Linux流量控制的基本组件"><a href="#Linux流量控制的基本组件" class="headerlink" title="Linux流量控制的基本组件"></a>Linux流量控制的基本组件</h4><p>&emps;&emsp;（1）排队规则（Queueing Discipline）<br>&emsp;&emsp;（2）类别（Class）<br>&emsp;&emsp;（3）过滤器/分类器（Filter/Classifier）<br>&emsp;&emsp;（4）策略（Policing）<br>&emsp;&emsp;<strong>排队规则</strong> Linux上的每个网络设备都有一个排队规则，它控制报文在传输前如何入队和出队。<br>&emsp;&emsp;<strong>类别</strong> 只有基于类的排队规则才支持类别。可以在传输网络流量之前根据过滤器（IP地址、TCP/IP端口等）将其分为不同的类别，每种类别会根据其优先级来调度报文的出队。<br>&emsp;&emsp;<strong>过滤器</strong> 过滤器根据特定参数（IP地址、TCP/IP端口等）将报文组织到不同的类别中。<br>&emsp;&emsp;<strong>策略</strong> 在将网络报文从队列中移出以后，可以对报文设置策略：发送报文、丢弃报文或者发送并标记报文。<br>&emsp;&emsp;Linux中的pfifo_fast排队规则的流程图如下图所示。<br><img src="../../../../pictures/TCP/20180110083808.png" alt=""></p>
<h4 id="Linux中pfifo-fast排队规则的实现"><a href="#Linux中pfifo-fast排队规则的实现" class="headerlink" title="Linux中pfifo_fast排队规则的实现"></a>Linux中pfifo_fast排队规则的实现</h4><p>&emsp;&emsp;pfifo_fast排队规则是Linux系统中所有网络接口的默认排队规则。pfifo_fast排队规则可以被Linux系统中的任何其他排队规则替换。pfifo_fast包含三个不同的FIFO队列，他们根据优先级将报文加入队列。最高优先级的报文进入FIFO 0，接下来依次是FIFO 1和FIFO 2。<br>&emsp;&emsp;pfifo_fast不是由用户配置的，而是默认硬编码的。报文的优先级是内核分配的，并且根据报文的TOS octet映射到适当的波段中。对于报文入队和出队，pfifo_fast排队规则使用pfifo_fast_enqueue()和pfifo_fast_dequeue()函数。</p>
<h4 id="排队规则数据结构"><a href="#排队规则数据结构" class="headerlink" title="排队规则数据结构"></a>排队规则数据结构</h4><p>&emsp;&emsp;<strong>（1）结构Qdisc</strong> struct Qdisc数据结构表示流量排队规则的一个qdisc，它与网络设备相关联。这个排队规则用于在将报文发送到Linux系统的网络接口之前的流量控制（报文排队）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">include/net/pkt_sched.h</div><div class="line"></div><div class="line">struct Qdisc </div><div class="line">&#123;</div><div class="line">    /* 指向排队规则的入队函数的函数指针。如果没有配置其他队列规则，则默认的函数</div><div class="line">     * 是pfifo_fast_enqueue。入队函数的主要作用是将sk_buff加入到调度器的恰当的</div><div class="line">     * 队列中。</div><div class="line">     */</div><div class="line">    int                 (*enqueue)(sturct sk_buff *skb, struct Qdisc *dev);</div><div class="line">    /* 指向队列规则的出队函数的函数指针。默认函数是pfifo_fast_dequeue()</div><div class="line">     * 。出队函数的主要作用是，从优先级最高的非空队列中移出报文。</div><div class="line">     */</div><div class="line">    struct sk_buff*     (*dequeue)(struct Qdisc *dev);</div><div class="line">    unsigned            flags;</div><div class="line">    ......</div><div class="line">    /* 每个排队规则都有一个用于控制其操作的函数集，Qdisc_ops数据结构包含了所有</div><div class="line">     * 这些控制函数。</div><div class="line">     */</div><div class="line">    struct Qdisc_ops    *ops;</div><div class="line">    /* Linux网络设备维护了qdisc_list，以链接所有用于设备排队的排队规则。这里，</div><div class="line">     * next指针指向设备的下一个排队规则。</div><div class="line">     */</div><div class="line">    struct Qdisc        *next;</div><div class="line">    /* 内核中有多个排队规则实例，每个排队规则实例都通过32位的数字来标识。*/</div><div class="line">    u32                 handle;</div><div class="line">    atomic_t            refcnt;</div><div class="line">    /* q表示队列的头部 */</div><div class="line">    struct sk_buff_head q;</div><div class="line">    /* 指向网络设备 */</div><div class="line">    struct net_device   *dev;</div><div class="line">    /* 表示统计，即入队的字节数与报文数、丢弃的报文数等。*/</div><div class="line">    struct tc_stats     stats;</div><div class="line">    int                 (*reshape_fail)(struct sk_buff *skb, struct Qdisc *q);</div><div class="line">    ......</div><div class="line">    struct Qdisc        *__parents;</div><div class="line">    /* 这是一个位置指针。对于默认的pfifo_fast，它指向一个sk_buff_head结构的数</div><div class="line">     * 组；对于CBQ，它指向cbq_sched_data数据结构，这个数据结构包含了用于不同队</div><div class="line">     * 列的类型。</div><div class="line">     */</div><div class="line">    char                data[0];</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>（2）结构Qdisc_ops</strong> struct Qdisc_ops数据结构提供了用于各种操作的控制函数集，这些操作在排队规则上执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">include/net/pkt_sched.h</div><div class="line"></div><div class="line">struct Qdisc_ops</div><div class="line">&#123;</div><div class="line">    /* 指向下一个Qdisc_ops，以链接所有在内核中注册的排队规则操作。*/</div><div class="line">    struct Qdisc_ops        *next;</div><div class="line">    /* 这是一个类别操作数据结构Qdisc_class_ops，它为某个特定的类别提供一个函</div><div class="line">     * 数集。</div><div class="line">     */</div><div class="line">    struct Qdisc_class_ops  *cl_ops;</div><div class="line">    /* 包含排队规则标识（例如，pfifo、cbq等）的字符数组。*/</div><div class="line">    char                    id[IFNAMSIZ];</div><div class="line">    int                     priv_size;</div><div class="line"></div><div class="line">    int                     (*enqueue)(struct sk_buff *, struct Qdisc *);</div><div class="line">    struct sk_buff *        (*dequeue)(struct Qdisc *);</div><div class="line">    /* 如果报文已经发送，但是由于未知的原因而发送失败，则requeue()</div><div class="line">     * 函数将报文放回到它原来在队列中的位置。</div><div class="line">     */</div><div class="line">    int                     (*requeue)(struct sk_buff *, struct Qdisc);</div><div class="line">    /* 从队列中删除并丢弃报文 */</div><div class="line">    int                     (*drop)(struct Qdisc *);</div><div class="line"></div><div class="line">    int                     (*init)(struct Qdisc *, struct rtattr *arg);</div><div class="line">    /* 将排队规则重新设置到初始状态 */</div><div class="line">    void                    (*reset)(struct Qdisc *);</div><div class="line">    /* 销毁在排队规则初始化期间使用的资源 */</div><div class="line">    void                    (*destroy)(struct Qdisc *);</div><div class="line">    /* 改变一个排队规则的参数值 */</div><div class="line">    int                     (*change)(struct Qdisc *, struct rtattr *arg);</div><div class="line">    /* 显示排队规则的统计信息 */</div><div class="line">    int                     (*dump)(struct Qdisc * struct sk_buff);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>（3）结构Qdisc_class_ops</strong> 这是一个类别操作数据结构，它为某个特定的类别提供了一个控制函数集。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">include/net/pkt_sched.h</div><div class="line"></div><div class="line">struct Qdisc_class_ops</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    /* 作用是将一个新的排队规则附加到一个类别上，并将之前附加的排队规则返回 */</div><div class="line">    int              (*qrqft)(struct Qdisc *, unsigned long c1, struct Qdisc</div><div class="line">                           *, struct Qdisc **);</div><div class="line">    /* 返回一个指向类别的排队规则的指针 */</div><div class="line">    struct Qdisc *   (*leaf)(struct Qdisc *, unsigned long c1);</div><div class="line">    ......</div><div class="line">    /* 返回类别的内部ID */</div><div class="line">    unsigned long    (*get)(struct Qdisc *, u32 classid);</div><div class="line">    /* 当get返回的类别不再被引用时调用该函数 */</div><div class="line">    void             (*put)(struct Qdisc *, unsigned long);</div><div class="line">    /* 改变类别的属性，也用于创建新的类别 */</div><div class="line">    int              (*change)(struct Qdisc *, u32, u32, struct rtattr **, </div><div class="line">                           unsigned long *);</div><div class="line">    /* 删除一个类别 */</div><div class="line">    int              (*delete)(struct Qdisc *, unsigned long);</div><div class="line">    /* 遍历一个排队规则上所有的类别，用于获取所有类别的诊断数据 */</div><div class="line">    void             (*walk)(struct Qdisc *, struct qdisc_walker *org);</div><div class="line">    ......</div><div class="line">    /* 返回指向类别的过滤器列表的指针，用于管理过滤器列表 */</div><div class="line">    struct tcf_proto ** (*tcf_chain)(struct Qdisc *, unsigned long);</div><div class="line">    /* 绑定一个过滤器实例到类别 */</div><div class="line">    unsigned long    (*bind_tcf)(struct Qdisc *, unsigned long, u32 classid);</div><div class="line">    /* 从类别中删除一个过滤器实例 */</div><div class="line">    void             (*unbind_tcf)(struct Qdisc *, unsigned long);</div><div class="line">    ......</div><div class="line">    /* 返回类别的统计信息 */</div><div class="line">    int              (*dump)(struct Qdisc *, unsigned long, struct sk_buff </div><div class="line">                          *skb, struct tcmsg*);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>（4）结构cbq_class</strong> 该数据结构表示cbq排队规则的流量类型，用于根据为类型分配的带宽调度报文。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">net/sched/sch_cbq.c</div><div class="line"></div><div class="line">struct cbq_class</div><div class="line">&#123;</div><div class="line">    /* 指向类别中cbq_class中下一个类别 */</div><div class="line">    struct cbq_class     *next;</div><div class="line">    /* cbq调度算法维护了活动的流量类别类型，用于根据优先级调度类别*/</div><div class="line">    struct cbq_class     *next_alive;</div><div class="line">    ......</div><div class="line">    /* 在cbq排队规则中每个类别都通过一个编号（id）来表示。这个域包含了一个cbq类</div><div class="line">     *别的唯一编号。</div><div class="line">     */</div><div class="line">    u32                  classid;</div><div class="line">    /* 这个域包含了类别优先级，它用于调度cbq类别 */</div><div class="line">    unsigned char        priority;</div><div class="line">    /* 这个域包含了overtime之后使用的类别优先级。一个cbq类别有三种类型：</div><div class="line">     * overtime、underlimit和atlimit。</div><div class="line">     */</div><div class="line">    unsigned char        priority2;</div><div class="line">    /* 这个域用于计算空闲时间，计算是在cbq调度函数中指定的 */</div><div class="line">    unsigned char        ewma_log;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Linux中的服务质量（排队规则）的基本功能是决定如何按顺序接受输入的网络报文，以及使用什么带宽速率接收，并且决定何时以及如何将报文安排进队列中并按照分配的带宽速率进行传输。它主要是根据应用程序需求管理带宽。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>延时确认定时器</title>
    <link href="http://yoursite.com/2018/01/03/TCP%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/03/TCP定时器（四）/</id>
    <published>2018-01-03T02:59:58.000Z</published>
    <updated>2018-04-02T07:05:24.882Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;TCP实现了两种确认模式：<br>&emsp;&emsp;快速确认<br>&emsp;&emsp;延时确认<br>&emsp;&emsp;在有些情况下，我们需要快速地得到ACK，以便于发送端在接收到ACK后，发出更多的数据，其原因是每个新数据的确认都会导致拥塞窗口加1。另外一些需要得到快速确认的情况是接收到乱序分段时，或者所接收数据的断档被填补时。也有一些情况需要延时确认，在这些情况中，会话是交互式的，如telnet、rlogin等，所要键入的每个字符都要回送。在这种情况下，如果为每个分段（只包含一个字符）生成确认，这将在网络中生成大量的报文。<br><a id="more"></a><br>&emsp;&emsp;Linux在struct ack结构中维护所有ACK相关的信息，它是struct_opt结构的一部分。源码如下：<br>include/net/sock.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct &#123;</div><div class="line">    __u8 pending; //表示任何给定时刻ACK的状态</div><div class="line">    __u8 quick; //</div><div class="line">    __u8 pingpong; //会话是交互式的</div><div class="line">    __u8 blocked; //延迟ACK被套接字锁阻塞</div><div class="line">    __u32 ato; //软时钟的预测滴答数</div><div class="line">    unsigned long timeout; //当前调度超时</div><div class="line">    __u32 lrcvtime; //收到最后一个数据包的时间戳</div><div class="line">    __u16 last_seq_size; //最后一个到来分段的大小</div><div class="line">    __u16 rcv_mss; //MSS用于延迟ACK决策</div><div class="line">&#125;ack;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;TCP ACK的状态有三个，源码如下：<br>include/net/tcp.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum tcp_ack_state_t</div><div class="line">&#123;</div><div class="line">    TCP_ACK_SCHED = 1; //表示调度了ACK</div><div class="line">    TCP_ACK_TIMER = 2; //表示已经安装了延时确认定时器</div><div class="line">    TCP_ACK_PUSHED = 4; //表示ACK需要尽早被发送出去</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="ACK的调度时机"><a href="#ACK的调度时机" class="headerlink" title="ACK的调度时机"></a>ACK的调度时机</h4><p>&emsp;&emsp;一旦从对等端得到数据，就需要调度ACK。调用tcp_schedule_ack()来设置TCP_ACK_SCHED标志。从tcp_rcv_established()和tcp_data_queue()中调用tcp_event_data_recv()接收数据时，都要调度ACK。<br>include/net/tcp.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static inline void tcp_schedule_ack(struct tcp_opt *tp)</div><div class="line">&#123;</div><div class="line">    tp-&gt;ack.pending |= TCP_ACK_SCHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;调用tcp_schedule_ack()可以调度一个ACK，但是不能基于该标志来强制发送ACK。ACK是立即发送还是延迟一段时间发送需要满足一定的条件。<br>net/ipv4/tcp_input.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">int tcp_rcv_established(struct sock *sk, struct sk_buff *skb, </div><div class="line">    struct tcphdr *th, unsigned len)</div><div class="line">&#123;</div><div class="line">    struct tcp_opt *tp = &amp;(sk-&gt;pinfo.af_tcp);</div><div class="line">    ......</div><div class="line">        if (eaten) &#123;</div><div class="line">            /* 检查是否处于快速ACK模式 */</div><div class="line">            if (tcp_in_quickack_mode(tp)) &#123;</div><div class="line">                /* 如果是，就立即生成ACK */</div><div class="line">                tcp_send_ack(sk);</div><div class="line">            &#125; else &#123;</div><div class="line">                /* 否则推迟一段时间 */</div><div class="line">                tcp_send_delayed_ack(sk);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; else &#123;</div><div class="line">            /* 如果应用程序没有读取数据，而是在接受对中排队，</div><div class="line">             * 就调用__tcp_ack_snd_check()做更严格的检查。</div><div class="line">             */</div><div class="line">            __tcp_ack_snd_check(sk, 0);</div><div class="line">        &#125;</div><div class="line">    ......</div><div class="line">    tcp_ack_snd_check(sk);</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;TCP实现了两种确认模式：&lt;br&gt;&amp;emsp;&amp;emsp;快速确认&lt;br&gt;&amp;emsp;&amp;emsp;延时确认&lt;br&gt;&amp;emsp;&amp;emsp;在有些情况下，我们需要快速地得到ACK，以便于发送端在接收到ACK后，发出更多的数据，其原因是每个新数据的确认都会导致拥塞窗口加1。另外一些需要得到快速确认的情况是接收到乱序分段时，或者所接收数据的断档被填补时。也有一些情况需要延时确认，在这些情况中，会话是交互式的，如telnet、rlogin等，所要键入的每个字符都要回送。在这种情况下，如果为每个分段（只包含一个字符）生成确认，这将在网络中生成大量的报文。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>零窗口探测定时器</title>
    <link href="http://yoursite.com/2018/01/02/TCP%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/02/TCP定时器（三）/</id>
    <published>2018-01-02T10:23:59.000Z</published>
    <updated>2018-04-02T07:05:06.514Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;接收端TCP在接受缓冲区满时，通告零窗口一旦应用程序从接受缓冲区中读取数据，就检查是否在接受缓冲区中释放了足够的空间，以向发送端通告新窗口。如果是，就发出通告新窗口的ACK分段。如果该分段丢失，在仅有单向数据流动时，很可能会导致发送端和接收端之间产生死锁。为了避免这种情况发生，发送端实现了零窗口探测定时器。<br><a id="more"></a></p>
<h4 id="首次安装探测定时器的时机"><a href="#首次安装探测定时器的时机" class="headerlink" title="首次安装探测定时器的时机"></a>首次安装探测定时器的时机</h4><p>&emsp;&emsp;当要传输新分段时，需要在很多地方做检查：<strong>tcp_push_pending_frames()、tcp_data_snd_check()。</strong>tcp_push_pending_frames()在将数据从应用程序发往套接字传输队列时调用，tcp_data_snd_check()在从对等段接收到分段时调用。这些函数检查是否能够发出新分段，如果不能，就调用tcp_check_probe_timer()检查是否接收窗口不允许数据分段发送而引发的。tcp_check_probe_timer()检查是否没有未确认数据（!tp-&gt;packets_out）且没有安装定时器（!tp-&gt;pending）。源码如下：<br>include/net/tcp.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static __inline__ </div><div class="line">void tcp_check_probe_timer(struct sock *sk, struct tcp_opt *tp)</div><div class="line">&#123;   </div><div class="line">    /* 检查是否有未确认数据且没有安装定时器 */</div><div class="line">    if (!tp-&gt;packets_out &amp;&amp; !tp-&gt;pending)</div><div class="line">        /* 设置零窗口定时器的超时值为tp-&gt;rto */</div><div class="line">        tcp_reset_xmit_timer(sk, TCP_TIME_PROBE0, tp-&gt;rto);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="取消连接探测定时器的时机"><a href="#取消连接探测定时器的时机" class="headerlink" title="取消连接探测定时器的时机"></a>取消连接探测定时器的时机</h4><p>&emsp;&emsp;当在tcp_ack()中处理输入ACK时，我们要检查这是否是一个有效的ACK，同时还有没有未确认的数据。如果是一个有效ACK，且有未确认的数据，那么可以判断这可能是窗口更新或者零窗口探测而引发的ACK。于是需要处理窗口更新，首先清除探测计数器（tp-&gt;probes_out），此外，如果还有任何待传输的新分段（tp-&gt;send_head != NULL），就调用tcp_ack_probe()来做进一步处理。源码如下：<br>net/ipv4/tcp_input.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void tcp_ack_probe(struct sock *sk)</div><div class="line">&#123;</div><div class="line">    struct tcp_opt *tp = &amp;(sk-&gt;tp_pinfo.af_tcp);</div><div class="line">    ......</div><div class="line">    /* 检查下一要传输的分段是否位于对等端所打开的窗口内 */</div><div class="line">    if (!after(TCP_SKB_CB(tp-&gt;send_head)-&gt;end_seq, tp-&gt;snd_una + tp-&gt;snd_wnd)) &#123;</div><div class="line">        tp-&gt;backoff = 0;</div><div class="line">        /* 如果传输队列头的结束序列号（tp-&gt;send_head）位于所打开窗口序</div><div class="line">         * 列空间内，就可以调用tcp_clear_xmit_timer()来停止零窗口探测。</div><div class="line">         */</div><div class="line">        tcp_clear_xmit_timer(sk, TCP_TIME_PROBE0);</div><div class="line">        ......</div><div class="line">    &#125; else &#123;</div><div class="line">        /* 否则，表示没有足够的空间来容纳传输队列头中的全部数据，因此，重置</div><div class="line">         * 有tp-&gt;rto和tp-&gt;backoff控制的定时器超时值，以继续零窗口探测。</div><div class="line">         */</div><div class="line">        tcp_reset_xmit_timer(sk, TCP_TIME_PROBE0, min(tp-&gt;rto &lt;&lt; tp-&gt;backoff, TCP_RTO_MAX));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="窗口探测定时器的工作原理"><a href="#窗口探测定时器的工作原理" class="headerlink" title="窗口探测定时器的工作原理"></a>窗口探测定时器的工作原理</h4><p>&emsp;&emsp;重传定时器和窗口探测定时器有一个公共的定时器回调函数，即tcp_write_timer()。tcp_write_timer()根据tp-&gt;pending标志来决定所要调用的函数。在任何时刻，只能安装一个定时器，也就是说，重传定时器或者窗口探测定时器。当窗口探测定时器超时时，需要调用tcp_probe_timer()来传输零窗口探测分段。源码如下：<br>net/ipv4/tcp_timer.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">static void tcp_probe_timer(struct sock *sk)</div><div class="line">&#123;</div><div class="line">    struct tcp_opt *tp = &amp;sk-&gt;tp_pinfo.af_tcp;</div><div class="line">    int max_probes;</div><div class="line"></div><div class="line">    /* 检查是否有未确认数据，如果tp-&gt;packets_out大于1，就意味着安装了零窗口探测</div><div class="line">     * 定时器后，已传输了一些新分段。第二个条件检查是否有要传输的新分段，如果没</div><div class="line">     * 有新数据要传输，就没有必要安装窗口探测器了。</div><div class="line">     */</div><div class="line">    if (tp-&gt;packets_out || !tp-&gt;send_head) &#123;</div><div class="line">        tp-&gt;probes_out = 0;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    max_probes = sysctl_tcp_retries2;</div><div class="line">    /* 检查与连接相关联的套接字是否已经死亡，如果是，就检查是否可以放弃该连接*/</div><div class="line">    if (sk-&gt;dead) &#123;</div><div class="line">        int alive = ((tp-&gt;rto &lt;&lt; tp-&gt;backoff) &lt; TCP_RTO_MAX);</div><div class="line">        ......</div><div class="line">        /* 检查是否可以立即放弃该连接。如果TCP套接字已经处于死亡状态，就需要根</div><div class="line">         * 据系统中孤立套接字的总量来对死亡套接字做出某种操作，也就是说，如果连</div><div class="line">         * 接很长时间内没有任何操作，就确认立即关闭该连接，以释放所占用的资源。</div><div class="line">         */</div><div class="line">        if (tcp_out_of_resources(sk, alive || tp-&gt;probes_out &lt;= max_probes))</div><div class="line">            return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* 检查探测次数是否超出了系统级控制参数 */</div><div class="line">    if (tp-&gt;probes_out &gt; max_probes) &#123;</div><div class="line">        /* 如果是，就放弃该连接 */</div><div class="line">        tcp_write_err(sk);</div><div class="line">    &#125; else &#123;</div><div class="line">        /* 否则发出零窗口探测 */</div><div class="line">        tcp_send_probe0(sk);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;接收端TCP在接受缓冲区满时，通告零窗口一旦应用程序从接受缓冲区中读取数据，就检查是否在接受缓冲区中释放了足够的空间，以向发送端通告新窗口。如果是，就发出通告新窗口的ACK分段。如果该分段丢失，在仅有单向数据流动时，很可能会导致发送端和接收端之间产生死锁。为了避免这种情况发生，发送端实现了零窗口探测定时器。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TCP重传定时器</title>
    <link href="http://yoursite.com/2018/01/02/TCP%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/02/TCP定时器（二）/</id>
    <published>2018-01-02T07:21:20.000Z</published>
    <updated>2018-04-02T07:05:06.470Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;TCP重传定时器是TCP状态机的一部分，用来检查网络拥塞/数据丢失。TCP就其所接收到的每个字节发出确认，一次来维护数据完整性。发送端根据确认报文中的时间戳选型来计算RTT（往返时间），然后根据RTT计算重传超时时间。<br><a id="more"></a><br>&emsp;&emsp;当发出窗口中的第一个分段时，就需要安装一个重传定时器，超时时间为一个RTO。这确保TCP在分段发送后的RTO时间内收到ACK，如果没有得到确认，重传定时器就超时，据此判断出所有窗口中的数据都已丢失。</p>
<h4 id="安装重传定时器的时机"><a href="#安装重传定时器的时机" class="headerlink" title="安装重传定时器的时机"></a>安装重传定时器的时机</h4><p>&emsp;&emsp;传输当前窗口的第一个报文时就需要安装重传定时器。packet_out记录了已经传输但还没确认的报文，一旦传输一个新的报文，就要将packet_out加一。在传输结束后，检查packet_out是否为零，如果是，就启动重传定时器在tp-&gt;rto时间后超时。<br>net/ipv4/tcp_output.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static __inline__ </div><div class="line">void update_send_head(struct sock *sk, struct tcp_opt *tp, struct sk_buff *skb)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    /* tcp_write_xmit()在成功传输完第一个分段后，将调用updata_send_head()</div><div class="line">     * 重置第一个分段的重传定时器。</div><div class="line">     */</div><div class="line">    if (tp-&gt;packets_out++ == 0)</div><div class="line">        tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp-&gt;rto); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="重置或取消重传定时器的时机"><a href="#重置或取消重传定时器的时机" class="headerlink" title="重置或取消重传定时器的时机"></a>重置或取消重传定时器的时机</h4><p>&emsp;&emsp;每收到一个ACK，TCP都要重置重传定时器，该ACK通告了一个发送窗口，调用顺序是tcp_ack()-&gt;tcp_clean_rtx_queue()调用tcp_ack_packets_out()。源码如下：<br>net/ipv4/tcp_output.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static __inline__ void tcp_ack_packets_out(struct sock *sk, struct tcp_opt *tp)</div><div class="line">&#123;</div><div class="line">    /* 如果所有分段都收到确认，就删除重传定时器 */</div><div class="line">    if (tp-&gt;packets_out == 0) &#123;</div><div class="line">        tcp_clear-xmit_timer(sk, TCP_TIME_RETRANS);</div><div class="line">    /* 否则重置重传定时器 */</div><div class="line">    &#125; else &#123;</div><div class="line">        tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp-&gt;rto);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在丢失恢复过程中传输分段时，如果在tcp_xmit_retransmit_queue()中重新传输重传队列的第一个分段，就重置重传定时器。重传定时器不仅仅考虑重传，还要调整超时值、重置路由、检查重试次数是否超出了限度等。<br>net/ipv4/tcp_output.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">static void tcp_retransmit_timer(struct sock *sk)</div><div class="line">&#123;</div><div class="line">    struct tcp_opt *tp = &amp;sk-&gt;tp_pinfo.af_tcp;</div><div class="line">    /* 乳沟没有报文传输，就返回，表示没有要重传的分段 */</div><div class="line">    if (tp-&gt;packets_out == 0)</div><div class="line">        goto out;</div><div class="line">    ......</div><div class="line">    /* 检查发送窗口是否关闭，套接字是否仍然活跃 */</div><div class="line">    if (tp-&gt;snd_wnd == 0 &amp;&amp; !sk-&gt;dead &amp;&amp; </div><div class="line">        !(1 &lt;&lt; sk-&gt;state)&amp;(TCPF_SYN_SENT|TCPF_SYN_RECV)) &#123;</div><div class="line">            ......</div><div class="line">            /* 如果超过了TCP_RTO_MAX的时间后还没有收到ACK，就需要设置该连接为超</div><div class="line">             * 时。</div><div class="line">             */</div><div class="line">            if (tcp_time_stamp - tp-&gt;rcv_tstamp &gt; TCP_RTO_MAX) &#123;</div><div class="line">                tcp_write_err(sk);</div><div class="line">                goto out;</div><div class="line">            &#125;</div><div class="line">            /* 如果该连接没有超时，就进入慢启动表示进入报文丢失状态 */</div><div class="line">            tcp_entry_loss(sk, 0);</div><div class="line">            /* 重新传输重传队列的头部 */</div><div class="line">            tcp_retransmit_skb(sk, skb_peek(&amp;sk-&gt;write_queue));</div><div class="line">            /* 使目的地址失效 */</div><div class="line">            __sk_dst_reset(sk);</div><div class="line">            /* 无法与对等端通信时，会导致窗口无法更新，这时会产生替代路由 */</div><div class="line">            goto out_reset_timer;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* 检查是否已超出重传次数 */</div><div class="line">        if (tcp_write_timeout(sk))</div><div class="line">            goto out;</div><div class="line">            ......</div><div class="line">        /* 表示没有超出重传次数，进入慢启动阶段 */</div><div class="line">        tcp_entry_loss(sk, 0);</div><div class="line"></div><div class="line">        /* 返回值大于0表示重传失败 */</div><div class="line">        if (tcp_retransmit_skb(sk, skb_peek(&amp;sk-&gt;write_queue)) &gt; 0) &#123;</div><div class="line">            /* tp-&gt;retransmits记录了重传丢失分段的次数 */</div><div class="line">            if (!tp-&gt;retransmits)</div><div class="line">                tp-&gt;retransmits = 1;</div><div class="line">            /* 重置重传定时器为rto和TCP_RESOURCE_PROBE_INTERVAL的较小值 */</div><div class="line">            tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, </div><div class="line">                min(tp-&gt;rto, TCP_RESOURSE_INTERVAL));</div><div class="line">            goto out;</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        /* 表示成功传输了丢失的分段 */</div><div class="line">        tp-&gt;backoff++;</div><div class="line">        tp-&gt;retransmits++;</div><div class="line"></div><div class="line">out_reset_timer:</div><div class="line">        /* 超时值取tp-&gt;rto和TCP_RTO_MAX中的较小值 */</div><div class="line">        tp-&gt;rto = min(tp-&gt;rto&lt;&lt;1, TCP_RTO_MAX);</div><div class="line">        /* 重置重传定时器 */</div><div class="line">        tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp-&gt;rto);</div><div class="line">        /* 检查重传最大次数是否超出了路由复位的次数 */</div><div class="line">        if (tp-&gt;retransmits &gt; sysctl_tcp_retries1)</div><div class="line">            __sk_dst_reset(sk);</div><div class="line"></div><div class="line">out:;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;连接超时有4个系统控制参数：<br>&emsp;&emsp;sysctl_tcp_retries1<br>&emsp;&emsp;sysctl_tcp_retries2<br>&emsp;&emsp;sysctl_tcp_syn_retries<br>&emsp;&emsp;sysctl_tcp_orphan_retries<br>&emsp;&emsp;sysctl_tcp_retries1是最大重传次数，超出该次数之后，要检查中间路由器是否失效。sysctl_tcp_retries2是分段重传的最大尝试次数，超出重试次数后，将放弃该连接。sysctl_tcp_syn_retries是重传SYN分段的最大尝试次数，在此之后，将放弃重试。sysctl_tcp_orphan_retries是孤立套接字的最大重试次数。</p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;TCP重传定时器是TCP状态机的一部分，用来检查网络拥塞/数据丢失。TCP就其所接收到的每个字节发出确认，一次来维护数据完整性。发送端根据确认报文中的时间戳选型来计算RTT（往返时间），然后根据RTT计算重传超时时间。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的定时器</title>
    <link href="http://yoursite.com/2018/01/02/TCP%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/02/TCP定时器（一）/</id>
    <published>2018-01-01T17:55:01.000Z</published>
    <updated>2018-04-02T07:05:24.958Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;TCP是一个事件驱动的状态机。TCP为实现可靠的传输，主要定义并实现了以下定时器：重传定时器、延时确认定时器、零窗口探测定时器（持久定时器）、keepalive定时器、TIME_WAIT定时器、SYN-ACK定时器（监听套接字定时器）。<br><a id="more"></a><br>&emsp;&emsp;重传定时器、延时确认定时器和零窗口探测定时器是TCP状态机核心实现的一部分。keepalive定时器用来管理已建立的连接。TIME_WAIT定时器用来管理关闭的连接，并等待2*MSL后超时。SYN-ACK定时器用来管理新连接请求。TCP提供了如下三个函数来管理这些定时器：<br>&emsp;&emsp;tcp_reset_xmit_timeer()<br>&emsp;&emsp;tcp_reset_keepalive_timer()<br>&emsp;&emsp;tcp_clear_xmit_timer()<br>&emsp;&emsp;tcp_reset_xmit_timer()是用来重置TCP状态机定时器的通用函数。tcp_reset_keepalive_timer()是重置连接管理定时器的接口，如keepalive定时器和SYN-ACK定时器。tcp_clear_xmit_timer()用来清楚或删除已安装的TCP定时器。</p>
<h3 id="Linux中的定时器"><a href="#Linux中的定时器" class="headerlink" title="Linux中的定时器"></a>Linux中的定时器</h3><p>&emsp;&emsp;Linxu实现定时器的数据结构是struct timer_list，源码如下：<br>include/linux/timer.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct timer_list &#123;</div><div class="line">    /* list指向列表头的指针，这时定时器所在的位置 */</div><div class="line">    struct list_head list;</div><div class="line">    /* 存储定时器启动所需的时钟周期数 */</div><div class="line">    unsigned long expires;</div><div class="line">    /* 包含传递给定时器回调函数的参数 */</div><div class="line">    unsigned long data;</div><div class="line">    /* 定时器超时时，所需要执行的回调函数 */</div><div class="line">    void (*functian) (unsigned long);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="mod-timer"><a href="#mod-timer" class="headerlink" title="mod_timer()"></a>mod_timer()</h4><p>&emsp;&emsp;当需要修改定时器的超时时间时，就需要调用mod_timer()，源码如下：<br>kernel/timer.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int mod_timer(struct time_list *timer, unsigned long expires)</div><div class="line">&#123;</div><div class="line">    int ret;</div><div class="line">    unsigned long flags;</div><div class="line">    /* 修改定时器的expires域要获取全局定时器旋转锁timerlist_lock */</div><div class="line">    spin_lock_irqsave(&amp;timertlist_lock, flags);</div><div class="line">    timer-&gt;expires = expires;</div><div class="line">    /* 将已安装定时器从全局列表中删除 */</div><div class="line">    ret = detach_timer(timer);</div><div class="line">    /* 在全局列表中添加定时器 */</div><div class="line">    internal_add_timer(timer);</div><div class="line">    spin_unlockirqrestore(&amp;timerlist_lock, flags);</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="detach-timer"><a href="#detach-timer" class="headerlink" title="detach_timer()"></a>detach_timer()</h4><p>&emsp;&emsp;该函数将已安装的定时器从全局列表中分离，源码如下：<br>kernel/timer.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static inline int detach_timer()</div><div class="line">&#123;</div><div class="line">   /* timer_pending()函数检查定时器是否安装在全局列表中，如果没有安装，那么定</div><div class="line">    * 时器列表头的next域为NULL，直接返回0. </div><div class="line">    */</div><div class="line">   if (!timer_pending(timer));</div><div class="line">       return 0;</div><div class="line">   /* 如果已经安装，那么调用list_del()将已安装定时器从全局列表中分离 */</div><div class="line">   list_del(&amp;timer-&gt;list);</div><div class="line">   return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="del-timer"><a href="#del-timer" class="headerlink" title="del_timer()"></a>del_timer()</h4><p>&emsp;&emsp;当要求取消某定时器时，首先调用timer_pending()来检查该定时器是否安装。如果定时器已经安装，就调用del_timer()从列表中删除定时器，将定时器从全局列表中删除的操作需要获取全局宣转锁timerlist_lock。源码如下：<br>kernel/timer.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int del_timer(struct timer_list *timer)</div><div class="line">&#123;</div><div class="line">    int ret;</div><div class="line">    unsigned long flags;</div><div class="line"></div><div class="line">    spin_lock_irqsave(&amp;timertlist_lock, flags);</div><div class="line">    /* 调用detach_timer()来从全局列表中分离该定时器 */</div><div class="line">    ret = detach-timer(timer);</div><div class="line">    /* 将定时器列表头的next和previous域置为NULL */</div><div class="line">    timer-&gt;list.next = timer-&gt;list.prev = NULL;</div><div class="line">    spin_unlockirqrestore(&amp;timerlist_lock, flags);</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="执行定时器函数的时机"><a href="#执行定时器函数的时机" class="headerlink" title="执行定时器函数的时机"></a>执行定时器函数的时机</h4><p>&emsp;&emsp;定时器中断每10ms一次，也就是说，一个时钟周期产生一次。该中断通过从do_timer()调用mark_bh()来产生软中断处理定时器。调用mark_bh()要传递bh_task_vec[]中的偏移量，mark_bh()调用tasklet_hi_schedule()来调度bh_task_vec[TIMER_BH]所指向的任务。在此要首先检查是否已经调度了该任务，如果该任务还没有调度，就调度<strong>tasklet_hi_schedule()来调度它，这可以保证一个任务仅在一个CPU上调度，同样的任务不能也不能在同一个CUP上调用两次。</strong>tasklet_hi_schedule()将在当前的CPU上调度该定时器任务。在每个CPU的tasklet_hi_vec[cpu].list列表中添加任务，然后产生HI_SOFTIRQ软中断。<br>kernel/timer.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void __tasklet_hi_schedule(struct tasklet_struct *t)</div><div class="line">&#123;</div><div class="line">    int cpu = smp_processor_id();</div><div class="line">    unsigned long flags;</div><div class="line"></div><div class="line">    local_irq_save(flags);</div><div class="line">    t-&gt;next = tasklet_hi_vec[cpu].list;</div><div class="line">    tasklet_hi_vec[cpu].list = t;</div><div class="line">    cpu_raise_softirq(cpu, HI_SOFTIRQ);</div><div class="line">    local_irq_restore(flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>参考文献</strong>：<br><a href="https://aavmqxaxn.updog.co/YWF2bXF4YXhuMDQ3MDE0NzczMw.pdf" target="_blank" rel="external">TCP/IP架构、设计及应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;TCP是一个事件驱动的状态机。TCP为实现可靠的传输，主要定义并实现了以下定时器：重传定时器、延时确认定时器、零窗口探测定时器（持久定时器）、keepalive定时器、TIME_WAIT定时器、SYN-ACK定时器（监听套接字定时器）。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TCP接收</title>
    <link href="http://yoursite.com/2017/12/31/TCP%E6%8E%A5%E6%94%B6/"/>
    <id>http://yoursite.com/2017/12/31/TCP接收/</id>
    <published>2017-12-31T01:52:31.000Z</published>
    <updated>2018-04-10T10:17:21.860Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;应用程序向内核发出请求，从TCP套接字接收正常或者紧急数据。内核套接字实现必须区分这两种不同类型的请求。当应用程序希望接收一个紧急字节的OOB数据时，它必须选择合适的时机已读取数据；否则可能会导致数据丢失。<br>&emsp;&emsp;TCP将数据看做是字节流，TCP接受缓冲区仅排列按序收到的字节，乱序数据则进入另外一个队列，并且来自该队列的数据不能响应应用程序请求。<br><a id="more"></a></p>
<h4 id="排队机制"><a href="#排队机制" class="headerlink" title="排队机制"></a>排队机制</h4><p>&emsp;&emsp;接收输入TCP报文时，有三个队列：<br>&emsp;&emsp;（1）待处理队列（sk-&gt;backlog）；<br>&emsp;&emsp;（2）预排队队列（tp-&gt;ucopy.prequeue）；<br>&emsp;&emsp;（3）接受队列（sk-&gt;receive_queue）；<br>&emsp;&emsp;sk-&gt;receive_queue包含了处理过的TCP数据包，也就是说，去除了全部的协议头，正准备将数据复制到用户应用程序。sk-&gt;receive_queue包含了所有按顺序接收的数据段，在其他两个队列中的TCP数据段则需要进一步处理。<br>&emsp;&emsp;TCP报文首先由tcp_v4_rcv()进行处理。该函数要决定是否需要处理报文或者在backlog和prequeue队列中排队。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@kernel version 4.10.13 /net/ipv4/tcp_ipv4.c</div><div class="line">int tcp_v4_rcv(struct sk_buff *skb)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    bh lock_sock(sk); //获取套接字旋转锁</div><div class="line">    ret = 0;</div><div class="line">    </div><div class="line">    if (!sk-&gt;lock.users) &#123; //检查套接字是否处于使用状态</div><div class="line">        if (!tcp_prequeue(sk, skb))</div><div class="line">            ret = tcp_v4_do_rav(sk, skb);</div><div class="line">    &#125; else </div><div class="line">        /* 如果套接字处于使用状态，就将数据包放入待处理队列 */</div><div class="line">        sk_add_backlog(sk, skb);</div><div class="line">    bh_unlock_sock(sk);</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;应用程序向内核发出请求，从TCP套接字接收正常或者紧急数据。内核套接字实现必须区分这两种不同类型的请求。当应用程序希望接收一个紧急字节的OOB数据时，它必须选择合适的时机已读取数据；否则可能会导致数据丢失。&lt;br&gt;&amp;emsp;&amp;emsp;TCP将数据看做是字节流，TCP接受缓冲区仅排列按序收到的字节，乱序数据则进入另外一个队列，并且来自该队列的数据不能响应应用程序请求。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>构建和解析协议层的协议头</title>
    <link href="http://yoursite.com/2017/12/29/%E6%9E%84%E5%BB%BA%E5%92%8C%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%A4%B4/"/>
    <id>http://yoursite.com/2017/12/29/构建和解析协议层的协议头/</id>
    <published>2017-12-29T07:06:24.000Z</published>
    <updated>2018-04-02T07:11:47.916Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在上一篇博客说了sk_buff和协议头，这里说下如何构建向下遍历协议层时的协议头和解析向上遍历协议层时的协议头。<br><a id="more"></a></p>
<h3 id="构建向下遍历协议层时的协议头"><a href="#构建向下遍历协议层时的协议头" class="headerlink" title="构建向下遍历协议层时的协议头"></a>构建向下遍历协议层时的协议头</h3><h4 id="TCP头的添加"><a href="#TCP头的添加" class="headerlink" title="TCP头的添加"></a>TCP头的添加</h4><p><img src="../../../../pictres/TCP/20171229154204.png" alt=""><br>&emsp;&emsp;在TCP载荷（skb-&gt;data）前面添加TCP协议头，TCP调用tcp_transmit_skb()来为TCP数据构建一个TCP头。首先计算TCP头的长度，要考虑当前TCP连接所使用的TCP选项。一旦完成该操作，就需要调用skb_push()来为TCP头分配空间，该函数将data指针向head指针方向移动TCP头所请求的长度。如上图所示，当skb_push()返回时，skb-&gt;h.th将指向skb-&gt;data。下面是分配TCP头的源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">net/ipv4/tcp_output.c</div><div class="line"></div><div class="line">        if (sysctl_tcp_window_scaling) &#123;</div><div class="line">            tcp_header_size += TCPOLEN_WSCALE_ALLGNED;</div><div class="line">            sysctl_flags |= SYSCTL_FLAG_WSCALE;</div><div class="line">        &#125;</div><div class="line">    ......</div><div class="line">    /* 调用skb_push()来为TCP头分配空间 */</div><div class="line">    th = (struct tcphdr *) skb_push(skb, tcp_header_size);</div><div class="line">    /* 将skb-&gt;h.th指向skb-&gt;data */</div><div class="line">    skb-&gt;h.th = th;</div><div class="line">    ......</div><div class="line">    th-&gt;source = sk-&gt;sport; //指向源端口</div><div class="line">    th-&gt;dest   = sk-&gt;dport; //指向目的端口</div><div class="line">    th-&gt;seg    = htonl(tcb-&gt;seq);</div></pre></td></tr></table></figure></p>
<h4 id="IP头的添加"><a href="#IP头的添加" class="headerlink" title="IP头的添加"></a>IP头的添加</h4><p><img src="../../../../pictures/TCP/20171229154141.png" alt=""><br>&emsp;&emsp;当添加完TCP头后，报文会被传递给IP层，这时IP层会调用ip_build_and_pkt()构建自己的IP头，并添加到报文的起始处（skb-&gt;data之前），然后发送给链路层。处理过IP选项后，接下来会计算IP头的长度，然后调用skb_push()为IP头分配空间，该函数返回skb-&gt;data指针。源代码如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">net/ipv4/tcp_output.c</div><div class="line"></div><div class="line">int in_build_and_send_pkt(struct sk_buff *skb, struct sock *sk, u32 saddr, u32 daddr, struct ip_options *opt)</div><div class="line">&#123;</div><div class="line">    struct rtable *rt = (struct rtable *)skb-&gt;dst;</div><div class="line">    struct iphdr *iph;</div><div class="line">    /* 有选项的话，加上选项长度 */</div><div class="line">    if (opt)</div><div class="line">        iph=(struct iphdr *)skb_push(skb, sizeof(struct iphdr) + opt-&gt;sptlen);</div><div class="line">    else //没有选项，就只需加上IP头长度</div><div class="line">        iph=(struct iphdr *)skb-&gt;push(skb, sizeof(struct iphdr));</div><div class="line">    iph-&gt;version = 4; //表示IPV4</div><div class="line">    iph-&lt;ihl     = 5;</div><div class="line">    iph-&gt;tos     = sk-&gt;protinfo.af_mettos; //数据包的类型</div><div class="line">    ......</div><div class="line">    /* 使用skb-&gt;nh.iph指向skb-&gt;data*/</div><div class="line">    skb-&gt;nh.iph  = iph;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="链路层头的添加"><a href="#链路层头的添加" class="headerlink" title="链路层头的添加"></a>链路层头的添加</h4><p><img src="../../../../pictures/TCP/20171229165915.png" alt=""><br>&emsp;&emsp;添加完TCP头和IP头后，报文会被传递到链路层，接下来会调用eth_header()添加MAC头。eth_header()将data指针向head指针推进ETH_HLEN字节。访问skb-&gt;data所指向的以太网头起始位置，并在此位置构建以太网头。下面是源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int eth_header(struct sk_buff *skb, struct net_device *dev, unsigned short type, void *daddr, void *asddr, unsigned len)</div><div class="line">&#123;</div><div class="line">    /* ETH_HLEN为链路层头的长度 */</div><div class="line">    struct ethhdr *eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解析向上遍历协议层时的协议头"><a href="#解析向上遍历协议层时的协议头" class="headerlink" title="解析向上遍历协议层时的协议头"></a>解析向上遍历协议层时的协议头</h3><h4 id="sk-buff指向链路层驱动要处理的链路层头"><a href="#sk-buff指向链路层驱动要处理的链路层头" class="headerlink" title="sk_buff指向链路层驱动要处理的链路层头"></a>sk_buff指向链路层驱动要处理的链路层头</h4><p><img src="../../../../pictures/TCP/20171229191911.png" alt=""><br>&emsp;&emsp;当新报文到达时，要为新报文分配一个新的sk_buff，其大小等于报文的长度。sk_buff的data域指向报文的起始位置（以太网头）。如图所示，链路层驱动根据其头来发现下一个协议头，然后正确的处理这些指针。以以太网驱动的接收例程e100_rx()为例，它的环缓冲区中得到所接受报文的指针，然后从以太网头域中查找下一个协议层协议。它调用eth_type_trans()，eth_type_trans()将sk_buff的data指针向下移动以太网头的长度，使其指向IP头，该例程在sk_buff到IP backlog队列排队之前完成。源代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">net/ethernet/eth.c</div><div class="line"></div><div class="line">    unsigned short eth_type_trans(struct sk_buff *skb, struct net_device *dev)</div><div class="line">    &#123;</div><div class="line">        struct ethhdr *eth;</div><div class="line">        unsigned char *rawp;</div><div class="line">        /* 指向报文的起始位置 */</div><div class="line">        skb-&gt;mac.raw = skb-&gt;data;</div><div class="line">        /* 调用skb_pull()指向IP头 */</div><div class="line">        skb_pull(skb, dev-&gt;hard_header_len);</div><div class="line">        eth = skb-&gt;mac.ethernet;</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="sk-buff指向IP层要处理的IP头"><a href="#sk-buff指向IP层要处理的IP头" class="headerlink" title="sk_buff指向IP层要处理的IP头"></a>sk_buff指向IP层要处理的IP头</h4><p><img src="../../../../pictures/TCP/20171229211749.png" alt=""><br>&emsp;&emsp;现在sk_buff处于IP bakclog队列中，由netif_receive_skb()负责处理，该函数将sk_buff从backlog队列中取出。nh.raw指向sk_buff的data域，根据nh.iph可以直接访问IP头，源码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">net/core/dev.c</div><div class="line">    int netif_receive_skb(struct sk_buff *skb)</div><div class="line">    &#123;</div><div class="line">        struct packet_type *ptype, *pt_prev;</div><div class="line">        ......</div><div class="line">        skb-&gt;h.raw = skb-&gt;nh.raw = skb-&gt;data; </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="sk-buff指向TCP层要处理的TCP头"><a href="#sk-buff指向TCP层要处理的TCP头" class="headerlink" title="sk_buff指向TCP层要处理的TCP头"></a>sk_buff指向TCP层要处理的TCP头</h4><p><img src="../../../../pictures/TCP/20171229212735.png" alt=""><br>&emsp;&emsp;最后，一个IP陈例程ip_local_deliver_finish()处理发往下一个协议的报文，并将sk_buff的data指针向前移动IP头的长度（包括IP选项），使其指向传输层头。因此，当sk_buff传递给传输层处理例程时，h.th指针指向传输层头的起始位置，如上图所示。源码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">net/ipv4/ip_input.c</div><div class="line"></div><div class="line">    static inline int ip_local_deliver_finish(struct sk_buff *skb)</div><div class="line">    &#123;</div><div class="line">        int ihl = skb-&gt;nh.iph-&gt;ihl*4;</div><div class="line">        ......</div><div class="line">        __skb_pull(skb, ihl);</div><div class="line">        ......</div><div class="line">        skb-&gt;h.raw = skb-&gt;data;</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最后传输层调用tcp_v4_do_rcv()处理传输层头报文。如果连接已建立，并且TCP报文中有数据，就调用skb_copy_datatram_iovec()将从skb-&gt;data的偏移量$I_dth$开始的数据复制给用户应用程序。如果由于某些原因不能复制数据给用户应用程序，就将sk_buff的data指针向前移动TCP头的长度（包括选项），然后将其发往套接字的接受队列排队。源代码和skb_buff图如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">net/ipv4/tcp_input.c</div><div class="line"></div><div class="line">int tcp_rvc_established(struct sock *sk, struct sk_buff *skb)</div><div class="line">&#123;</div><div class="line">    struct tcp_opt *tp = &amp;(sk-&gt;tp_pinfo.af_tcp);</div><div class="line">    ......</div><div class="line">        /* 将sk_buff的data指针向前移动TCP头长度 */</div><div class="line">        __skb_pull(skb, tcp_header_len);</div><div class="line">        /* */</div><div class="line">        __skb_queue_tail(&amp;sk-&gt;receive_queue, skb);</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="../../../../pictures/TCP/20171230085652.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在上一篇博客说了sk_buff和协议头，这里说下如何构建向下遍历协议层时的协议头和解析向上遍历协议层时的协议头。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>sk_buff和协议头</title>
    <link href="http://yoursite.com/2017/12/26/sk-buff%E5%92%8C%E5%8D%8F%E8%AE%AE%E5%A4%B4/"/>
    <id>http://yoursite.com/2017/12/26/sk-buff和协议头/</id>
    <published>2017-12-26T00:23:44.000Z</published>
    <updated>2018-04-02T07:05:43.558Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在Linux TCP/IP协议栈中，sk_buff是代表网络报文的网络缓冲区。sk_buff有三个构成部分：sk_buff、线性数据缓冲区、分页数据（struct_skb_shared_info）。当请求sk_buff时，需要传递线性数据区域的长度。sk_buff中有一些页分别指向传输层、网络层和链路层头。<br>&emsp;&emsp;这篇博客主要讨论sk_buff结构中的各个域，以及处理sk_buff结构的头、尾、结束、数据以及长度域的函数，将对sk_buff结构的data_len域和处理该域的函数做出说明。还将阐述skb_shared_info结构以及该结构的用途，然后描述了各种与sk_buff复制和排队操作相关的各种函数。<br>&emsp;&emsp;sk_buff包含线性和非线性两部分的数据。线性数据由sk_buff的数据域表示。一般来说，能够在单页中容纳的IP报文才分配一页的线性数据。如果整个IP报文的长度超过了一页的容量，处理该报文就有两个选择。一种是分配一个长度可容纳整个IP报文的先行数据区，另一种是使用分页数据区来容纳报文的剩余部分（线性数据=1页，IP剩余部分则存储在sk_buff的分页数据区中）。<br><a id="more"></a></p>
<h4 id="结构sk-buff"><a href="#结构sk-buff" class="headerlink" title="结构sk_buff"></a>结构sk_buff</h4><p>&emsp;&emsp;在Linux中，sk_buff结构代表了一个报文，它由三个部分组成。<br>&emsp;&emsp;（1）sk_buff结构，也称为sk_buff头；<br>&emsp;&emsp;（2）包含数据的线性数据块；<br>&emsp;&emsp;（3）由struct skb_shared_info表示的非线性数据部分；<br>&emsp;&emsp;sk_buff结构包含指向特定协议头数据结构的指针域，因此，有些域包含了每一层的控制信息，以便构建协议头，同时还可以用来根据特定事件判断下一步的处理动作。有些域包含IP校验和，以及下一个协议信息。任何时候当要从某接口接收或者发送新报文时，都要为该数据块分配一个sk_buff结构，并将数据复制到sk_buff中，然后才进一步处理报文。根据需要，可以克隆（只复制sk_buff结构，但是共享数据块）或完全复制sk_buff（完全复制sk_buff结构，同时也复制了一份数据块）。<br>&emsp;&emsp;下面是sk_buff结构定义的代码块实现：<br>include/linux/skbuff.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">struct sk_buff &#123;</div><div class="line">    /*next和prev这两个域链接相关的sk_buff结构，当报文分段时，原始报文的每个分段</div><div class="line">     *通过next域链接在一起。</div><div class="line">     */</div><div class="line">    struct sk_buff *next; //指向下一个分段   </div><div class="line">    struct sk_buff *prev; //指向前一个分段</div><div class="line"></div><div class="line">    //list指针指向该sk_buff当前放置的队列或者列表</div><div class="line">    struct sk_buff_head *list;</div><div class="line">    struct sock *sk; //指向报文（sk_buff）所属套接字的指针</div><div class="line">    struct timeval stamp; //该域记录接收或者传输报文时刻的时间戳</div><div class="line"></div><div class="line">    /* 这是指向设备（struct net_device）的指针，报文通过此设备接收或者发送。</div><div class="line">     * net_device记录网络接口（数据链路层）信息以及该设备的相关操作。</div><div class="line">     */</div><div class="line">    struct net_device *dev;</div><div class="line"></div><div class="line">    /* 这是一个不同传输层头的指针联合，该域指向传输层头在报文中开始的位置 */</div><div class="line">    union &#123;</div><div class="line">        struct tcphdr  *th;</div><div class="line">        struct udphdr  *uh;</div><div class="line">        struct icmphdr *icmph;</div><div class="line">        struct igmphdr *igmph;</div><div class="line">        struct iphdr   *ipiph;</div><div class="line">        struct spxhdr  *spxh;</div><div class="line">        unsigned char  *raw;</div><div class="line">    &#125;h;</div><div class="line"></div><div class="line">    /* 这是一个不同网络层头的指针联合，该域指向网络层头在报文中开始的位置 */</div><div class="line">    union &#123;</div><div class="line">        struct iphdr    *iph;</div><div class="line">        struct ipv6hdr  *ipv6h;</div><div class="line">        struct arphdr   *arph;</div><div class="line">        struct ipxhdr   *ipxh;</div><div class="line">        unsigned char   *raw;</div><div class="line">    &#125;nh;</div><div class="line"></div><div class="line">    /* 这是一个不同MAC层头的指针联合，该域指向MAC层头在报文中开始的位置 */</div><div class="line">    union &#123;</div><div class="line">        struct ethhdr *ethernet;</div><div class="line">        unsigned char *raw;</div><div class="line">    &#125;max;</div><div class="line"></div><div class="line">    /* dst 指向dst_entry结构，该结构记录了到达给定目的地的路由信息，也记录了一</div><div class="line">     *些给定连接相关的网络特征信息，如PMTU、RTT等。</div><div class="line">     */</div><div class="line">    struct dst_entry *dst;</div><div class="line">    /* 该域保存协议相关的控制信息，每个协议层可能独立的使用这些信息。*/</div><div class="line">    char             cb[48];</div><div class="line"></div><div class="line">    unsigned int len; //该域记录sk_buff中数据的总长度</div><div class="line">    unsigned int data_len; //只有当sk_buff中有非线性数据时才使用该域</div><div class="line">    unsigned int csum; //这是某时刻协议的校验和</div><div class="line">    unsigned int char __unused, </div><div class="line">                 cloned, //该域保存当前sk_buff是原始数据还是克隆数据的信息</div><div class="line">                 /* 该域包含报文类型信息。类型通常为多播、广播、回路、主机、其</div><div class="line">                  * 他主机、传出等。</div><div class="line">                  */</div><div class="line">                 pkt_type,</div><div class="line">                 ip_summed; //该域表示驱动是否计算IP校验和</div><div class="line">    __u32 priority; //该域保存报文的排队优先级信息，这基于IP头中的TOS域</div><div class="line">    atomic_t users; //该域保存引用了sk_buff的数量</div><div class="line"></div><div class="line">     /* 该域保存了下一个协议层信息，在处理报文时由当前协议层设置 */</div><div class="line">    unsigned short protocol;</div><div class="line">    unsigned short security; //该域保存报文的安全级别</div><div class="line"></div><div class="line">     /* 该域保存为该缓冲区所分配的总内存。它包括sk_buff结构的大小+分配给该</div><div class="line">      * sk_buff的数据块的大小。</div><div class="line">      */</div><div class="line">    unsigned int truesize;</div><div class="line"></div><div class="line">    /* 该域指向线性数据区的开始（为sk_buff分配的线性数据区的首字节） */</div><div class="line">    unsigned char *head; </div><div class="line">    /* 该域指向驻留在线性数据区的数据的起始位置。驻留在线性数据区中的数据可能并</div><div class="line">     * 不总是从线性数据区的起始head开始。</div><div class="line">     */</div><div class="line">    unsigned char *data;</div><div class="line">    unsigned char *tail; //该域指向驻留在线性数据区的最后一个字节的数据</div><div class="line"></div><div class="line">    /* 该域指向线性数据区的结尾，与tail不同。驻留在线性数据区中的数据结尾并不是</div><div class="line">     * 总是在线性数据区的结尾。利用该域可以确保我们没有使用超出可用存储的缓冲区</div><div class="line">     */</div><div class="line">    unsigned char *end;</div><div class="line">    ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;head、data、end、tail这4个域维护了线性数据区，当为新的sk_buff分配缓冲区时，需要提供线性数据区的大小。同时还要初始化sk_buff的这4个域，以指向线性数据区中合适的位置。下图是当skb_alloc()刚返回时的sk_buff结构：<br><img src="../../../../pictures/TCP/20171226114708.png" alt=""></p>
<h4 id="结构skb-shared-info"><a href="#结构skb-shared-info" class="headerlink" title="结构skb_shared_info"></a>结构skb_shared_info</h4><p>&emsp;&emsp;处于线性数据区结尾的结构，包含sk_buff的分段信息和非线性数据信息。<br>include/linux/skbuff.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct skb_shared_info &#123;</div><div class="line">    atomic_t        dataref; //该域保存skb_shared_info对象的引用次数</div><div class="line"></div><div class="line">     /* 该域保存sk_buff分页段的数目，它表示frags[]</div><div class="line">      * 数组的元素数量，该数组包含sk_buff的分页数据。</div><div class="line">      */</div><div class="line">    unsigned int nr_frags;</div><div class="line"></div><div class="line">    /* 该域是一个指向原始报文（frag_list所属的sk_buff）sk_buffs分段列表的指针。</div><div class="line">     * 如果原始报文需要分段，所有表示这些分配的sk_buffs将链接到该链表中。</div><div class="line">     */ </div><div class="line">    struct sk_buff  *frag_list;</div><div class="line">    /* 该域是分段的数组，这些分段包含sk_buff的分页数据。分页数据由</div><div class="line">    *  skb_frag_struct表示，分页数据（由frags[]表示）的数据长度是每个页段中所含字节数（frags[i]-&gt;size）的总和，并存储在sk_buff的data_len域。</div><div class="line">    */</div><div class="line">    skb_frag_t      frags[MAX_SKB_FRAGS]; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="sk-buff和DMA-skb-frag-struct"><a href="#sk-buff和DMA-skb-frag-struct" class="headerlink" title="sk_buff和DMA-skb_frag_struct"></a>sk_buff和DMA-skb_frag_struct</h4><p>&emsp;&emsp;该结构是一个描述符，描述了包含sk_buff分页数据的每个分页段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct skb_frag_struct &#123;</div><div class="line">    /* 该域是一个指向页结构的指针，页结构包含了分页数据。每个分页段都包含了一页</div><div class="line">     * 所容纳的最大数据。</div><div class="line">     */</div><div class="line">    struct page *page; </div><div class="line">    __u16 page_offset; //该域是页偏移量指针，指向本页数据的起始位置</div><div class="line">    __u16 size; //该域是page域所指页中数据的总长度</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="sk-buff例程操作"><a href="#sk-buff例程操作" class="headerlink" title="sk_buff例程操作"></a>sk_buff例程操作</h4><p>（1） alloc_skb()<br>&emsp;&emsp;该函数分配一个新的sk_buff，该函数的参数为数据区的长度和内存分配的模式。数据区是分配给sk_buff的内存块，报文在这个数据区中构造。当alloc_skb()放回时，head、data、tail和end指针的位置在前面的图中已经给出了。可以看出，内存分配完成后，tail空间等于为sk_buff所请求的数据块的长度，head空间和数据长度则为0。<br>（2） skb_reserve()<br>&emsp;&emsp;该函数会改变sk_buff的head和tail空间，它主要用来为协议头预留空间。当需要为协议头保留空间时，就调用该函数，并向其传递头空间的长度。如下图所示。<br><img src="../../../../pictures/TCP/20171227101518.png" alt=""><br>（3） skb_put()<br>&emsp;&emsp;该例程用来处理sk_buff的线性数据区。该函数为分段数据在线性数据区的结尾预留空间。在大部分情况下，用户数据将在此处理，或者说TCP/UDP载荷在此处复制，它为报文载荷创建空间，如下图所示。<br><img src="../../../../pictures/TCP/20171227102803.png" alt=""><br>下面是skb_put()的源码<br>include/linux/skbuff.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)</div><div class="line">&#123;</div><div class="line">    unsigned char *tmp = skb-&gt;tail; //记录sk_buff的原始tail域</div><div class="line">    SKB_LINEAR_ASSERT(skb);</div><div class="line">    /* tail域加上请求的长度值，修改后的tail域扩展了sk_buff的总长度。</div><div class="line">     * 同样skb-&gt;len也要加上请求的长度值。</div><div class="line">     */</div><div class="line">    skb-&gt;tail += len; </div><div class="line">    skb-&gt;len += len;</div><div class="line">    /* 做完善性检查，以确保tail没有超过线性数据区的结束（skb-&gt;end）*/</div><div class="line">    if (skb-&gt;tail&gt;skb-&gt;end) &#123;</div><div class="line">        skb_over_panic(skb, len, current_text_addr());</div><div class="line">    &#125;</div><div class="line">    return tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（4） skb_push()<br>&emsp;&emsp;该函数处理sk_buff的data域，仅操作线性数据区。它将data域向head推进一个值，该值是以参数传递给该函数的字节数。数据长度增加多少，头空间就减少多少。skb_push()函数的源码如下所示。<br>include/linux/skbuff.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static inline unsigned char *skb_push()</div><div class="line">&#123;</div><div class="line">    skb-&gt;data -= len; //data根据请求的长度减少</div><div class="line">    /* data域向head的推导导致整个sk_buff长度的扩展，sk_buff的长度将增加请求的长</div><div class="line">     * 度。</div><div class="line">     */</div><div class="line">    skb-&gt;len += len;</div><div class="line">    /* 进行完善性检查*/</div><div class="line">    if (skb-&gt;data&lt;skb-&gt;head) &#123;</div><div class="line">        skb_under_panic(skb, len, current_text_addr());</div><div class="line">    &#125;</div><div class="line">    /* 检查通过，将一个数据指针引用放回给调用者。 */</div><div class="line">    return skb-&gt;data;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="../../../../pictures/TCP/20171229115947.png" alt=""><br>&emsp;&emsp;下图给出了调用skb_push()来处理data域的情形。$l_0$是sk_buff的原始长度，其中虚线表示data域指针。$l_r$是调用skb_push()所请求的长度。skb_push()处理完sk_buff后，线性数据区的总长度变为$l<em>r+l</em> 0$，黑线表示数据指针。<br>（5）skb_pull()<br>&emsp;&emsp;这个函数根据字节移动数据指针，字节数则以参数的形式传递给该函数，然后返回新的数据指针。它通过修改sk_buff的data域来处理sk_buff的线性数据区。该函数将skb-&gt;len减小请求的字节数大小，从而增加了sk_buff线性数据区头空间的大小。下面是源代码。<br>include/linux/skbuff.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static inline unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)</div><div class="line">&#123;</div><div class="line">    if (len &gt; skb-&gt;len)</div><div class="line">        return NULL;</div><div class="line">    return __skb_pull(skb, len);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static inline char *__skb_pull(struct sk_buff *skb, unsigned int len)</div><div class="line">&#123;</div><div class="line">    skb-&gt;len -= len;</div><div class="line">    if (skb-&gt;len &lt; skb-&gt;data_len)</div><div class="line">        out_of_line_bug();</div><div class="line">    return skb-&gt;data += len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在Linux TCP/IP协议栈中，sk_buff是代表网络报文的网络缓冲区。sk_buff有三个构成部分：sk_buff、线性数据缓冲区、分页数据（struct_skb_shared_info）。当请求sk_buff时，需要传递线性数据区域的长度。sk_buff中有一些页分别指向传输层、网络层和链路层头。&lt;br&gt;&amp;emsp;&amp;emsp;这篇博客主要讨论sk_buff结构中的各个域，以及处理sk_buff结构的头、尾、结束、数据以及长度域的函数，将对sk_buff结构的data_len域和处理该域的函数做出说明。还将阐述skb_shared_info结构以及该结构的用途，然后描述了各种与sk_buff复制和排队操作相关的各种函数。&lt;br&gt;&amp;emsp;&amp;emsp;sk_buff包含线性和非线性两部分的数据。线性数据由sk_buff的数据域表示。一般来说，能够在单页中容纳的IP报文才分配一页的线性数据。如果整个IP报文的长度超过了一页的容量，处理该报文就有两个选择。一种是分配一个长度可容纳整个IP报文的先行数据区，另一种是使用分页数据区来容纳报文的剩余部分（线性数据=1页，IP剩余部分则存储在sk_buff的分页数据区中）。&lt;br&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TCP拥塞控制之CUBIC</title>
    <link href="http://yoursite.com/2017/12/21/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8BCUBIC/"/>
    <id>http://yoursite.com/2017/12/21/TCP拥塞控制之CUBIC/</id>
    <published>2017-12-21T12:00:34.000Z</published>
    <updated>2017-12-30T01:06:25.615Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;CUBIC是当前Linux系统上默认的拥塞控制算法。它的拥塞控制窗口增长函数是一个三次函数，这样设计的目的是为了在当前的快速和长距离网络环境中有更好的扩展性。CUBIC的拥塞窗口增长独立于RTT，因此能更好的保证流与流之间的公平性。<br><a id="more"></a></p>
<h3 id="问题是什么"><a href="#问题是什么" class="headerlink" title="问题是什么"></a>问题是什么</h3><p>&emspp;&emsp;当今的因特网朝着速度更快，距离更长的趋势发展，致使针对传统网络设计的TCP算法性能受到了挑战。上面的网络特性用一个专业名词描述叫做高BDP（bandwidth and delay product），它代表了带宽被完全利用时网络中能容纳的数据包总量。<br>&emsp;&emsp;传统的TCP算法，例如TCP-Reno，TCP-NewReno，TCP-SACK等之所以在新环境下不能充分利用网络带宽，主要是因为在进入拥塞避免阶段后，它们的拥塞窗口每经过一个RTT才加1，拥塞窗口的增长速度太慢，当碰上高带宽环境时，可能需要经历很多个RTT，拥塞窗口才能接近于一个BDP。如果数据流很短，可能拥塞窗口还没增长到一个BDP，数据流就已经结束了，这种情况的带宽利用率就会非常低。</p>
<h3 id="已存在的方法"><a href="#已存在的方法" class="headerlink" title="已存在的方法"></a>已存在的方法</h3><p>&emsp;&emsp;为了解决上面提到的TCP低利用率问题，有很新的TCP变体被提出来，例如FAST，HSTCP，STCP，HTCP，SQRT，West-wood和BIC-TCP。这些算法都号称能在很短的时间内提高网络传输速率。在Linux内核2.6.8版本里，BIC-TCP被选为默认算法，其他算法也实施在Linux内核里作为可选项。BIC-TCP相比其他算法的优点是其稳定性。下面就花点篇幅介绍下BIC-TCP算法。</p>
<h4 id="BIC-TCP"><a href="#BIC-TCP" class="headerlink" title="BIC-TCP"></a>BIC-TCP</h4><p>&emsp;&emsp;BIC-TCP采用二分搜索的方式来决定拥塞窗口的增长尺度，首先它会记录拥塞窗口的一个最大值点，这个最大值就是TCP最近一次出现丢包时拥塞窗口的值；还会记录一个最小值点，即在一个RTT周期内没有出现丢包事件时窗口的大小。二分搜索就是取最小值和最大值的中间点，当拥塞窗口增长到这个中间值且没有出现丢包的话，就说明网络还可以容纳更多的数据包。那么将这个中值设为新的最小值，在新的最小值和最大值间搜索中间值。当当前拥塞窗口的值还远没有达到通道的容量时，其增长速度很快；相反，当拥塞窗口的值接近于通道的容量时，其拥塞窗口增长函数是一个简化的对数凹函数。这个凹函数使拥塞窗口在饱和点或平衡点比凸函数或线性函数保持更长的时间，在饱和点处，凹函数和线性函数它们具有最大的窗口增量，因此在丢包发生时会出现大量的数据包被丢失。<br><img src="../../../../pictures/paper read/20171223094737.png" alt=""><br>&emsp;&emsp;BIC-TCP的主要特征是在前面说过的其独特的窗口增长函数，图1给出了BIC-TCP的窗口增长函数。当出现丢包事件时，BIC-TCP通过乘以因子$\beta$来缩小窗口，缩小之前的窗口大小被设置为最大$W_max$，并且缩小之后的窗口大小被设置为最小值$W_min$。 然后，BIC-TCP使用这两个参数执行二分搜索，拥塞窗口的下一个取值会是$W_max$和$W_min$之间的“中点”$W_mid$。<br>&emsp;&emsp;为了防止拥塞窗口从$W_min$增长到$W_mid$的步长$step$太大，BIC-TCP还设置了一个常数$S_max$，当$step$&gt;$S_max$时，BIC-TCP会取下一个增长点为$W_min$+$S_max$而不是$W_mid$，如果没有出现丢包的话，再更新$W_min$，直到$step$&lt;$S_max$为止。与此同时BIC-TCP还设置一个另一个控制参数$S_min$，当窗口增量小于$S_min$时，BIC-TCP会将当前拥塞窗口值设为最大值。<br>&emsp;&emsp;如果窗口增长超过最大值，则说明当前窗口最大值还不是一个饱和点，网络还可以容纳更多的数据包，窗口还有增长的空间，一个新的窗口最大值需要被探索。于是BIC-TCP会进入一个新的阶段，叫做最大值探索阶段。最大探测使用一个与在加法增长和二分搜索阶段（这是对数;其倒数将是指数）完全对称的窗口增长函数。图1中给出了在最大探索阶段期间的窗口增长函数。在最大探测期间，窗口最初缓慢地增长以发现附近新的最大值，经过一段时间的缓慢增长，如果没有找到新的最大值（即，没出现包丢失），则它猜测新的最大值离得很远，所以它给窗口大小增加一个大的固定增量，使用加法增加切换到更快的增加速度。BIC-TCP的良好性能来自$W_max$附近的缓慢增加和在加法增加和最大探测期间的线性增加。</p>
<h3 id="什么是CUBIC"><a href="#什么是CUBIC" class="headerlink" title="什么是CUBIC"></a>什么是CUBIC</h3><p>&emsp;&emsp;CUBIC是BIC-TCP的下一代版本。 它通过用三次函数（包含凹和凸部分）代替BIC-TCP的凹凸窗口生长部分，大大简化了BIC-TCP的窗口调整算法。实际上，任何奇数阶多项式函数都具有这种形状。三次函数的选择是偶然的，并且不方便。CUBIC的关键特征是其窗口增长仅取决于两个连续拥塞事件之间的时间。一个拥塞事件是指出现TCP快速恢复的时间。因此，窗口增长与RTT无关。 这个特性允许CUBIC流在同一个瓶颈中竞争，有相同的窗口大小，而不依赖于它们的RTT，从而获得良好的RTT公平性。而且，当RTT较短时，由于窗口增长率是固定的，其增长速度可能比TCP标准慢。 由于TCP标准（例如，TCP-SACK）在短RTT下工作良好，因此该特征增强了协议的TCP友好性。</p>
<h4 id="CUBIC的窗口增长函数"><a href="#CUBIC的窗口增长函数" class="headerlink" title="CUBIC的窗口增长函数"></a>CUBIC的窗口增长函数</h4><p>&emsp;&emsp;BIC-TCP在高速网络中实现了良好的可扩展性，在自身的竞争流之间是公平的，并且具有低窗口振荡的稳定性。但BIC-TCP的窗口增长函数对于TCP来说还是过于激进，特别是在短RTT或低速网络中。于是有了CUBIC，CUBIC保留了BIC-TCP的稳定性和可扩展性的优点，同时简化了窗口控制和加强了TCP友好性。<br><img src="../../../../pictures/paper read/20171223095005.png" alt=""><br>&emsp;&emsp;CUBIC的窗口增长函数是一个三次函数，非常类似于BIC-TCP的窗口增长函数，CUBIC的函数图像如图2所示。CUBIC的详细运行过程如下，当出现丢包事件时，CUBIC同BIC-TCP一样，会记录这时的拥塞窗口大小作为$W_max$，接着通过因子$\beta$执行拥塞窗口的乘法减小，这里$\beta$是一个窗口降低常数，并进行正常的TCP快速恢复和重传。从快速恢复阶段进入拥塞避免后，使用三次函数的凹轮廓增加窗口。三次函数被设置在$W_max$处达到稳定点，然后使用三次函数的凸轮廓开始探索新的最大窗口，如果新的最大窗口存在的话。<br>&emsp;&emsp;CUBIC的窗口增长函数公式如下所示：<br>$$W(t)=C(t-K)^3+W_max \quad (1)$$<br>这里，C是一个CUBIC的参数，t是从窗口上次降低开始到现在的时间，是一个弹性值，而K是上述函数在没有进一步丢包的情况下将$W$增加到$W_max$经历的时间，其计算公式如下：<br>$$K=\sqrt[3]{\frac{W_max*\beta}{C}} \quad (2)$$<br>在拥塞避免阶段每收到一个ACK，CUBIC都会使用方程（1）计算在下个RTT的窗口增长速率。CUBIC使用$W(t+RTT)$作为拥塞窗口的候选值，假设当前拥塞窗口大小为$cwnd$。根据$cwnd$的值，CUBIC有三种运行模式。首先，如果cwnd小于（标准）TCP在上次丢包事件之后t时刻到达的窗口大小，那么CUBIC处于TCP模式（我们将在下面描述如何根据时间确定标准TCP的窗口大小）。否则，如果$cwnd$小于$W_max$，那么CUBIC在三次函数的凹轮廓区域，如果$cwnd$大于$W_max$，那么，CUBIC处于三次函数的凸轮廓区域。</p>
<h4 id="TCP友好型区域"><a href="#TCP友好型区域" class="headerlink" title="TCP友好型区域"></a>TCP友好型区域</h4><p>&emsp;&emsp;这小节主要说了怎么判断在发生丢包事件后，标准TCP在$t$时刻的窗口大小。</p>
<h4 id="凹区域"><a href="#凹区域" class="headerlink" title="凹区域"></a>凹区域</h4><p>&emsp;&emsp;当在拥塞避免阶段收到一个ACK，如果协议不处于TCP模式，且$cwnd$小于$W_max$，那么，协议就处于凹区域，在这个区域，$cwnd$的增量为<br>$$\frac{W(t+RTT)-cwnd}{cwnd}$$</p>
<h4 id="凸区域"><a href="#凸区域" class="headerlink" title="凸区域"></a>凸区域</h4><p>&emsp;&emsp;如果协议不处于TCP模式，且$cwnd$大于饱和点$W_max$，那么协议处于凸区域，$cwnd$的增量为<br>$$\frac{W(t+RTT)-cwnd}{cwnd}$$<br>其实凸区域的增长函数和凹区域的增长函数一样，只不过凸区域越过了饱和点，而其区域没有越过饱和点。</p>
<h4 id="乘法降低"><a href="#乘法降低" class="headerlink" title="乘法降低"></a>乘法降低</h4><p>&emsp;&emsp;当出现数据包丢失时，CUBIC会通过乘以因子$\beta$来降低拥塞窗口，这里取$\beta=0.2$，设置$\beta$小于0.5的副作用是收敛较慢。虽然更适应性的设置会导致更快的收敛，但是会使协议的分析变得更加困难，并影响协议的稳定性。</p>
<h4 id="快速收敛"><a href="#快速收敛" class="headerlink" title="快速收敛"></a>快速收敛</h4><p>&emsp;&emsp;为了提高CUBIC的收敛速度，在协议中加入了启发式。当新的流量加入网络时，网络中的现有流量需要放弃其带宽份额，以使新流量有一定的增长空间。下面详细描述一下快速收敛的过程。在发生丢包前，CUBIC会记录一个最大窗口值$W_max$，当发生丢包后，在降低窗口前，CUBIC又会记录当前的窗口值作为新的$W_max$，为了不至于混淆，可以将之前记录的$W_max$标记位$W_lastmax$。当发生丢包时，CUBIC会比较$W_lastmax$的$W_max$大小，如果$W_max$小于$W_lastmax$，这表明由于可用带宽的变化，该流所经历的饱和点正在降低。这种情况下，CUBIC的做法是通过进一步的减小$W_max$来释放更多的可用带宽。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;CUBIC是当前Linux系统上默认的拥塞控制算法。它的拥塞控制窗口增长函数是一个三次函数，这样设计的目的是为了在当前的快速和长距离网络环境中有更好的扩展性。CUBIC的拥塞窗口增长独立于RTT，因此能更好的保证流与流之间的公平性。&lt;br&gt;
    
    </summary>
    
      <category term="私人文献阅读" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
</feed>
